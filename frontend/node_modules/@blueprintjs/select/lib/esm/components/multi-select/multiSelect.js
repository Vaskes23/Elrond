import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
/*
 * Copyright 2022 Palantir Technologies, Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import classNames from "classnames";
import { createElement, createRef } from "react";
import { AbstractPureComponent, Button, Classes as CoreClasses, DISPLAYNAME_PREFIX, mergeRefs, Popover, PopupKind, refHandler, setRef, TagInput, Utils, } from "@blueprintjs/core";
import { Cross } from "@blueprintjs/icons";
import { Classes } from "../../common";
import { QueryList } from "../query-list/queryList";
/**
 * Multi select component.
 *
 * @see https://blueprintjs.com/docs/#select/multi-select
 */
export class MultiSelect extends AbstractPureComponent {
    constructor() {
        var _a;
        super(...arguments);
        this.listboxId = Utils.uniqueId("listbox");
        this.state = {
            isOpen: (this.props.popoverProps && this.props.popoverProps.isOpen) || false,
        };
        this.input = null;
        this.queryList = null;
        this.refHandlers = {
            input: refHandler(this, "input", (_a = this.props.tagInputProps) === null || _a === void 0 ? void 0 : _a.inputRef),
            popover: createRef(),
            queryList: (ref) => (this.queryList = ref),
        };
        this.renderQueryList = (listProps) => {
            var _a;
            const { disabled, popoverContentProps = {}, popoverProps = {} } = this.props;
            const { handleKeyDown, handleKeyUp } = listProps;
            // N.B. no need to set `popoverProps.fill` since that is unused with the `renderTarget` API
            return (_jsx(Popover, { autoFocus: false, canEscapeKeyClose: true, disabled: disabled, enforceFocus: false, isOpen: this.state.isOpen, placement: popoverProps.position || popoverProps.placement ? undefined : "bottom-start", ...popoverProps, className: classNames(listProps.className, popoverProps.className), content: _jsxs("div", { 
                    // In the case where customTarget is supplied and the TagInput is rendered within the Popover,
                    // without matchTargetWidth there is no width defined in any of TagInput's
                    // grandparents when it's rendered through usePortal, so it will never flex-wrap
                    // and infinitely grow horizontally. To address this, if there is no width guidance
                    // from matchTargetWidth, explicitly set a default width to so Tags will flex-wrap.
                    className: this.props.customTarget != null && !((_a = this.props.popoverProps) === null || _a === void 0 ? void 0 : _a.matchTargetWidth)
                        ? Classes.MULTISELECT_POPOVER_DEFAULT_WIDTH
                        : undefined, ...popoverContentProps, onKeyDown: handleKeyDown, onKeyUp: handleKeyUp, children: [this.props.customTarget != null &&
                            this.getTagInput(listProps, classNames(CoreClasses.FILL, Classes.MULTISELECT_POPOVER_TAG_INPUT_MARGIN)), listProps.itemList] }), interactionKind: "click", onInteraction: this.handlePopoverInteraction, onOpened: this.handlePopoverOpened, popoverClassName: classNames(Classes.MULTISELECT_POPOVER, popoverProps.popoverClassName), popupKind: PopupKind.LISTBOX, ref: mergeRefs(this.refHandlers.popover, this.props.popoverRef), renderTarget: this.getPopoverTargetRenderer(listProps, this.state.isOpen) }));
        };
        // We use the renderTarget API to flatten the rendered DOM and make it easier to implement features like
        // the "fill" prop. Note that we must take `isOpen` as an argument to force this render function to be called
        // again after that state changes.
        this.getPopoverTargetRenderer = (listProps, isOpen) => 
        // N.B. pull out `isOpen` so that it's not forwarded to the DOM, but remember not to use it directly
        // since it may be stale (`renderTarget` is not re-invoked on this.state changes).
        // eslint-disable-next-line react/display-name
        ({ isOpen: _isOpen, ref, ...targetProps }) => {
            const { disabled, fill, selectedItems, popoverProps = {}, popoverTargetProps = {} } = this.props;
            const { handleKeyDown, handleKeyUp } = listProps;
            const { targetTagName = "div" } = popoverProps;
            return createElement(targetTagName, {
                "aria-autocomplete": "list",
                "aria-controls": this.listboxId,
                ...popoverTargetProps,
                ...targetProps,
                "aria-disabled": disabled,
                "aria-expanded": isOpen,
                // Note that we must set FILL here in addition to TagInput to get the wrapper element to full width
                className: classNames(targetProps.className, popoverTargetProps.className, {
                    [CoreClasses.FILL]: fill,
                }),
                // Normally, Popover would also need to attach its own `onKeyDown` handler via `targetProps`,
                // but in our case we fully manage that interaction and listen for key events to open/close
                // the popover, so we elide it from the DOM.
                onKeyDown: this.getTagInputKeyDownHandler(handleKeyDown),
                onKeyUp: this.getTagInputKeyUpHandler(handleKeyUp),
                ref,
                role: "combobox",
            }, this.props.customTarget != null
                ? this.props.customTarget(selectedItems, isOpen)
                : this.getTagInput(listProps));
        };
        this.getTagInput = (listProps, className) => {
            var _a;
            const { disabled, fill, onClear, placeholder, selectedItems, tagInputProps = {} } = this.props;
            const maybeClearButton = onClear !== undefined && selectedItems.length > 0 ? (
            // use both aria-label and title a11y attributes here, for screen readers
            // and mouseover interactions respectively
            _jsx(Button, { "aria-label": "Clear selected items", disabled: disabled, icon: _jsx(Cross, {}), onClick: this.handleClearButtonClick, title: "Clear selected items", variant: "minimal" })) : undefined;
            // add our own inputProps.className so that we can reference it in event handlers
            const inputProps = {
                ...tagInputProps.inputProps,
                className: classNames((_a = tagInputProps.inputProps) === null || _a === void 0 ? void 0 : _a.className, Classes.MULTISELECT_TAG_INPUT_INPUT),
            };
            return (_jsx(TagInput, { placeholder: placeholder, rightElement: maybeClearButton, ...tagInputProps, className: classNames(className, Classes.MULTISELECT, tagInputProps.className), disabled: disabled, fill: fill, inputRef: this.refHandlers.input, inputProps: inputProps, inputValue: listProps.query, onAdd: this.getTagInputAddHandler(listProps), onInputChange: listProps.handleQueryChange, onRemove: this.handleTagRemove, values: selectedItems.map(this.props.tagRenderer) }));
        };
        this.handleItemSelect = (item, evt) => {
            var _a, _b, _c;
            if (this.input != null) {
                this.input.focus();
            }
            (_b = (_a = this.props).onItemSelect) === null || _b === void 0 ? void 0 : _b.call(_a, item, evt);
            (_c = this.refHandlers.popover.current) === null || _c === void 0 ? void 0 : _c.reposition(); // reposition when size of input changes
        };
        this.handleQueryChange = (query, evt) => {
            var _a, _b;
            this.setState({ isOpen: query.length > 0 || (this.props.customTarget == null && !this.props.openOnKeyDown) });
            (_b = (_a = this.props).onQueryChange) === null || _b === void 0 ? void 0 : _b.call(_a, query, evt);
        };
        // Popover interaction kind is CLICK, so this only handles click events.
        // Note that we defer to the next animation frame in order to get the latest activeElement
        this.handlePopoverInteraction = (nextOpenState, evt) => {
            var _a, _b;
            if (this.props.customTarget != null) {
                this.setState({ isOpen: nextOpenState });
                (_b = (_a = this.props.popoverProps) === null || _a === void 0 ? void 0 : _a.onInteraction) === null || _b === void 0 ? void 0 : _b.call(_a, nextOpenState, evt);
                return;
            }
            this.requestAnimationFrame(() => {
                var _a, _b;
                const isInputFocused = this.input === Utils.getActiveElement(this.input);
                if (this.input != null && !isInputFocused) {
                    // input is no longer focused, we should close the popover
                    this.setState({ isOpen: false });
                }
                else if (!this.props.openOnKeyDown) {
                    // we should open immediately on click focus events
                    this.setState({ isOpen: true });
                }
                (_b = (_a = this.props.popoverProps) === null || _a === void 0 ? void 0 : _a.onInteraction) === null || _b === void 0 ? void 0 : _b.call(_a, nextOpenState, evt);
            });
        };
        this.handlePopoverOpened = (node) => {
            var _a, _b, _c, _d;
            if (this.queryList != null) {
                // scroll active item into view after popover transition completes and all dimensions are stable.
                this.queryList.scrollActiveItemIntoView();
            }
            const hasCustomTarget = this.props.customTarget != null;
            if (hasCustomTarget && this.input != null) {
                const shouldAutofocus = ((_b = (_a = this.props.tagInputProps) === null || _a === void 0 ? void 0 : _a.inputProps) === null || _b === void 0 ? void 0 : _b.autoFocus) !== false;
                if (shouldAutofocus) {
                    this.input.focus();
                }
            }
            (_d = (_c = this.props.popoverProps) === null || _c === void 0 ? void 0 : _c.onOpened) === null || _d === void 0 ? void 0 : _d.call(_c, node);
        };
        this.handleTagRemove = (tag, index) => {
            var _a, _b;
            const { selectedItems, onRemove, tagInputProps } = this.props;
            onRemove === null || onRemove === void 0 ? void 0 : onRemove(selectedItems[index], index);
            (_a = tagInputProps === null || tagInputProps === void 0 ? void 0 : tagInputProps.onRemove) === null || _a === void 0 ? void 0 : _a.call(tagInputProps, tag, index);
            (_b = this.refHandlers.popover.current) === null || _b === void 0 ? void 0 : _b.reposition(); // reposition when size of input changes
        };
        this.getTagInputAddHandler = (listProps) => (values, method) => {
            if (method === "paste") {
                listProps.handlePaste(values);
            }
        };
        this.getTagInputKeyDownHandler = (handleQueryListKeyDown) => {
            return (e) => {
                var _a, _b, _c;
                if (e.key === "Escape" || e.key === "Tab") {
                    // By default the escape key will not trigger a blur on the
                    // input element. It must be done explicitly.
                    if (e.key === "Escape") {
                        (_a = this.input) === null || _a === void 0 ? void 0 : _a.blur();
                        // prevent other overlays from closing
                        e.stopPropagation();
                        // prevent browser-specific escape key behavior (Safari exits fullscreen)
                        e.preventDefault();
                    }
                    this.setState({ isOpen: false });
                }
                else if (!(e.key === "Backspace" || e.key === "ArrowLeft" || e.key === "ArrowRight")) {
                    // Custom target might not be an input, so certain keystrokes might have other effects (space pushing the scrollview down)
                    if (this.props.customTarget != null) {
                        if (e.key === " ") {
                            e.preventDefault();
                            this.setState({ isOpen: true });
                        }
                        else if (e.key === "Enter") {
                            this.setState({ isOpen: true });
                        }
                    }
                    else {
                        this.setState({ isOpen: true });
                    }
                }
                const isTargetingTagRemoveButton = e.target.closest(`.${CoreClasses.TAG_REMOVE}`) != null;
                if (this.state.isOpen && !isTargetingTagRemoveButton) {
                    handleQueryListKeyDown === null || handleQueryListKeyDown === void 0 ? void 0 : handleQueryListKeyDown(e);
                }
                (_c = (_b = this.props.popoverTargetProps) === null || _b === void 0 ? void 0 : _b.onKeyDown) === null || _c === void 0 ? void 0 : _c.call(_b, e);
            };
        };
        this.getTagInputKeyUpHandler = (handleQueryListKeyUp) => {
            return (e) => {
                var _a, _b;
                const isTargetingInput = e.target.classList.contains(Classes.MULTISELECT_TAG_INPUT_INPUT);
                // only handle events when the focus is on the actual <input> inside the TagInput, as that's
                // what QueryList is designed to do
                if (this.state.isOpen && isTargetingInput) {
                    handleQueryListKeyUp === null || handleQueryListKeyUp === void 0 ? void 0 : handleQueryListKeyUp(e);
                }
                (_b = (_a = this.props.popoverTargetProps) === null || _a === void 0 ? void 0 : _a.onKeyDown) === null || _b === void 0 ? void 0 : _b.call(_a, e);
            };
        };
        this.handleClearButtonClick = () => {
            var _a, _b, _c;
            (_b = (_a = this.props).onClear) === null || _b === void 0 ? void 0 : _b.call(_a);
            (_c = this.refHandlers.popover.current) === null || _c === void 0 ? void 0 : _c.reposition(); // reposition when size of input changes
        };
    }
    /** @deprecated no longer necessary now that the TypeScript parser supports type arguments on JSX element tags */
    static ofType() {
        return MultiSelect;
    }
    componentDidUpdate(prevProps) {
        var _a, _b, _c, _d, _e;
        if (((_a = prevProps.tagInputProps) === null || _a === void 0 ? void 0 : _a.inputRef) !== ((_b = this.props.tagInputProps) === null || _b === void 0 ? void 0 : _b.inputRef)) {
            setRef((_c = prevProps.tagInputProps) === null || _c === void 0 ? void 0 : _c.inputRef, null);
            this.refHandlers.input = refHandler(this, "input", (_d = this.props.tagInputProps) === null || _d === void 0 ? void 0 : _d.inputRef);
            setRef((_e = this.props.tagInputProps) === null || _e === void 0 ? void 0 : _e.inputRef, this.input);
        }
        if ((prevProps.onClear === undefined && this.props.onClear !== undefined) ||
            (prevProps.onClear !== undefined && this.props.onClear === undefined)) {
            this.forceUpdate();
        }
    }
    render() {
        // omit props specific to this component, spread the rest.
        const { menuProps, openOnKeyDown, popoverProps, tagInputProps, customTarget, ...restProps } = this.props;
        return (_jsx(QueryList, { ...restProps, menuProps: {
                "aria-label": "selectable options",
                ...menuProps,
                "aria-multiselectable": true,
                id: this.listboxId,
            }, onItemSelect: this.handleItemSelect, onQueryChange: this.handleQueryChange, ref: this.refHandlers.queryList, renderer: this.renderQueryList }));
    }
}
MultiSelect.displayName = `${DISPLAYNAME_PREFIX}.MultiSelect`;
MultiSelect.defaultProps = {
    disabled: false,
    fill: false,
    placeholder: "Search...",
};
//# sourceMappingURL=multiSelect.js.map