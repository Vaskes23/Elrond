{"ast":null,"code":"/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Named modifier keys\n *\n * @see https://www.w3.org/TR/uievents-key/#keys-modifier\n */\nconst MODIFIER_KEYS = new Set([\"Shift\", \"Control\", \"Alt\", \"Meta\"]);\nexport const MODIFIER_BIT_MASKS = {\n  alt: 1,\n  ctrl: 2,\n  meta: 4,\n  shift: 8\n};\nexport const CONFIG_ALIASES = {\n  cmd: \"meta\",\n  command: \"meta\",\n  del: \"delete\",\n  esc: \"escape\",\n  escape: \"escape\",\n  minus: \"-\",\n  mod: isMac(undefined) ? \"meta\" : \"ctrl\",\n  option: \"alt\",\n  plus: \"+\",\n  return: \"enter\",\n  win: \"meta\",\n  // need these aliases for backwards-compatibility (but they're also convenient)\n  up: \"ArrowUp\",\n  left: \"ArrowLeft\",\n  down: \"ArrowDown\",\n  right: \"ArrowRight\"\n};\n/**\n * Key mapping used in getKeyCombo() implementation for physical keys which are not alphabet characters or digits.\n *\n * N.B. at some point, we should stop using this mapping, since we can implement the desired functionality in a more\n * straightforward way by using the `event.code` property, which will always tell us the identifiers represented by the\n * _values_ in this object (the default physical keys, unaltered by modifier keys or keyboard layout).\n */\nexport const SHIFT_KEYS = {\n  \"~\": \"`\",\n  _: \"-\",\n  \"+\": \"=\",\n  \"{\": \"[\",\n  \"}\": \"]\",\n  \"|\": \"\\\\\",\n  \":\": \";\",\n  '\"': \"'\",\n  \"<\": \",\",\n  \">\": \".\",\n  \"?\": \"/\"\n};\nexport function comboMatches(a, b) {\n  return a.modifiers === b.modifiers && a.key === b.key;\n}\n/**\n * Converts a key combo string into a key combo object. Key combos include\n * zero or more modifier keys, such as `shift` or `alt`, and exactly one\n * action key, such as `A`, `enter`, or `left`.\n *\n * For action keys that require a shift, e.g. `@` or `|`, we inlude the\n * necessary `shift` modifier and automatically convert the action key to the\n * unshifted version. For example, `@` is equivalent to `shift+2`.\n */\nexport const parseKeyCombo = combo => {\n  const pieces = combo.replace(/\\s/g, \"\").toLowerCase().split(\"+\");\n  let modifiers = 0;\n  let key;\n  for (let piece of pieces) {\n    if (piece === \"\") {\n      throw new Error(`Failed to parse key combo \"${combo}\".\n                Valid key combos look like \"cmd + plus\", \"shift+p\", or \"!\"`);\n    }\n    if (CONFIG_ALIASES[piece] !== undefined) {\n      piece = CONFIG_ALIASES[piece];\n    }\n    if (MODIFIER_BIT_MASKS[piece] !== undefined) {\n      modifiers += MODIFIER_BIT_MASKS[piece];\n    } else if (SHIFT_KEYS[piece] !== undefined) {\n      modifiers += MODIFIER_BIT_MASKS.shift;\n      key = SHIFT_KEYS[piece];\n    } else {\n      key = piece.toLowerCase();\n    }\n  }\n  return {\n    modifiers,\n    key\n  };\n};\n/**\n * Interprets a keyboard event as a valid KeyComboTag `combo` prop string value.\n *\n * Note that this function is only used in the docs example and tests; it is not used by `useHotkeys()` or any\n * Blueprint consumers that we are currently aware of.\n */\nexport const getKeyComboString = e => {\n  const comboParts = [];\n  // modifiers first\n  if (e.ctrlKey) {\n    comboParts.push(\"ctrl\");\n  }\n  if (e.altKey) {\n    comboParts.push(\"alt\");\n  }\n  if (e.shiftKey) {\n    comboParts.push(\"shift\");\n  }\n  if (e.metaKey) {\n    comboParts.push(\"meta\");\n  }\n  const key = maybeGetKeyFromEventCode(e);\n  if (key !== undefined) {\n    comboParts.push(key);\n  } else {\n    if (e.code === \"Space\") {\n      comboParts.push(\"space\");\n    } else if (MODIFIER_KEYS.has(e.key)) {\n      // do nothing\n    } else if (e.shiftKey && SHIFT_KEYS[e.key] !== undefined) {\n      comboParts.push(SHIFT_KEYS[e.key]);\n    } else if (e.key !== undefined) {\n      comboParts.push(e.key.toLowerCase());\n    }\n  }\n  return comboParts.join(\" + \");\n};\nconst KEY_CODE_PREFIX = \"Key\";\nconst DIGIT_CODE_PREFIX = \"Digit\";\nfunction maybeGetKeyFromEventCode(e) {\n  if (e.code == null) {\n    return undefined;\n  }\n  if (e.code.startsWith(KEY_CODE_PREFIX)) {\n    // Code looks like \"KeyA\", etc.\n    return e.code.substring(KEY_CODE_PREFIX.length).toLowerCase();\n  } else if (e.code.startsWith(DIGIT_CODE_PREFIX)) {\n    // Code looks like \"Digit1\", etc.\n    return e.code.substring(DIGIT_CODE_PREFIX.length).toLowerCase();\n  } else if (e.code === \"Space\") {\n    return \"space\";\n  }\n  return undefined;\n}\n/**\n * Determines the key combo object from the given keyboard event. A key combo includes zero or more modifiers\n * (represented by a bitmask) and one physical key. For most keys, we prefer dealing with the `code` property of the\n * event, since this is not altered by keyboard layout or the state of modifier keys. Fall back to using the `key`\n * property.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code\n */\nexport const getKeyCombo = e => {\n  var _a, _b;\n  let key;\n  if (MODIFIER_KEYS.has(e.key)) {\n    // Leave local variable `key` undefined\n  } else {\n    key = (_a = maybeGetKeyFromEventCode(e)) !== null && _a !== void 0 ? _a : (_b = e.key) === null || _b === void 0 ? void 0 : _b.toLowerCase();\n  }\n  let modifiers = 0;\n  if (e.altKey) {\n    modifiers += MODIFIER_BIT_MASKS.alt;\n  }\n  if (e.ctrlKey) {\n    modifiers += MODIFIER_BIT_MASKS.ctrl;\n  }\n  if (e.metaKey) {\n    modifiers += MODIFIER_BIT_MASKS.meta;\n  }\n  if (e.shiftKey) {\n    modifiers += MODIFIER_BIT_MASKS.shift;\n    if (SHIFT_KEYS[e.key] !== undefined) {\n      key = SHIFT_KEYS[e.key];\n    }\n  }\n  return {\n    modifiers,\n    key\n  };\n};\n/**\n * Splits a key combo string into its constituent key values and looks up\n * aliases, such as `return` -> `enter`.\n *\n * Unlike the parseKeyCombo method, this method does NOT convert shifted\n * action keys. So `\"@\"` will NOT be converted to `[\"shift\", \"2\"]`).\n */\nexport const normalizeKeyCombo = (combo, platformOverride) => {\n  const keys = combo.replace(/\\s/g, \"\").split(\"+\");\n  return keys.map(key => {\n    const keyName = CONFIG_ALIASES[key] != null ? CONFIG_ALIASES[key] : key;\n    return keyName === \"meta\" ? isMac(platformOverride) ? \"cmd\" : \"ctrl\" : keyName;\n  });\n};\nexport function isMac(platformOverride) {\n  // HACKHACK: see https://github.com/palantir/blueprint/issues/5174\n  // eslint-disable-next-line @typescript-eslint/no-deprecated\n  const platform = platformOverride !== null && platformOverride !== void 0 ? platformOverride : typeof navigator !== \"undefined\" ? navigator.platform : undefined;\n  return platform === undefined ? false : /Mac|iPod|iPhone|iPad/.test(platform);\n}","map":{"version":3,"names":["MODIFIER_KEYS","Set","MODIFIER_BIT_MASKS","alt","ctrl","meta","shift","CONFIG_ALIASES","cmd","command","del","esc","escape","minus","mod","isMac","undefined","option","plus","return","win","up","left","down","right","SHIFT_KEYS","_","comboMatches","a","b","modifiers","key","parseKeyCombo","combo","pieces","replace","toLowerCase","split","piece","Error","getKeyComboString","e","comboParts","ctrlKey","push","altKey","shiftKey","metaKey","maybeGetKeyFromEventCode","code","has","join","KEY_CODE_PREFIX","DIGIT_CODE_PREFIX","startsWith","substring","length","getKeyCombo","_a","_b","normalizeKeyCombo","platformOverride","keys","map","keyName","platform","navigator","test"],"sources":["/Users/husseingalal/Desktop/Hackathon/Elrond/frontend/node_modules/@blueprintjs/core/src/components/hotkeys/hotkeyParser.ts"],"sourcesContent":["/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// alph sorting is unintuitive here\n/* eslint-disable sort-keys */\n\nexport interface KeyCodeTable {\n    [code: number]: string;\n}\n\nexport interface KeyCodeReverseTable {\n    [key: string]: number;\n}\n\nexport interface KeyMap {\n    [key: string]: string;\n}\n\n/**\n * Named modifier keys\n *\n * @see https://www.w3.org/TR/uievents-key/#keys-modifier\n */\nconst MODIFIER_KEYS = new Set([\"Shift\", \"Control\", \"Alt\", \"Meta\"]);\n\nexport const MODIFIER_BIT_MASKS: KeyCodeReverseTable = {\n    alt: 1,\n    ctrl: 2,\n    meta: 4,\n    shift: 8,\n};\n\nexport const CONFIG_ALIASES: KeyMap = {\n    cmd: \"meta\",\n    command: \"meta\",\n    del: \"delete\",\n    esc: \"escape\",\n    escape: \"escape\",\n    minus: \"-\",\n    mod: isMac(undefined) ? \"meta\" : \"ctrl\",\n    option: \"alt\",\n    plus: \"+\",\n    return: \"enter\",\n    win: \"meta\",\n    // need these aliases for backwards-compatibility (but they're also convenient)\n    up: \"ArrowUp\",\n    left: \"ArrowLeft\",\n    down: \"ArrowDown\",\n    right: \"ArrowRight\",\n};\n\n/**\n * Key mapping used in getKeyCombo() implementation for physical keys which are not alphabet characters or digits.\n *\n * N.B. at some point, we should stop using this mapping, since we can implement the desired functionality in a more\n * straightforward way by using the `event.code` property, which will always tell us the identifiers represented by the\n * _values_ in this object (the default physical keys, unaltered by modifier keys or keyboard layout).\n */\nexport const SHIFT_KEYS: KeyMap = {\n    \"~\": \"`\",\n    _: \"-\",\n    \"+\": \"=\",\n    \"{\": \"[\",\n    \"}\": \"]\",\n    \"|\": \"\\\\\",\n    \":\": \";\",\n    '\"': \"'\",\n    \"<\": \",\",\n    \">\": \".\",\n    \"?\": \"/\",\n};\n\nexport interface KeyCombo {\n    key?: string;\n    modifiers: number;\n}\n\nexport function comboMatches(a: KeyCombo, b: KeyCombo) {\n    return a.modifiers === b.modifiers && a.key === b.key;\n}\n\n/**\n * Converts a key combo string into a key combo object. Key combos include\n * zero or more modifier keys, such as `shift` or `alt`, and exactly one\n * action key, such as `A`, `enter`, or `left`.\n *\n * For action keys that require a shift, e.g. `@` or `|`, we inlude the\n * necessary `shift` modifier and automatically convert the action key to the\n * unshifted version. For example, `@` is equivalent to `shift+2`.\n */\nexport const parseKeyCombo = (combo: string): KeyCombo => {\n    const pieces = combo.replace(/\\s/g, \"\").toLowerCase().split(\"+\");\n    let modifiers = 0;\n    let key: string | undefined;\n    for (let piece of pieces) {\n        if (piece === \"\") {\n            throw new Error(`Failed to parse key combo \"${combo}\".\n                Valid key combos look like \"cmd + plus\", \"shift+p\", or \"!\"`);\n        }\n\n        if (CONFIG_ALIASES[piece] !== undefined) {\n            piece = CONFIG_ALIASES[piece];\n        }\n\n        if (MODIFIER_BIT_MASKS[piece] !== undefined) {\n            modifiers += MODIFIER_BIT_MASKS[piece];\n        } else if (SHIFT_KEYS[piece] !== undefined) {\n            modifiers += MODIFIER_BIT_MASKS.shift;\n            key = SHIFT_KEYS[piece];\n        } else {\n            key = piece.toLowerCase();\n        }\n    }\n    return { modifiers, key };\n};\n\n/**\n * Interprets a keyboard event as a valid KeyComboTag `combo` prop string value.\n *\n * Note that this function is only used in the docs example and tests; it is not used by `useHotkeys()` or any\n * Blueprint consumers that we are currently aware of.\n */\nexport const getKeyComboString = (e: KeyboardEvent): string => {\n    const comboParts = [] as string[];\n\n    // modifiers first\n    if (e.ctrlKey) {\n        comboParts.push(\"ctrl\");\n    }\n    if (e.altKey) {\n        comboParts.push(\"alt\");\n    }\n    if (e.shiftKey) {\n        comboParts.push(\"shift\");\n    }\n    if (e.metaKey) {\n        comboParts.push(\"meta\");\n    }\n\n    const key = maybeGetKeyFromEventCode(e);\n    if (key !== undefined) {\n        comboParts.push(key);\n    } else {\n        if (e.code === \"Space\") {\n            comboParts.push(\"space\");\n        } else if (MODIFIER_KEYS.has(e.key)) {\n            // do nothing\n        } else if (e.shiftKey && SHIFT_KEYS[e.key] !== undefined) {\n            comboParts.push(SHIFT_KEYS[e.key]);\n        } else if (e.key !== undefined) {\n            comboParts.push(e.key.toLowerCase());\n        }\n    }\n\n    return comboParts.join(\" + \");\n};\n\nconst KEY_CODE_PREFIX = \"Key\";\nconst DIGIT_CODE_PREFIX = \"Digit\";\n\nfunction maybeGetKeyFromEventCode(e: KeyboardEvent) {\n    if (e.code == null) {\n        return undefined;\n    }\n\n    if (e.code.startsWith(KEY_CODE_PREFIX)) {\n        // Code looks like \"KeyA\", etc.\n        return e.code.substring(KEY_CODE_PREFIX.length).toLowerCase();\n    } else if (e.code.startsWith(DIGIT_CODE_PREFIX)) {\n        // Code looks like \"Digit1\", etc.\n        return e.code.substring(DIGIT_CODE_PREFIX.length).toLowerCase();\n    } else if (e.code === \"Space\") {\n        return \"space\";\n    }\n\n    return undefined;\n}\n\n/**\n * Determines the key combo object from the given keyboard event. A key combo includes zero or more modifiers\n * (represented by a bitmask) and one physical key. For most keys, we prefer dealing with the `code` property of the\n * event, since this is not altered by keyboard layout or the state of modifier keys. Fall back to using the `key`\n * property.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code\n */\nexport const getKeyCombo = (e: KeyboardEvent): KeyCombo => {\n    let key: string | undefined;\n    if (MODIFIER_KEYS.has(e.key)) {\n        // Leave local variable `key` undefined\n    } else {\n        key = maybeGetKeyFromEventCode(e) ?? e.key?.toLowerCase();\n    }\n\n    let modifiers = 0;\n    if (e.altKey) {\n        modifiers += MODIFIER_BIT_MASKS.alt;\n    }\n    if (e.ctrlKey) {\n        modifiers += MODIFIER_BIT_MASKS.ctrl;\n    }\n    if (e.metaKey) {\n        modifiers += MODIFIER_BIT_MASKS.meta;\n    }\n    if (e.shiftKey) {\n        modifiers += MODIFIER_BIT_MASKS.shift;\n        if (SHIFT_KEYS[e.key] !== undefined) {\n            key = SHIFT_KEYS[e.key];\n        }\n    }\n\n    return { modifiers, key };\n};\n\n/**\n * Splits a key combo string into its constituent key values and looks up\n * aliases, such as `return` -> `enter`.\n *\n * Unlike the parseKeyCombo method, this method does NOT convert shifted\n * action keys. So `\"@\"` will NOT be converted to `[\"shift\", \"2\"]`).\n */\nexport const normalizeKeyCombo = (combo: string, platformOverride: string | undefined): string[] => {\n    const keys = combo.replace(/\\s/g, \"\").split(\"+\");\n    return keys.map(key => {\n        const keyName = CONFIG_ALIASES[key] != null ? CONFIG_ALIASES[key] : key;\n        return keyName === \"meta\" ? (isMac(platformOverride) ? \"cmd\" : \"ctrl\") : keyName;\n    });\n};\n\nexport function isMac(platformOverride: string | undefined) {\n    // HACKHACK: see https://github.com/palantir/blueprint/issues/5174\n    // eslint-disable-next-line @typescript-eslint/no-deprecated\n    const platform = platformOverride ?? (typeof navigator !== \"undefined\" ? navigator.platform : undefined);\n    return platform === undefined ? false : /Mac|iPod|iPhone|iPad/.test(platform);\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;AA+BA;;;;;AAKA,MAAMA,aAAa,GAAG,IAAIC,GAAG,CAAC,CAAC,OAAO,EAAE,SAAS,EAAE,KAAK,EAAE,MAAM,CAAC,CAAC;AAElE,OAAO,MAAMC,kBAAkB,GAAwB;EACnDC,GAAG,EAAE,CAAC;EACNC,IAAI,EAAE,CAAC;EACPC,IAAI,EAAE,CAAC;EACPC,KAAK,EAAE;CACV;AAED,OAAO,MAAMC,cAAc,GAAW;EAClCC,GAAG,EAAE,MAAM;EACXC,OAAO,EAAE,MAAM;EACfC,GAAG,EAAE,QAAQ;EACbC,GAAG,EAAE,QAAQ;EACbC,MAAM,EAAE,QAAQ;EAChBC,KAAK,EAAE,GAAG;EACVC,GAAG,EAAEC,KAAK,CAACC,SAAS,CAAC,GAAG,MAAM,GAAG,MAAM;EACvCC,MAAM,EAAE,KAAK;EACbC,IAAI,EAAE,GAAG;EACTC,MAAM,EAAE,OAAO;EACfC,GAAG,EAAE,MAAM;EACX;EACAC,EAAE,EAAE,SAAS;EACbC,IAAI,EAAE,WAAW;EACjBC,IAAI,EAAE,WAAW;EACjBC,KAAK,EAAE;CACV;AAED;;;;;;;AAOA,OAAO,MAAMC,UAAU,GAAW;EAC9B,GAAG,EAAE,GAAG;EACRC,CAAC,EAAE,GAAG;EACN,GAAG,EAAE,GAAG;EACR,GAAG,EAAE,GAAG;EACR,GAAG,EAAE,GAAG;EACR,GAAG,EAAE,IAAI;EACT,GAAG,EAAE,GAAG;EACR,GAAG,EAAE,GAAG;EACR,GAAG,EAAE,GAAG;EACR,GAAG,EAAE,GAAG;EACR,GAAG,EAAE;CACR;AAOD,OAAM,SAAUC,YAAYA,CAACC,CAAW,EAAEC,CAAW;EACjD,OAAOD,CAAC,CAACE,SAAS,KAAKD,CAAC,CAACC,SAAS,IAAIF,CAAC,CAACG,GAAG,KAAKF,CAAC,CAACE,GAAG;AACzD;AAEA;;;;;;;;;AASA,OAAO,MAAMC,aAAa,GAAIC,KAAa,IAAc;EACrD,MAAMC,MAAM,GAAGD,KAAK,CAACE,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAACC,WAAW,EAAE,CAACC,KAAK,CAAC,GAAG,CAAC;EAChE,IAAIP,SAAS,GAAG,CAAC;EACjB,IAAIC,GAAuB;EAC3B,KAAK,IAAIO,KAAK,IAAIJ,MAAM,EAAE;IACtB,IAAII,KAAK,KAAK,EAAE,EAAE;MACd,MAAM,IAAIC,KAAK,CAAC,8BAA8BN,KAAK;2EACY,CAAC;IACpE;IAEA,IAAI1B,cAAc,CAAC+B,KAAK,CAAC,KAAKtB,SAAS,EAAE;MACrCsB,KAAK,GAAG/B,cAAc,CAAC+B,KAAK,CAAC;IACjC;IAEA,IAAIpC,kBAAkB,CAACoC,KAAK,CAAC,KAAKtB,SAAS,EAAE;MACzCc,SAAS,IAAI5B,kBAAkB,CAACoC,KAAK,CAAC;IAC1C,CAAC,MAAM,IAAIb,UAAU,CAACa,KAAK,CAAC,KAAKtB,SAAS,EAAE;MACxCc,SAAS,IAAI5B,kBAAkB,CAACI,KAAK;MACrCyB,GAAG,GAAGN,UAAU,CAACa,KAAK,CAAC;IAC3B,CAAC,MAAM;MACHP,GAAG,GAAGO,KAAK,CAACF,WAAW,EAAE;IAC7B;EACJ;EACA,OAAO;IAAEN,SAAS;IAAEC;EAAG,CAAE;AAC7B,CAAC;AAED;;;;;;AAMA,OAAO,MAAMS,iBAAiB,GAAIC,CAAgB,IAAY;EAC1D,MAAMC,UAAU,GAAG,EAAc;EAEjC;EACA,IAAID,CAAC,CAACE,OAAO,EAAE;IACXD,UAAU,CAACE,IAAI,CAAC,MAAM,CAAC;EAC3B;EACA,IAAIH,CAAC,CAACI,MAAM,EAAE;IACVH,UAAU,CAACE,IAAI,CAAC,KAAK,CAAC;EAC1B;EACA,IAAIH,CAAC,CAACK,QAAQ,EAAE;IACZJ,UAAU,CAACE,IAAI,CAAC,OAAO,CAAC;EAC5B;EACA,IAAIH,CAAC,CAACM,OAAO,EAAE;IACXL,UAAU,CAACE,IAAI,CAAC,MAAM,CAAC;EAC3B;EAEA,MAAMb,GAAG,GAAGiB,wBAAwB,CAACP,CAAC,CAAC;EACvC,IAAIV,GAAG,KAAKf,SAAS,EAAE;IACnB0B,UAAU,CAACE,IAAI,CAACb,GAAG,CAAC;EACxB,CAAC,MAAM;IACH,IAAIU,CAAC,CAACQ,IAAI,KAAK,OAAO,EAAE;MACpBP,UAAU,CAACE,IAAI,CAAC,OAAO,CAAC;IAC5B,CAAC,MAAM,IAAI5C,aAAa,CAACkD,GAAG,CAACT,CAAC,CAACV,GAAG,CAAC,EAAE;MACjC;IAAA,CACH,MAAM,IAAIU,CAAC,CAACK,QAAQ,IAAIrB,UAAU,CAACgB,CAAC,CAACV,GAAG,CAAC,KAAKf,SAAS,EAAE;MACtD0B,UAAU,CAACE,IAAI,CAACnB,UAAU,CAACgB,CAAC,CAACV,GAAG,CAAC,CAAC;IACtC,CAAC,MAAM,IAAIU,CAAC,CAACV,GAAG,KAAKf,SAAS,EAAE;MAC5B0B,UAAU,CAACE,IAAI,CAACH,CAAC,CAACV,GAAG,CAACK,WAAW,EAAE,CAAC;IACxC;EACJ;EAEA,OAAOM,UAAU,CAACS,IAAI,CAAC,KAAK,CAAC;AACjC,CAAC;AAED,MAAMC,eAAe,GAAG,KAAK;AAC7B,MAAMC,iBAAiB,GAAG,OAAO;AAEjC,SAASL,wBAAwBA,CAACP,CAAgB;EAC9C,IAAIA,CAAC,CAACQ,IAAI,IAAI,IAAI,EAAE;IAChB,OAAOjC,SAAS;EACpB;EAEA,IAAIyB,CAAC,CAACQ,IAAI,CAACK,UAAU,CAACF,eAAe,CAAC,EAAE;IACpC;IACA,OAAOX,CAAC,CAACQ,IAAI,CAACM,SAAS,CAACH,eAAe,CAACI,MAAM,CAAC,CAACpB,WAAW,EAAE;EACjE,CAAC,MAAM,IAAIK,CAAC,CAACQ,IAAI,CAACK,UAAU,CAACD,iBAAiB,CAAC,EAAE;IAC7C;IACA,OAAOZ,CAAC,CAACQ,IAAI,CAACM,SAAS,CAACF,iBAAiB,CAACG,MAAM,CAAC,CAACpB,WAAW,EAAE;EACnE,CAAC,MAAM,IAAIK,CAAC,CAACQ,IAAI,KAAK,OAAO,EAAE;IAC3B,OAAO,OAAO;EAClB;EAEA,OAAOjC,SAAS;AACpB;AAEA;;;;;;;;AAQA,OAAO,MAAMyC,WAAW,GAAIhB,CAAgB,IAAc;;EACtD,IAAIV,GAAuB;EAC3B,IAAI/B,aAAa,CAACkD,GAAG,CAACT,CAAC,CAACV,GAAG,CAAC,EAAE;IAC1B;EAAA,CACH,MAAM;IACHA,GAAG,GAAG,CAAA2B,EAAA,GAAAV,wBAAwB,CAACP,CAAC,CAAC,cAAAiB,EAAA,cAAAA,EAAA,GAAI,CAAAC,EAAA,GAAAlB,CAAC,CAACV,GAAG,cAAA4B,EAAA,uBAAAA,EAAA,CAAEvB,WAAW,EAAE;EAC7D;EAEA,IAAIN,SAAS,GAAG,CAAC;EACjB,IAAIW,CAAC,CAACI,MAAM,EAAE;IACVf,SAAS,IAAI5B,kBAAkB,CAACC,GAAG;EACvC;EACA,IAAIsC,CAAC,CAACE,OAAO,EAAE;IACXb,SAAS,IAAI5B,kBAAkB,CAACE,IAAI;EACxC;EACA,IAAIqC,CAAC,CAACM,OAAO,EAAE;IACXjB,SAAS,IAAI5B,kBAAkB,CAACG,IAAI;EACxC;EACA,IAAIoC,CAAC,CAACK,QAAQ,EAAE;IACZhB,SAAS,IAAI5B,kBAAkB,CAACI,KAAK;IACrC,IAAImB,UAAU,CAACgB,CAAC,CAACV,GAAG,CAAC,KAAKf,SAAS,EAAE;MACjCe,GAAG,GAAGN,UAAU,CAACgB,CAAC,CAACV,GAAG,CAAC;IAC3B;EACJ;EAEA,OAAO;IAAED,SAAS;IAAEC;EAAG,CAAE;AAC7B,CAAC;AAED;;;;;;;AAOA,OAAO,MAAM6B,iBAAiB,GAAGA,CAAC3B,KAAa,EAAE4B,gBAAoC,KAAc;EAC/F,MAAMC,IAAI,GAAG7B,KAAK,CAACE,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAACE,KAAK,CAAC,GAAG,CAAC;EAChD,OAAOyB,IAAI,CAACC,GAAG,CAAChC,GAAG,IAAG;IAClB,MAAMiC,OAAO,GAAGzD,cAAc,CAACwB,GAAG,CAAC,IAAI,IAAI,GAAGxB,cAAc,CAACwB,GAAG,CAAC,GAAGA,GAAG;IACvE,OAAOiC,OAAO,KAAK,MAAM,GAAIjD,KAAK,CAAC8C,gBAAgB,CAAC,GAAG,KAAK,GAAG,MAAM,GAAIG,OAAO;EACpF,CAAC,CAAC;AACN,CAAC;AAED,OAAM,SAAUjD,KAAKA,CAAC8C,gBAAoC;EACtD;EACA;EACA,MAAMI,QAAQ,GAAGJ,gBAAgB,aAAhBA,gBAAgB,cAAhBA,gBAAgB,GAAK,OAAOK,SAAS,KAAK,WAAW,GAAGA,SAAS,CAACD,QAAQ,GAAGjD,SAAU;EACxG,OAAOiD,QAAQ,KAAKjD,SAAS,GAAG,KAAK,GAAG,sBAAsB,CAACmD,IAAI,CAACF,QAAQ,CAAC;AACjF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}