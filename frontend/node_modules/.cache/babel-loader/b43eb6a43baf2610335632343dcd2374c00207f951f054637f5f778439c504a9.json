{"ast":null,"code":"import { jsxs as _jsxs, jsx as _jsx } from \"react/jsx-runtime\";\n/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport classNames from \"classnames\";\nimport { ChevronDown, ChevronUp } from \"@blueprintjs/icons\";\nimport { AbstractPureComponent, Classes, DISPLAYNAME_PREFIX, Intent, Position, refHandler, removeNonHTMLProps, setRef, Utils } from \"../../common\";\nimport * as Errors from \"../../common/errors\";\nimport { ButtonGroup } from \"../button/buttonGroup\";\nimport { Button } from \"../button/buttons\";\nimport { ControlGroup } from \"./controlGroup\";\nimport { InputGroup } from \"./inputGroup\";\nimport { clampValue, getValueOrEmptyValue, isValidNumericKeyboardEvent, isValueNumeric, parseStringToStringNumber, sanitizeNumericInput, toLocaleString, toMaxPrecision } from \"./numericInputUtils\";\nvar IncrementDirection;\n(function (IncrementDirection) {\n  IncrementDirection[IncrementDirection[\"DOWN\"] = -1] = \"DOWN\";\n  IncrementDirection[IncrementDirection[\"UP\"] = 1] = \"UP\";\n})(IncrementDirection || (IncrementDirection = {}));\nconst NON_HTML_PROPS = [\"allowNumericCharactersOnly\", \"buttonPosition\", \"clampValueOnBlur\", \"className\", \"defaultValue\", \"majorStepSize\", \"minorStepSize\", \"onButtonClick\", \"onValueChange\", \"selectAllOnFocus\", \"selectAllOnIncrement\", \"stepSize\"];\n/**\n * Numeric input component.\n *\n * @see https://blueprintjs.com/docs/#core/components/numeric-input\n */\nexport class NumericInput extends AbstractPureComponent {\n  constructor() {\n    var _a;\n    super(...arguments);\n    this.numericInputId = Utils.uniqueId(\"numericInput\");\n    this.state = {\n      currentImeInputInvalid: false,\n      shouldSelectAfterUpdate: false,\n      stepMaxPrecision: NumericInput.getStepMaxPrecision(this.props),\n      value: getValueOrEmptyValue((_a = this.props.value) !== null && _a !== void 0 ? _a : this.props.defaultValue)\n    };\n    // updating these flags need not trigger re-renders, so don't include them in this.state.\n    this.didPasteEventJustOccur = false;\n    this.delta = 0;\n    this.inputElement = null;\n    this.inputRef = refHandler(this, \"inputElement\", this.props.inputRef);\n    this.incrementButtonHandlers = this.getButtonEventHandlers(IncrementDirection.UP);\n    this.decrementButtonHandlers = this.getButtonEventHandlers(IncrementDirection.DOWN);\n    this.getCurrentValueAsNumber = () => Number(parseStringToStringNumber(this.state.value, this.props.locale));\n    this.handleButtonClick = (e, direction) => {\n      var _a, _b;\n      const delta = this.updateDelta(direction, e);\n      const nextValue = this.incrementValue(delta);\n      (_b = (_a = this.props).onButtonClick) === null || _b === void 0 ? void 0 : _b.call(_a, Number(parseStringToStringNumber(nextValue, this.props.locale)), nextValue);\n    };\n    this.stopContinuousChange = () => {\n      this.delta = 0;\n      this.clearTimeouts();\n      clearInterval(this.intervalId);\n      document.removeEventListener(\"mouseup\", this.stopContinuousChange);\n    };\n    this.handleContinuousChange = () => {\n      var _a, _b, _c, _d;\n      // If either min or max prop is set, when reaching the limit\n      // the button will be disabled and stopContinuousChange will be never fired,\n      // hence the need to check on each iteration to properly clear the timeout\n      if (this.props.min !== undefined || this.props.max !== undefined) {\n        const min = (_a = this.props.min) !== null && _a !== void 0 ? _a : -Infinity;\n        const max = (_b = this.props.max) !== null && _b !== void 0 ? _b : Infinity;\n        const valueAsNumber = this.getCurrentValueAsNumber();\n        if (valueAsNumber <= min || valueAsNumber >= max) {\n          this.stopContinuousChange();\n          return;\n        }\n      }\n      const nextValue = this.incrementValue(this.delta);\n      (_d = (_c = this.props).onButtonClick) === null || _d === void 0 ? void 0 : _d.call(_c, Number(parseStringToStringNumber(nextValue, this.props.locale)), nextValue);\n    };\n    // Callbacks - Input\n    // =================\n    this.handleInputFocus = e => {\n      var _a, _b;\n      // update this state flag to trigger update for input selection (see componentDidUpdate)\n      this.setState({\n        shouldSelectAfterUpdate: this.props.selectAllOnFocus\n      });\n      (_b = (_a = this.props).onFocus) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n    };\n    this.handleInputBlur = e => {\n      var _a, _b;\n      // always disable this flag on blur so it's ready for next time.\n      this.setState({\n        shouldSelectAfterUpdate: false\n      });\n      if (this.props.clampValueOnBlur) {\n        const {\n          value\n        } = e.target;\n        this.handleNextValue(this.roundAndClampValue(value));\n      }\n      (_b = (_a = this.props).onBlur) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n    };\n    this.handleInputKeyDown = e => {\n      var _a, _b;\n      if (this.props.disabled || this.props.readOnly) {\n        return;\n      }\n      const direction = Utils.getArrowKeyDirection(e, [\"ArrowDown\"], [\"ArrowUp\"]);\n      if (direction !== undefined) {\n        // when the input field has focus, some key combinations will modify\n        // the field's selection range. we'll actually want to select all\n        // text in the field after we modify the value on the following\n        // lines. preventing the default selection behavior lets us do that\n        // without interference.\n        e.preventDefault();\n        const delta = this.updateDelta(direction, e);\n        this.incrementValue(delta);\n      }\n      (_b = (_a = this.props).onKeyDown) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n    };\n    this.handleCompositionEnd = e => {\n      if (this.props.allowNumericCharactersOnly) {\n        this.handleNextValue(sanitizeNumericInput(e.data, this.props.locale));\n        this.setState({\n          currentImeInputInvalid: false\n        });\n      }\n    };\n    this.handleCompositionUpdate = e => {\n      if (this.props.allowNumericCharactersOnly) {\n        const {\n          data\n        } = e;\n        const sanitizedValue = sanitizeNumericInput(data, this.props.locale);\n        if (sanitizedValue.length === 0 && data.length > 0) {\n          this.setState({\n            currentImeInputInvalid: true\n          });\n        } else {\n          this.setState({\n            currentImeInputInvalid: false\n          });\n        }\n      }\n    };\n    this.handleInputKeyPress = e => {\n      var _a, _b;\n      // we prohibit keystrokes in onKeyPress instead of onKeyDown, because\n      // e.key is not trustworthy in onKeyDown in all browsers.\n      if (this.props.allowNumericCharactersOnly && !isValidNumericKeyboardEvent(e, this.props.locale)) {\n        e.preventDefault();\n      }\n      // eslint-disable-next-line @typescript-eslint/no-deprecated\n      (_b = (_a = this.props).onKeyPress) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n    };\n    this.handleInputPaste = e => {\n      var _a, _b;\n      this.didPasteEventJustOccur = true;\n      (_b = (_a = this.props).onPaste) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n    };\n    this.handleInputChange = value => {\n      let nextValue = value;\n      if (this.props.allowNumericCharactersOnly && this.didPasteEventJustOccur) {\n        this.didPasteEventJustOccur = false;\n        nextValue = sanitizeNumericInput(value, this.props.locale);\n      }\n      this.handleNextValue(nextValue);\n      this.setState({\n        shouldSelectAfterUpdate: false\n      });\n    };\n  }\n  static getDerivedStateFromProps(props, state) {\n    var _a, _b;\n    const nextState = {\n      prevMaxProp: props.max,\n      prevMinProp: props.min\n    };\n    const didMinChange = props.min !== state.prevMinProp;\n    const didMaxChange = props.max !== state.prevMaxProp;\n    const didBoundsChange = didMinChange || didMaxChange;\n    // in controlled mode, use props.value\n    // in uncontrolled mode, if state.value has not been assigned yet (upon initial mount), use props.defaultValue\n    const value = (_b = (_a = props.value) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : state.value;\n    const stepMaxPrecision = NumericInput.getStepMaxPrecision(props);\n    const sanitizedValue = value !== NumericInput.VALUE_EMPTY ? NumericInput.roundAndClampValue(value, stepMaxPrecision, props.min, props.max, 0, props.locale) : NumericInput.VALUE_EMPTY;\n    // if a new min and max were provided that cause the existing value to fall\n    // outside of the new bounds, then clamp the value to the new valid range.\n    if (didBoundsChange && sanitizedValue !== state.value) {\n      return {\n        ...nextState,\n        stepMaxPrecision,\n        value: sanitizedValue\n      };\n    }\n    return {\n      ...nextState,\n      stepMaxPrecision,\n      value\n    };\n  }\n  // Value Helpers\n  // =============\n  static getStepMaxPrecision(props) {\n    if (props.minorStepSize != null) {\n      return Utils.countDecimalPlaces(props.minorStepSize);\n    } else {\n      return Utils.countDecimalPlaces(props.stepSize);\n    }\n  }\n  static roundAndClampValue(value, stepMaxPrecision, min, max, delta = 0, locale) {\n    if (!isValueNumeric(value, locale)) {\n      return NumericInput.VALUE_EMPTY;\n    }\n    const currentValue = parseStringToStringNumber(value, locale);\n    const nextValue = toMaxPrecision(Number(currentValue) + delta, stepMaxPrecision);\n    const clampedValue = clampValue(nextValue, min, max);\n    return toLocaleString(clampedValue, locale);\n  }\n  render() {\n    // eslint-disable-next-line @typescript-eslint/no-deprecated\n    const {\n      buttonPosition,\n      className,\n      fill,\n      large,\n      size = \"medium\",\n      small\n    } = this.props;\n    const containerClasses = classNames(Classes.NUMERIC_INPUT, Classes.sizeClass(size, {\n      large,\n      small\n    }), className);\n    const buttons = this.renderButtons();\n    return _jsxs(ControlGroup, {\n      className: containerClasses,\n      fill: fill,\n      children: [buttonPosition === Position.LEFT && buttons, this.renderInput(), buttonPosition === Position.RIGHT && buttons]\n    });\n  }\n  componentDidUpdate(prevProps, prevState) {\n    var _a, _b, _c;\n    super.componentDidUpdate(prevProps, prevState);\n    if (prevProps.inputRef !== this.props.inputRef) {\n      setRef(prevProps.inputRef, null);\n      this.inputRef = refHandler(this, \"inputElement\", this.props.inputRef);\n      setRef(this.props.inputRef, this.inputElement);\n    }\n    if (this.state.shouldSelectAfterUpdate) {\n      (_a = this.inputElement) === null || _a === void 0 ? void 0 : _a.setSelectionRange(0, this.state.value.length);\n    }\n    const didMinChange = this.props.min !== prevProps.min;\n    const didMaxChange = this.props.max !== prevProps.max;\n    const didBoundsChange = didMinChange || didMaxChange;\n    const didLocaleChange = this.props.locale !== prevProps.locale;\n    const didValueChange = this.state.value !== prevState.value;\n    if (didBoundsChange && didValueChange || didLocaleChange && prevState.value !== NumericInput.VALUE_EMPTY) {\n      // we clamped the value due to a bounds change, so we should fire the change callback\n      const valueToParse = didLocaleChange ? prevState.value : this.state.value;\n      const valueAsString = parseStringToStringNumber(valueToParse, prevProps.locale);\n      const localizedValue = toLocaleString(+valueAsString, this.props.locale);\n      (_c = (_b = this.props).onValueChange) === null || _c === void 0 ? void 0 : _c.call(_b, +valueAsString, localizedValue, this.inputElement);\n    }\n  }\n  validateProps(nextProps) {\n    const {\n      majorStepSize,\n      max,\n      min,\n      minorStepSize,\n      stepSize,\n      value\n    } = nextProps;\n    if (min != null && max != null && min > max) {\n      console.error(Errors.NUMERIC_INPUT_MIN_MAX);\n    }\n    if (stepSize <= 0) {\n      console.error(Errors.NUMERIC_INPUT_STEP_SIZE_NON_POSITIVE);\n    }\n    if (minorStepSize && minorStepSize <= 0) {\n      console.error(Errors.NUMERIC_INPUT_MINOR_STEP_SIZE_NON_POSITIVE);\n    }\n    if (majorStepSize && majorStepSize <= 0) {\n      console.error(Errors.NUMERIC_INPUT_MAJOR_STEP_SIZE_NON_POSITIVE);\n    }\n    if (minorStepSize && minorStepSize > stepSize) {\n      console.error(Errors.NUMERIC_INPUT_MINOR_STEP_SIZE_BOUND);\n    }\n    if (majorStepSize && majorStepSize < stepSize) {\n      console.error(Errors.NUMERIC_INPUT_MAJOR_STEP_SIZE_BOUND);\n    }\n    // controlled mode\n    if (value != null) {\n      const stepMaxPrecision = NumericInput.getStepMaxPrecision(nextProps);\n      const sanitizedValue = NumericInput.roundAndClampValue(value.toString(), stepMaxPrecision, min, max, 0, this.props.locale);\n      const valueDoesNotMatch = sanitizedValue !== value.toString();\n      const localizedValue = toLocaleString(Number(parseStringToStringNumber(value, this.props.locale)), this.props.locale);\n      const isNotLocalized = sanitizedValue !== localizedValue;\n      if (valueDoesNotMatch && isNotLocalized) {\n        console.warn(Errors.NUMERIC_INPUT_CONTROLLED_VALUE_INVALID);\n      }\n    }\n  }\n  // Render Helpers\n  // ==============\n  renderButtons() {\n    const {\n      intent,\n      max,\n      min,\n      locale\n    } = this.props;\n    const value = parseStringToStringNumber(this.state.value, locale);\n    const disabled = this.props.disabled || this.props.readOnly;\n    const isIncrementDisabled = max !== undefined && value !== \"\" && +value >= max;\n    const isDecrementDisabled = min !== undefined && value !== \"\" && +value <= min;\n    return _jsxs(ButtonGroup, {\n      className: Classes.FIXED,\n      vertical: true,\n      children: [_jsx(Button, {\n        \"aria-label\": \"increment\",\n        \"aria-controls\": this.numericInputId,\n        disabled: disabled || isIncrementDisabled,\n        icon: _jsx(ChevronUp, {}),\n        intent: intent,\n        ...this.incrementButtonHandlers\n      }), _jsx(Button, {\n        \"aria-label\": \"decrement\",\n        \"aria-controls\": this.numericInputId,\n        disabled: disabled || isDecrementDisabled,\n        icon: _jsx(ChevronDown, {}),\n        intent: intent,\n        ...this.decrementButtonHandlers\n      })]\n    }, \"button-group\");\n  }\n  renderInput() {\n    const inputGroupHtmlProps = removeNonHTMLProps(this.props, NON_HTML_PROPS, true);\n    const valueAsNumber = this.getCurrentValueAsNumber();\n    return _jsx(InputGroup, {\n      asyncControl: this.props.asyncControl,\n      autoComplete: \"off\",\n      id: this.numericInputId,\n      role: this.props.allowNumericCharactersOnly ? \"spinbutton\" : undefined,\n      ...inputGroupHtmlProps,\n      \"aria-valuemax\": this.props.max,\n      \"aria-valuemin\": this.props.min,\n      \"aria-valuenow\": valueAsNumber,\n      intent: this.state.currentImeInputInvalid ? Intent.DANGER : this.props.intent,\n      inputClassName: this.props.inputClassName,\n      inputRef: this.inputRef,\n      inputSize: this.props.inputSize,\n      // eslint-disable-next-line @typescript-eslint/no-deprecated\n      large: this.props.large,\n      leftElement: this.props.leftElement,\n      leftIcon: this.props.leftIcon,\n      onFocus: this.handleInputFocus,\n      onBlur: this.handleInputBlur,\n      onCompositionEnd: this.handleCompositionEnd,\n      onCompositionUpdate: this.handleCompositionUpdate,\n      onKeyDown: this.handleInputKeyDown,\n      // eslint-disable-next-line @typescript-eslint/no-deprecated\n      onKeyPress: this.handleInputKeyPress,\n      onPaste: this.handleInputPaste,\n      onValueChange: this.handleInputChange,\n      rightElement: this.props.rightElement,\n      size: this.props.size,\n      // eslint-disable-next-line @typescript-eslint/no-deprecated\n      small: this.props.small,\n      value: this.state.value\n    });\n  }\n  // Callbacks - Buttons\n  // ===================\n  getButtonEventHandlers(direction) {\n    return {\n      // keydown is fired repeatedly when held so it's implicitly continuous\n      onKeyDown: evt => {\n        if (!this.props.disabled && Utils.isKeyboardClick(evt)) {\n          this.handleButtonClick(evt, direction);\n        }\n      },\n      onMouseDown: evt => {\n        if (!this.props.disabled) {\n          this.handleButtonClick(evt, direction);\n          this.startContinuousChange();\n        }\n      }\n    };\n  }\n  startContinuousChange() {\n    // The button's onMouseUp event handler doesn't fire if the user\n    // releases outside of the button, so we need to watch all the way\n    // from the top.\n    document.addEventListener(\"mouseup\", this.stopContinuousChange);\n    // Initial delay is slightly longer to prevent the user from\n    // accidentally triggering the continuous increment/decrement.\n    this.setTimeout(() => {\n      this.intervalId = window.setInterval(this.handleContinuousChange, NumericInput.CONTINUOUS_CHANGE_INTERVAL);\n    }, NumericInput.CONTINUOUS_CHANGE_DELAY);\n  }\n  // Data logic\n  // ==========\n  handleNextValue(valueAsString) {\n    var _a, _b;\n    if (this.props.value == null) {\n      this.setState({\n        value: valueAsString\n      });\n    }\n    (_b = (_a = this.props).onValueChange) === null || _b === void 0 ? void 0 : _b.call(_a, Number(parseStringToStringNumber(valueAsString, this.props.locale)), valueAsString, this.inputElement);\n  }\n  incrementValue(delta) {\n    // pretend we're incrementing from 0 if currValue is empty\n    const currValue = this.state.value === NumericInput.VALUE_EMPTY ? NumericInput.VALUE_ZERO : this.state.value;\n    const nextValue = this.roundAndClampValue(currValue, delta);\n    if (nextValue !== this.state.value) {\n      this.handleNextValue(nextValue);\n      this.setState({\n        shouldSelectAfterUpdate: this.props.selectAllOnIncrement\n      });\n    }\n    // return value used in continuous change updates\n    return nextValue;\n  }\n  getIncrementDelta(direction, isShiftKeyPressed, isAltKeyPressed) {\n    const {\n      majorStepSize,\n      minorStepSize,\n      stepSize\n    } = this.props;\n    if (isShiftKeyPressed && majorStepSize != null) {\n      return direction * majorStepSize;\n    } else if (isAltKeyPressed && minorStepSize != null) {\n      return direction * minorStepSize;\n    } else {\n      return direction * stepSize;\n    }\n  }\n  roundAndClampValue(value, delta = 0) {\n    return NumericInput.roundAndClampValue(value, this.state.stepMaxPrecision, this.props.min, this.props.max, delta, this.props.locale);\n  }\n  updateDelta(direction, e) {\n    this.delta = this.getIncrementDelta(direction, e.shiftKey, e.altKey);\n    return this.delta;\n  }\n}\nNumericInput.displayName = `${DISPLAYNAME_PREFIX}.NumericInput`;\nNumericInput.VALUE_EMPTY = \"\";\nNumericInput.VALUE_ZERO = \"0\";\nNumericInput.defaultProps = {\n  allowNumericCharactersOnly: true,\n  buttonPosition: Position.RIGHT,\n  clampValueOnBlur: false,\n  defaultValue: NumericInput.VALUE_EMPTY,\n  large: false,\n  majorStepSize: 10,\n  minorStepSize: 0.1,\n  selectAllOnFocus: false,\n  selectAllOnIncrement: false,\n  size: \"medium\",\n  small: false,\n  stepSize: 1\n};\nNumericInput.CONTINUOUS_CHANGE_DELAY = 300;\nNumericInput.CONTINUOUS_CHANGE_INTERVAL = 100;","map":{"version":3,"names":["classNames","ChevronDown","ChevronUp","AbstractPureComponent","Classes","DISPLAYNAME_PREFIX","Intent","Position","refHandler","removeNonHTMLProps","setRef","Utils","Errors","ButtonGroup","Button","ControlGroup","InputGroup","clampValue","getValueOrEmptyValue","isValidNumericKeyboardEvent","isValueNumeric","parseStringToStringNumber","sanitizeNumericInput","toLocaleString","toMaxPrecision","IncrementDirection","NON_HTML_PROPS","NumericInput","constructor","numericInputId","uniqueId","state","currentImeInputInvalid","shouldSelectAfterUpdate","stepMaxPrecision","getStepMaxPrecision","props","value","_a","defaultValue","didPasteEventJustOccur","delta","inputElement","inputRef","incrementButtonHandlers","getButtonEventHandlers","UP","decrementButtonHandlers","DOWN","getCurrentValueAsNumber","Number","locale","handleButtonClick","e","direction","updateDelta","nextValue","incrementValue","_b","onButtonClick","call","stopContinuousChange","clearTimeouts","clearInterval","intervalId","document","removeEventListener","handleContinuousChange","min","undefined","max","Infinity","valueAsNumber","_d","_c","handleInputFocus","setState","selectAllOnFocus","onFocus","handleInputBlur","clampValueOnBlur","target","handleNextValue","roundAndClampValue","onBlur","handleInputKeyDown","disabled","readOnly","getArrowKeyDirection","preventDefault","onKeyDown","handleCompositionEnd","allowNumericCharactersOnly","data","handleCompositionUpdate","sanitizedValue","length","handleInputKeyPress","onKeyPress","handleInputPaste","onPaste","handleInputChange","getDerivedStateFromProps","nextState","prevMaxProp","prevMinProp","didMinChange","didMaxChange","didBoundsChange","toString","VALUE_EMPTY","minorStepSize","countDecimalPlaces","stepSize","currentValue","clampedValue","render","buttonPosition","className","fill","large","size","small","containerClasses","NUMERIC_INPUT","sizeClass","buttons","renderButtons","_jsxs","children","LEFT","renderInput","RIGHT","componentDidUpdate","prevProps","prevState","setSelectionRange","didLocaleChange","didValueChange","valueToParse","valueAsString","localizedValue","onValueChange","validateProps","nextProps","majorStepSize","console","error","NUMERIC_INPUT_MIN_MAX","NUMERIC_INPUT_STEP_SIZE_NON_POSITIVE","NUMERIC_INPUT_MINOR_STEP_SIZE_NON_POSITIVE","NUMERIC_INPUT_MAJOR_STEP_SIZE_NON_POSITIVE","NUMERIC_INPUT_MINOR_STEP_SIZE_BOUND","NUMERIC_INPUT_MAJOR_STEP_SIZE_BOUND","valueDoesNotMatch","isNotLocalized","warn","NUMERIC_INPUT_CONTROLLED_VALUE_INVALID","intent","isIncrementDisabled","isDecrementDisabled","FIXED","vertical","_jsx","icon","inputGroupHtmlProps","asyncControl","autoComplete","id","role","DANGER","inputClassName","inputSize","leftElement","leftIcon","onCompositionEnd","onCompositionUpdate","rightElement","evt","isKeyboardClick","onMouseDown","startContinuousChange","addEventListener","setTimeout","window","setInterval","CONTINUOUS_CHANGE_INTERVAL","CONTINUOUS_CHANGE_DELAY","currValue","VALUE_ZERO","selectAllOnIncrement","getIncrementDelta","isShiftKeyPressed","isAltKeyPressed","shiftKey","altKey","displayName","defaultProps"],"sources":["/Users/husseingalal/Desktop/Hackathon/Elrond/frontend/node_modules/@blueprintjs/core/src/components/forms/numericInput.tsx"],"sourcesContent":["/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport classNames from \"classnames\";\n\nimport { ChevronDown, ChevronUp } from \"@blueprintjs/icons\";\n\nimport {\n    AbstractPureComponent,\n    Classes,\n    DISPLAYNAME_PREFIX,\n    type HTMLInputProps,\n    Intent,\n    Position,\n    refHandler,\n    removeNonHTMLProps,\n    setRef,\n    Utils,\n} from \"../../common\";\nimport * as Errors from \"../../common/errors\";\nimport type { Size } from \"../../common/size\";\nimport { ButtonGroup } from \"../button/buttonGroup\";\nimport { Button } from \"../button/buttons\";\n\nimport { ControlGroup } from \"./controlGroup\";\nimport { InputGroup } from \"./inputGroup\";\nimport type { InputSharedProps } from \"./inputSharedProps\";\nimport {\n    clampValue,\n    getValueOrEmptyValue,\n    isValidNumericKeyboardEvent,\n    isValueNumeric,\n    parseStringToStringNumber,\n    sanitizeNumericInput,\n    toLocaleString,\n    toMaxPrecision,\n} from \"./numericInputUtils\";\n\nexport interface NumericInputProps extends InputSharedProps {\n    /**\n     * Whether to allow only floating-point number characters in the field,\n     * mimicking the native `input[type=\"number\"]`.\n     *\n     * @default true\n     */\n    allowNumericCharactersOnly?: boolean;\n\n    /**\n     * Set this to `true` if you will be controlling the `value` of this input with asynchronous updates.\n     * These may occur if you do not immediately call setState in a parent component with the value from\n     * the `onChange` handler.\n     */\n    asyncControl?: boolean;\n\n    /**\n     * The position of the buttons with respect to the input field.\n     *\n     * @default Position.RIGHT\n     */\n    buttonPosition?: typeof Position.LEFT | typeof Position.RIGHT | \"none\";\n\n    /**\n     * Whether the value should be clamped to `[min, max]` on blur.\n     * The value will be clamped to each bound only if the bound is defined.\n     * Note that native `input[type=\"number\"]` controls do *NOT* clamp on blur.\n     *\n     * @default false\n     */\n    clampValueOnBlur?: boolean;\n\n    /**\n     * In uncontrolled mode, this sets the default value of the input.\n     * Note that this value is only used upon component instantiation and changes to this prop\n     * during the component lifecycle will be ignored.\n     *\n     * @default \"\"\n     */\n    defaultValue?: number | string;\n    /**\n     * If set to `true`, the input will display with larger styling.\n     * This is equivalent to setting `Classes.LARGE` via className on the\n     * parent control group and on the child input group.\n     *\n     * @deprecated use size=\"large\" instead\n     * @default false\n     */\n    large?: boolean;\n\n    /**\n     * The locale name, which is passed to the component to format the number and allowing to type the number in the specific locale.\n     * [See MDN documentation for more info about browser locale identification](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#Locale_identification_and_negotiation).\n     *\n     * @default \"\"\n     */\n    locale?: string;\n\n    /**\n     * The increment between successive values when <kbd>shift</kbd> is held.\n     * Pass explicit `null` value to disable this interaction.\n     *\n     * @default 10\n     */\n    majorStepSize?: number | null;\n\n    /** The maximum value of the input. */\n    max?: number;\n\n    /** The minimum value of the input. */\n    min?: number;\n\n    /**\n     * The increment between successive values when <kbd>alt</kbd> is held.\n     * Pass explicit `null` value to disable this interaction.\n     *\n     * @default 0.1\n     */\n    minorStepSize?: number | null;\n\n    /**\n     * Whether the entire text field should be selected on focus.\n     *\n     * @default false\n     */\n    selectAllOnFocus?: boolean;\n\n    /**\n     * Whether the entire text field should be selected on increment.\n     *\n     * @default false\n     */\n    selectAllOnIncrement?: boolean;\n\n    /**\n     * If set to `true`, the input will display with smaller styling.\n     * This is equivalent to setting `Classes.SMALL` via className on the\n     * parent control group and on the child input group.\n     *\n     * @deprecated use size=\"small\" instead\n     * @default false\n     */\n    small?: boolean;\n\n    /**\n     * Size of the input.\n     *\n     * @default \"medium\"\n     */\n    size?: Size;\n\n    /**\n     * Alias for the native HTML input `size` attribute.\n     * see: https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/size\n     */\n    inputSize?: HTMLInputProps[\"size\"];\n\n    /**\n     * The increment between successive values when no modifier keys are held.\n     *\n     * @default 1\n     */\n    stepSize?: number;\n\n    /**\n     * The value to display in the input field.\n     */\n    value?: number | string;\n\n    /** The callback invoked when the value changes due to a button click. */\n    onButtonClick?(valueAsNumber: number, valueAsString: string): void;\n\n    /** The callback invoked when the value changes due to typing, arrow keys, or button clicks. */\n    onValueChange?(valueAsNumber: number, valueAsString: string, inputElement: HTMLInputElement | null): void;\n}\n\nexport interface NumericInputState {\n    currentImeInputInvalid: boolean;\n    prevMinProp?: number;\n    prevMaxProp?: number;\n    shouldSelectAfterUpdate: boolean;\n    stepMaxPrecision: number;\n    value: string;\n}\n\nenum IncrementDirection {\n    DOWN = -1,\n    UP = +1,\n}\n\nconst NON_HTML_PROPS: Array<keyof NumericInputProps> = [\n    \"allowNumericCharactersOnly\",\n    \"buttonPosition\",\n    \"clampValueOnBlur\",\n    \"className\",\n    \"defaultValue\",\n    \"majorStepSize\",\n    \"minorStepSize\",\n    \"onButtonClick\",\n    \"onValueChange\",\n    \"selectAllOnFocus\",\n    \"selectAllOnIncrement\",\n    \"stepSize\",\n];\n\ntype ButtonEventHandlers = Required<Pick<React.HTMLAttributes<HTMLElement>, \"onKeyDown\" | \"onMouseDown\">>;\n\n/**\n * Numeric input component.\n *\n * @see https://blueprintjs.com/docs/#core/components/numeric-input\n */\nexport class NumericInput extends AbstractPureComponent<\n    Omit<HTMLInputProps, \"size\"> & NumericInputProps,\n    NumericInputState\n> {\n    public static displayName = `${DISPLAYNAME_PREFIX}.NumericInput`;\n\n    public static VALUE_EMPTY = \"\";\n\n    public static VALUE_ZERO = \"0\";\n\n    private numericInputId = Utils.uniqueId(\"numericInput\");\n\n    public static defaultProps: NumericInputProps = {\n        allowNumericCharactersOnly: true,\n        buttonPosition: Position.RIGHT,\n        clampValueOnBlur: false,\n        defaultValue: NumericInput.VALUE_EMPTY,\n        large: false,\n        majorStepSize: 10,\n        minorStepSize: 0.1,\n        selectAllOnFocus: false,\n        selectAllOnIncrement: false,\n        size: \"medium\",\n        small: false,\n        stepSize: 1,\n    };\n\n    public static getDerivedStateFromProps(props: NumericInputProps, state: NumericInputState) {\n        const nextState = {\n            prevMaxProp: props.max,\n            prevMinProp: props.min,\n        };\n\n        const didMinChange = props.min !== state.prevMinProp;\n        const didMaxChange = props.max !== state.prevMaxProp;\n        const didBoundsChange = didMinChange || didMaxChange;\n\n        // in controlled mode, use props.value\n        // in uncontrolled mode, if state.value has not been assigned yet (upon initial mount), use props.defaultValue\n        const value = props.value?.toString() ?? state.value;\n        const stepMaxPrecision = NumericInput.getStepMaxPrecision(props);\n\n        const sanitizedValue =\n            value !== NumericInput.VALUE_EMPTY\n                ? NumericInput.roundAndClampValue(value, stepMaxPrecision, props.min, props.max, 0, props.locale)\n                : NumericInput.VALUE_EMPTY;\n\n        // if a new min and max were provided that cause the existing value to fall\n        // outside of the new bounds, then clamp the value to the new valid range.\n        if (didBoundsChange && sanitizedValue !== state.value) {\n            return { ...nextState, stepMaxPrecision, value: sanitizedValue };\n        }\n        return { ...nextState, stepMaxPrecision, value };\n    }\n\n    private static CONTINUOUS_CHANGE_DELAY = 300;\n\n    private static CONTINUOUS_CHANGE_INTERVAL = 100;\n\n    // Value Helpers\n    // =============\n    private static getStepMaxPrecision(props: Omit<HTMLInputProps, \"size\"> & NumericInputProps) {\n        if (props.minorStepSize != null) {\n            return Utils.countDecimalPlaces(props.minorStepSize);\n        } else {\n            return Utils.countDecimalPlaces(props.stepSize!);\n        }\n    }\n\n    private static roundAndClampValue(\n        value: string,\n        stepMaxPrecision: number,\n        min: number | undefined,\n        max: number | undefined,\n        delta = 0,\n        locale: string | undefined,\n    ) {\n        if (!isValueNumeric(value, locale)) {\n            return NumericInput.VALUE_EMPTY;\n        }\n        const currentValue = parseStringToStringNumber(value, locale);\n        const nextValue = toMaxPrecision(Number(currentValue) + delta, stepMaxPrecision);\n        const clampedValue = clampValue(nextValue, min, max);\n        return toLocaleString(clampedValue, locale);\n    }\n\n    public state: NumericInputState = {\n        currentImeInputInvalid: false,\n        shouldSelectAfterUpdate: false,\n        stepMaxPrecision: NumericInput.getStepMaxPrecision(this.props),\n        value: getValueOrEmptyValue(this.props.value ?? this.props.defaultValue),\n    };\n\n    // updating these flags need not trigger re-renders, so don't include them in this.state.\n    private didPasteEventJustOccur = false;\n\n    private delta = 0;\n\n    public inputElement: HTMLInputElement | null = null;\n\n    private inputRef: React.Ref<HTMLInputElement> = refHandler(this, \"inputElement\", this.props.inputRef);\n\n    private intervalId?: number;\n\n    private incrementButtonHandlers = this.getButtonEventHandlers(IncrementDirection.UP);\n\n    private decrementButtonHandlers = this.getButtonEventHandlers(IncrementDirection.DOWN);\n\n    private getCurrentValueAsNumber = () => Number(parseStringToStringNumber(this.state.value, this.props.locale));\n\n    public render() {\n        // eslint-disable-next-line @typescript-eslint/no-deprecated\n        const { buttonPosition, className, fill, large, size = \"medium\", small } = this.props;\n        const containerClasses = classNames(\n            Classes.NUMERIC_INPUT,\n            Classes.sizeClass(size, { large, small }),\n            className,\n        );\n        const buttons = this.renderButtons();\n        return (\n            <ControlGroup className={containerClasses} fill={fill}>\n                {buttonPosition === Position.LEFT && buttons}\n                {this.renderInput()}\n                {buttonPosition === Position.RIGHT && buttons}\n            </ControlGroup>\n        );\n    }\n\n    public componentDidUpdate(prevProps: NumericInputProps, prevState: NumericInputState) {\n        super.componentDidUpdate(prevProps, prevState);\n\n        if (prevProps.inputRef !== this.props.inputRef) {\n            setRef(prevProps.inputRef, null);\n            this.inputRef = refHandler(this, \"inputElement\", this.props.inputRef);\n            setRef(this.props.inputRef, this.inputElement);\n        }\n\n        if (this.state.shouldSelectAfterUpdate) {\n            this.inputElement?.setSelectionRange(0, this.state.value.length);\n        }\n\n        const didMinChange = this.props.min !== prevProps.min;\n        const didMaxChange = this.props.max !== prevProps.max;\n        const didBoundsChange = didMinChange || didMaxChange;\n        const didLocaleChange = this.props.locale !== prevProps.locale;\n        const didValueChange = this.state.value !== prevState.value;\n\n        if ((didBoundsChange && didValueChange) || (didLocaleChange && prevState.value !== NumericInput.VALUE_EMPTY)) {\n            // we clamped the value due to a bounds change, so we should fire the change callback\n            const valueToParse = didLocaleChange ? prevState.value : this.state.value;\n            const valueAsString = parseStringToStringNumber(valueToParse, prevProps.locale);\n            const localizedValue = toLocaleString(+valueAsString, this.props.locale);\n\n            this.props.onValueChange?.(+valueAsString, localizedValue, this.inputElement);\n        }\n    }\n\n    protected validateProps(nextProps: HTMLInputProps & NumericInputProps) {\n        const { majorStepSize, max, min, minorStepSize, stepSize, value } = nextProps;\n        if (min != null && max != null && min > max) {\n            console.error(Errors.NUMERIC_INPUT_MIN_MAX);\n        }\n        if (stepSize! <= 0) {\n            console.error(Errors.NUMERIC_INPUT_STEP_SIZE_NON_POSITIVE);\n        }\n        if (minorStepSize && minorStepSize <= 0) {\n            console.error(Errors.NUMERIC_INPUT_MINOR_STEP_SIZE_NON_POSITIVE);\n        }\n        if (majorStepSize && majorStepSize <= 0) {\n            console.error(Errors.NUMERIC_INPUT_MAJOR_STEP_SIZE_NON_POSITIVE);\n        }\n        if (minorStepSize && minorStepSize > stepSize!) {\n            console.error(Errors.NUMERIC_INPUT_MINOR_STEP_SIZE_BOUND);\n        }\n        if (majorStepSize && majorStepSize < stepSize!) {\n            console.error(Errors.NUMERIC_INPUT_MAJOR_STEP_SIZE_BOUND);\n        }\n\n        // controlled mode\n        if (value != null) {\n            const stepMaxPrecision = NumericInput.getStepMaxPrecision(nextProps);\n            const sanitizedValue = NumericInput.roundAndClampValue(\n                value.toString(),\n                stepMaxPrecision,\n                min,\n                max,\n                0,\n                this.props.locale,\n            );\n            const valueDoesNotMatch = sanitizedValue !== value.toString();\n            const localizedValue = toLocaleString(\n                Number(parseStringToStringNumber(value, this.props.locale)),\n                this.props.locale,\n            );\n            const isNotLocalized = sanitizedValue !== localizedValue;\n\n            if (valueDoesNotMatch && isNotLocalized) {\n                console.warn(Errors.NUMERIC_INPUT_CONTROLLED_VALUE_INVALID);\n            }\n        }\n    }\n\n    // Render Helpers\n    // ==============\n\n    private renderButtons() {\n        const { intent, max, min, locale } = this.props;\n        const value = parseStringToStringNumber(this.state.value, locale);\n        const disabled = this.props.disabled || this.props.readOnly;\n        const isIncrementDisabled = max !== undefined && value !== \"\" && +value >= max;\n        const isDecrementDisabled = min !== undefined && value !== \"\" && +value <= min;\n\n        return (\n            <ButtonGroup className={Classes.FIXED} key=\"button-group\" vertical={true}>\n                <Button\n                    aria-label=\"increment\"\n                    aria-controls={this.numericInputId}\n                    disabled={disabled || isIncrementDisabled}\n                    icon={<ChevronUp />}\n                    intent={intent}\n                    {...this.incrementButtonHandlers}\n                />\n                <Button\n                    aria-label=\"decrement\"\n                    aria-controls={this.numericInputId}\n                    disabled={disabled || isDecrementDisabled}\n                    icon={<ChevronDown />}\n                    intent={intent}\n                    {...this.decrementButtonHandlers}\n                />\n            </ButtonGroup>\n        );\n    }\n\n    private renderInput() {\n        const inputGroupHtmlProps = removeNonHTMLProps(this.props, NON_HTML_PROPS, true);\n        const valueAsNumber = this.getCurrentValueAsNumber();\n\n        return (\n            <InputGroup\n                asyncControl={this.props.asyncControl}\n                autoComplete=\"off\"\n                id={this.numericInputId}\n                role={this.props.allowNumericCharactersOnly ? \"spinbutton\" : undefined}\n                {...inputGroupHtmlProps}\n                aria-valuemax={this.props.max}\n                aria-valuemin={this.props.min}\n                aria-valuenow={valueAsNumber}\n                intent={this.state.currentImeInputInvalid ? Intent.DANGER : this.props.intent}\n                inputClassName={this.props.inputClassName}\n                inputRef={this.inputRef}\n                inputSize={this.props.inputSize}\n                // eslint-disable-next-line @typescript-eslint/no-deprecated\n                large={this.props.large}\n                leftElement={this.props.leftElement}\n                leftIcon={this.props.leftIcon}\n                onFocus={this.handleInputFocus}\n                onBlur={this.handleInputBlur}\n                onCompositionEnd={this.handleCompositionEnd}\n                onCompositionUpdate={this.handleCompositionUpdate}\n                onKeyDown={this.handleInputKeyDown}\n                // eslint-disable-next-line @typescript-eslint/no-deprecated\n                onKeyPress={this.handleInputKeyPress}\n                onPaste={this.handleInputPaste}\n                onValueChange={this.handleInputChange}\n                rightElement={this.props.rightElement}\n                size={this.props.size}\n                // eslint-disable-next-line @typescript-eslint/no-deprecated\n                small={this.props.small}\n                value={this.state.value}\n            />\n        );\n    }\n\n    // Callbacks - Buttons\n    // ===================\n\n    private getButtonEventHandlers(direction: IncrementDirection): ButtonEventHandlers {\n        return {\n            // keydown is fired repeatedly when held so it's implicitly continuous\n            onKeyDown: evt => {\n                if (!this.props.disabled && Utils.isKeyboardClick(evt)) {\n                    this.handleButtonClick(evt, direction);\n                }\n            },\n            onMouseDown: evt => {\n                if (!this.props.disabled) {\n                    this.handleButtonClick(evt, direction);\n                    this.startContinuousChange();\n                }\n            },\n        };\n    }\n\n    private handleButtonClick = (e: React.MouseEvent | React.KeyboardEvent, direction: IncrementDirection) => {\n        const delta = this.updateDelta(direction, e);\n        const nextValue = this.incrementValue(delta);\n        this.props.onButtonClick?.(Number(parseStringToStringNumber(nextValue, this.props.locale)), nextValue);\n    };\n\n    private startContinuousChange() {\n        // The button's onMouseUp event handler doesn't fire if the user\n        // releases outside of the button, so we need to watch all the way\n        // from the top.\n        document.addEventListener(\"mouseup\", this.stopContinuousChange);\n\n        // Initial delay is slightly longer to prevent the user from\n        // accidentally triggering the continuous increment/decrement.\n        this.setTimeout(() => {\n            this.intervalId = window.setInterval(this.handleContinuousChange, NumericInput.CONTINUOUS_CHANGE_INTERVAL);\n        }, NumericInput.CONTINUOUS_CHANGE_DELAY);\n    }\n\n    private stopContinuousChange = () => {\n        this.delta = 0;\n        this.clearTimeouts();\n        clearInterval(this.intervalId);\n        document.removeEventListener(\"mouseup\", this.stopContinuousChange);\n    };\n\n    private handleContinuousChange = () => {\n        // If either min or max prop is set, when reaching the limit\n        // the button will be disabled and stopContinuousChange will be never fired,\n        // hence the need to check on each iteration to properly clear the timeout\n        if (this.props.min !== undefined || this.props.max !== undefined) {\n            const min = this.props.min ?? -Infinity;\n            const max = this.props.max ?? Infinity;\n            const valueAsNumber = this.getCurrentValueAsNumber();\n            if (valueAsNumber <= min || valueAsNumber >= max) {\n                this.stopContinuousChange();\n                return;\n            }\n        }\n        const nextValue = this.incrementValue(this.delta);\n        this.props.onButtonClick?.(Number(parseStringToStringNumber(nextValue, this.props.locale)), nextValue);\n    };\n\n    // Callbacks - Input\n    // =================\n\n    private handleInputFocus = (e: React.FocusEvent<HTMLInputElement>) => {\n        // update this state flag to trigger update for input selection (see componentDidUpdate)\n        this.setState({ shouldSelectAfterUpdate: this.props.selectAllOnFocus! });\n        this.props.onFocus?.(e);\n    };\n\n    private handleInputBlur = (e: React.FocusEvent<HTMLInputElement>) => {\n        // always disable this flag on blur so it's ready for next time.\n        this.setState({ shouldSelectAfterUpdate: false });\n\n        if (this.props.clampValueOnBlur) {\n            const { value } = e.target as HTMLInputElement;\n            this.handleNextValue(this.roundAndClampValue(value));\n        }\n\n        this.props.onBlur?.(e);\n    };\n\n    private handleInputKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {\n        if (this.props.disabled || this.props.readOnly) {\n            return;\n        }\n\n        const direction = Utils.getArrowKeyDirection(e, [\"ArrowDown\"], [\"ArrowUp\"]);\n        if (direction !== undefined) {\n            // when the input field has focus, some key combinations will modify\n            // the field's selection range. we'll actually want to select all\n            // text in the field after we modify the value on the following\n            // lines. preventing the default selection behavior lets us do that\n            // without interference.\n            e.preventDefault();\n\n            const delta = this.updateDelta(direction, e);\n            this.incrementValue(delta);\n        }\n\n        this.props.onKeyDown?.(e);\n    };\n\n    private handleCompositionEnd = (e: React.CompositionEvent<HTMLInputElement>) => {\n        if (this.props.allowNumericCharactersOnly) {\n            this.handleNextValue(sanitizeNumericInput(e.data, this.props.locale));\n            this.setState({ currentImeInputInvalid: false });\n        }\n    };\n\n    private handleCompositionUpdate = (e: React.CompositionEvent<HTMLInputElement>) => {\n        if (this.props.allowNumericCharactersOnly) {\n            const { data } = e;\n            const sanitizedValue = sanitizeNumericInput(data, this.props.locale);\n            if (sanitizedValue.length === 0 && data.length > 0) {\n                this.setState({ currentImeInputInvalid: true });\n            } else {\n                this.setState({ currentImeInputInvalid: false });\n            }\n        }\n    };\n\n    private handleInputKeyPress = (e: React.KeyboardEvent<HTMLInputElement>) => {\n        // we prohibit keystrokes in onKeyPress instead of onKeyDown, because\n        // e.key is not trustworthy in onKeyDown in all browsers.\n        if (this.props.allowNumericCharactersOnly && !isValidNumericKeyboardEvent(e, this.props.locale)) {\n            e.preventDefault();\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-deprecated\n        this.props.onKeyPress?.(e);\n    };\n\n    private handleInputPaste = (e: React.ClipboardEvent<HTMLInputElement>) => {\n        this.didPasteEventJustOccur = true;\n        this.props.onPaste?.(e);\n    };\n\n    private handleInputChange = (value: string) => {\n        let nextValue = value;\n        if (this.props.allowNumericCharactersOnly && this.didPasteEventJustOccur) {\n            this.didPasteEventJustOccur = false;\n            nextValue = sanitizeNumericInput(value, this.props.locale);\n        }\n\n        this.handleNextValue(nextValue);\n        this.setState({ shouldSelectAfterUpdate: false });\n    };\n\n    // Data logic\n    // ==========\n\n    private handleNextValue(valueAsString: string) {\n        if (this.props.value == null) {\n            this.setState({ value: valueAsString });\n        }\n\n        this.props.onValueChange?.(\n            Number(parseStringToStringNumber(valueAsString, this.props.locale)),\n            valueAsString,\n            this.inputElement,\n        );\n    }\n\n    private incrementValue(delta: number) {\n        // pretend we're incrementing from 0 if currValue is empty\n        const currValue = this.state.value === NumericInput.VALUE_EMPTY ? NumericInput.VALUE_ZERO : this.state.value;\n        const nextValue = this.roundAndClampValue(currValue, delta);\n\n        if (nextValue !== this.state.value) {\n            this.handleNextValue(nextValue);\n            this.setState({ shouldSelectAfterUpdate: this.props.selectAllOnIncrement! });\n        }\n\n        // return value used in continuous change updates\n        return nextValue;\n    }\n\n    private getIncrementDelta(direction: IncrementDirection, isShiftKeyPressed: boolean, isAltKeyPressed: boolean) {\n        const { majorStepSize, minorStepSize, stepSize } = this.props;\n\n        if (isShiftKeyPressed && majorStepSize != null) {\n            return direction * majorStepSize;\n        } else if (isAltKeyPressed && minorStepSize != null) {\n            return direction * minorStepSize;\n        } else {\n            return direction * stepSize!;\n        }\n    }\n\n    private roundAndClampValue(value: string, delta = 0) {\n        return NumericInput.roundAndClampValue(\n            value,\n            this.state.stepMaxPrecision,\n            this.props.min,\n            this.props.max,\n            delta,\n            this.props.locale,\n        );\n    }\n\n    private updateDelta(direction: IncrementDirection, e: React.MouseEvent | React.KeyboardEvent) {\n        this.delta = this.getIncrementDelta(direction, e.shiftKey, e.altKey);\n        return this.delta;\n    }\n}\n"],"mappings":";AAAA;;;;;;;;;;;;;;;AAgBA,OAAOA,UAAU,MAAM,YAAY;AAEnC,SAASC,WAAW,EAAEC,SAAS,QAAQ,oBAAoB;AAE3D,SACIC,qBAAqB,EACrBC,OAAO,EACPC,kBAAkB,EAElBC,MAAM,EACNC,QAAQ,EACRC,UAAU,EACVC,kBAAkB,EAClBC,MAAM,EACNC,KAAK,QACF,cAAc;AACrB,OAAO,KAAKC,MAAM,MAAM,qBAAqB;AAE7C,SAASC,WAAW,QAAQ,uBAAuB;AACnD,SAASC,MAAM,QAAQ,mBAAmB;AAE1C,SAASC,YAAY,QAAQ,gBAAgB;AAC7C,SAASC,UAAU,QAAQ,cAAc;AAEzC,SACIC,UAAU,EACVC,oBAAoB,EACpBC,2BAA2B,EAC3BC,cAAc,EACdC,yBAAyB,EACzBC,oBAAoB,EACpBC,cAAc,EACdC,cAAc,QACX,qBAAqB;AAmJ5B,IAAKC,kBAGJ;AAHD,WAAKA,kBAAkB;EACnBA,kBAAA,CAAAA,kBAAA,uBAAS;EACTA,kBAAA,CAAAA,kBAAA,kBAAO;AACX,CAAC,EAHIA,kBAAkB,KAAlBA,kBAAkB;AAKvB,MAAMC,cAAc,GAAmC,CACnD,4BAA4B,EAC5B,gBAAgB,EAChB,kBAAkB,EAClB,WAAW,EACX,cAAc,EACd,eAAe,EACf,eAAe,EACf,eAAe,EACf,eAAe,EACf,kBAAkB,EAClB,sBAAsB,EACtB,UAAU,CACb;AAID;;;;;AAKA,OAAM,MAAOC,YAAa,SAAQxB,qBAGjC;EAHDyB,YAAA;;;IAUY,KAAAC,cAAc,GAAGlB,KAAK,CAACmB,QAAQ,CAAC,cAAc,CAAC;IA4EhD,KAAAC,KAAK,GAAsB;MAC9BC,sBAAsB,EAAE,KAAK;MAC7BC,uBAAuB,EAAE,KAAK;MAC9BC,gBAAgB,EAAEP,YAAY,CAACQ,mBAAmB,CAAC,IAAI,CAACC,KAAK,CAAC;MAC9DC,KAAK,EAAEnB,oBAAoB,CAAC,CAAAoB,EAAA,OAAI,CAACF,KAAK,CAACC,KAAK,cAAAC,EAAA,cAAAA,EAAA,GAAI,IAAI,CAACF,KAAK,CAACG,YAAY;KAC1E;IAED;IACQ,KAAAC,sBAAsB,GAAG,KAAK;IAE9B,KAAAC,KAAK,GAAG,CAAC;IAEV,KAAAC,YAAY,GAA4B,IAAI;IAE3C,KAAAC,QAAQ,GAAgCnC,UAAU,CAAC,IAAI,EAAE,cAAc,EAAE,IAAI,CAAC4B,KAAK,CAACO,QAAQ,CAAC;IAI7F,KAAAC,uBAAuB,GAAG,IAAI,CAACC,sBAAsB,CAACpB,kBAAkB,CAACqB,EAAE,CAAC;IAE5E,KAAAC,uBAAuB,GAAG,IAAI,CAACF,sBAAsB,CAACpB,kBAAkB,CAACuB,IAAI,CAAC;IAE9E,KAAAC,uBAAuB,GAAG,MAAMC,MAAM,CAAC7B,yBAAyB,CAAC,IAAI,CAACU,KAAK,CAACM,KAAK,EAAE,IAAI,CAACD,KAAK,CAACe,MAAM,CAAC,CAAC;IA0LtG,KAAAC,iBAAiB,GAAG,CAACC,CAAyC,EAAEC,SAA6B,KAAI;;MACrG,MAAMb,KAAK,GAAG,IAAI,CAACc,WAAW,CAACD,SAAS,EAAED,CAAC,CAAC;MAC5C,MAAMG,SAAS,GAAG,IAAI,CAACC,cAAc,CAAChB,KAAK,CAAC;MAC5C,CAAAiB,EAAA,IAAApB,EAAA,OAAI,CAACF,KAAK,EAACuB,aAAa,cAAAD,EAAA,uBAAAA,EAAA,CAAAE,IAAA,CAAAtB,EAAA,EAAGY,MAAM,CAAC7B,yBAAyB,CAACmC,SAAS,EAAE,IAAI,CAACpB,KAAK,CAACe,MAAM,CAAC,CAAC,EAAEK,SAAS,CAAC;IAC1G,CAAC;IAeO,KAAAK,oBAAoB,GAAG,MAAK;MAChC,IAAI,CAACpB,KAAK,GAAG,CAAC;MACd,IAAI,CAACqB,aAAa,EAAE;MACpBC,aAAa,CAAC,IAAI,CAACC,UAAU,CAAC;MAC9BC,QAAQ,CAACC,mBAAmB,CAAC,SAAS,EAAE,IAAI,CAACL,oBAAoB,CAAC;IACtE,CAAC;IAEO,KAAAM,sBAAsB,GAAG,MAAK;;MAClC;MACA;MACA;MACA,IAAI,IAAI,CAAC/B,KAAK,CAACgC,GAAG,KAAKC,SAAS,IAAI,IAAI,CAACjC,KAAK,CAACkC,GAAG,KAAKD,SAAS,EAAE;QAC9D,MAAMD,GAAG,GAAG,CAAA9B,EAAA,OAAI,CAACF,KAAK,CAACgC,GAAG,cAAA9B,EAAA,cAAAA,EAAA,GAAI,CAACiC,QAAQ;QACvC,MAAMD,GAAG,GAAG,CAAAZ,EAAA,OAAI,CAACtB,KAAK,CAACkC,GAAG,cAAAZ,EAAA,cAAAA,EAAA,GAAIa,QAAQ;QACtC,MAAMC,aAAa,GAAG,IAAI,CAACvB,uBAAuB,EAAE;QACpD,IAAIuB,aAAa,IAAIJ,GAAG,IAAII,aAAa,IAAIF,GAAG,EAAE;UAC9C,IAAI,CAACT,oBAAoB,EAAE;UAC3B;QACJ;MACJ;MACA,MAAML,SAAS,GAAG,IAAI,CAACC,cAAc,CAAC,IAAI,CAAChB,KAAK,CAAC;MACjD,CAAAgC,EAAA,IAAAC,EAAA,OAAI,CAACtC,KAAK,EAACuB,aAAa,cAAAc,EAAA,uBAAAA,EAAA,CAAAb,IAAA,CAAAc,EAAA,EAAGxB,MAAM,CAAC7B,yBAAyB,CAACmC,SAAS,EAAE,IAAI,CAACpB,KAAK,CAACe,MAAM,CAAC,CAAC,EAAEK,SAAS,CAAC;IAC1G,CAAC;IAED;IACA;IAEQ,KAAAmB,gBAAgB,GAAItB,CAAqC,IAAI;;MACjE;MACA,IAAI,CAACuB,QAAQ,CAAC;QAAE3C,uBAAuB,EAAE,IAAI,CAACG,KAAK,CAACyC;MAAiB,CAAE,CAAC;MACxE,CAAAnB,EAAA,IAAApB,EAAA,OAAI,CAACF,KAAK,EAAC0C,OAAO,cAAApB,EAAA,uBAAAA,EAAA,CAAAE,IAAA,CAAAtB,EAAA,EAAGe,CAAC,CAAC;IAC3B,CAAC;IAEO,KAAA0B,eAAe,GAAI1B,CAAqC,IAAI;;MAChE;MACA,IAAI,CAACuB,QAAQ,CAAC;QAAE3C,uBAAuB,EAAE;MAAK,CAAE,CAAC;MAEjD,IAAI,IAAI,CAACG,KAAK,CAAC4C,gBAAgB,EAAE;QAC7B,MAAM;UAAE3C;QAAK,CAAE,GAAGgB,CAAC,CAAC4B,MAA0B;QAC9C,IAAI,CAACC,eAAe,CAAC,IAAI,CAACC,kBAAkB,CAAC9C,KAAK,CAAC,CAAC;MACxD;MAEA,CAAAqB,EAAA,IAAApB,EAAA,OAAI,CAACF,KAAK,EAACgD,MAAM,cAAA1B,EAAA,uBAAAA,EAAA,CAAAE,IAAA,CAAAtB,EAAA,EAAGe,CAAC,CAAC;IAC1B,CAAC;IAEO,KAAAgC,kBAAkB,GAAIhC,CAAwC,IAAI;;MACtE,IAAI,IAAI,CAACjB,KAAK,CAACkD,QAAQ,IAAI,IAAI,CAAClD,KAAK,CAACmD,QAAQ,EAAE;QAC5C;MACJ;MAEA,MAAMjC,SAAS,GAAG3C,KAAK,CAAC6E,oBAAoB,CAACnC,CAAC,EAAE,CAAC,WAAW,CAAC,EAAE,CAAC,SAAS,CAAC,CAAC;MAC3E,IAAIC,SAAS,KAAKe,SAAS,EAAE;QACzB;QACA;QACA;QACA;QACA;QACAhB,CAAC,CAACoC,cAAc,EAAE;QAElB,MAAMhD,KAAK,GAAG,IAAI,CAACc,WAAW,CAACD,SAAS,EAAED,CAAC,CAAC;QAC5C,IAAI,CAACI,cAAc,CAAChB,KAAK,CAAC;MAC9B;MAEA,CAAAiB,EAAA,IAAApB,EAAA,OAAI,CAACF,KAAK,EAACsD,SAAS,cAAAhC,EAAA,uBAAAA,EAAA,CAAAE,IAAA,CAAAtB,EAAA,EAAGe,CAAC,CAAC;IAC7B,CAAC;IAEO,KAAAsC,oBAAoB,GAAItC,CAA2C,IAAI;MAC3E,IAAI,IAAI,CAACjB,KAAK,CAACwD,0BAA0B,EAAE;QACvC,IAAI,CAACV,eAAe,CAAC5D,oBAAoB,CAAC+B,CAAC,CAACwC,IAAI,EAAE,IAAI,CAACzD,KAAK,CAACe,MAAM,CAAC,CAAC;QACrE,IAAI,CAACyB,QAAQ,CAAC;UAAE5C,sBAAsB,EAAE;QAAK,CAAE,CAAC;MACpD;IACJ,CAAC;IAEO,KAAA8D,uBAAuB,GAAIzC,CAA2C,IAAI;MAC9E,IAAI,IAAI,CAACjB,KAAK,CAACwD,0BAA0B,EAAE;QACvC,MAAM;UAAEC;QAAI,CAAE,GAAGxC,CAAC;QAClB,MAAM0C,cAAc,GAAGzE,oBAAoB,CAACuE,IAAI,EAAE,IAAI,CAACzD,KAAK,CAACe,MAAM,CAAC;QACpE,IAAI4C,cAAc,CAACC,MAAM,KAAK,CAAC,IAAIH,IAAI,CAACG,MAAM,GAAG,CAAC,EAAE;UAChD,IAAI,CAACpB,QAAQ,CAAC;YAAE5C,sBAAsB,EAAE;UAAI,CAAE,CAAC;QACnD,CAAC,MAAM;UACH,IAAI,CAAC4C,QAAQ,CAAC;YAAE5C,sBAAsB,EAAE;UAAK,CAAE,CAAC;QACpD;MACJ;IACJ,CAAC;IAEO,KAAAiE,mBAAmB,GAAI5C,CAAwC,IAAI;;MACvE;MACA;MACA,IAAI,IAAI,CAACjB,KAAK,CAACwD,0BAA0B,IAAI,CAACzE,2BAA2B,CAACkC,CAAC,EAAE,IAAI,CAACjB,KAAK,CAACe,MAAM,CAAC,EAAE;QAC7FE,CAAC,CAACoC,cAAc,EAAE;MACtB;MAEA;MACA,CAAA/B,EAAA,IAAApB,EAAA,OAAI,CAACF,KAAK,EAAC8D,UAAU,cAAAxC,EAAA,uBAAAA,EAAA,CAAAE,IAAA,CAAAtB,EAAA,EAAGe,CAAC,CAAC;IAC9B,CAAC;IAEO,KAAA8C,gBAAgB,GAAI9C,CAAyC,IAAI;;MACrE,IAAI,CAACb,sBAAsB,GAAG,IAAI;MAClC,CAAAkB,EAAA,IAAApB,EAAA,OAAI,CAACF,KAAK,EAACgE,OAAO,cAAA1C,EAAA,uBAAAA,EAAA,CAAAE,IAAA,CAAAtB,EAAA,EAAGe,CAAC,CAAC;IAC3B,CAAC;IAEO,KAAAgD,iBAAiB,GAAIhE,KAAa,IAAI;MAC1C,IAAImB,SAAS,GAAGnB,KAAK;MACrB,IAAI,IAAI,CAACD,KAAK,CAACwD,0BAA0B,IAAI,IAAI,CAACpD,sBAAsB,EAAE;QACtE,IAAI,CAACA,sBAAsB,GAAG,KAAK;QACnCgB,SAAS,GAAGlC,oBAAoB,CAACe,KAAK,EAAE,IAAI,CAACD,KAAK,CAACe,MAAM,CAAC;MAC9D;MAEA,IAAI,CAAC+B,eAAe,CAAC1B,SAAS,CAAC;MAC/B,IAAI,CAACoB,QAAQ,CAAC;QAAE3C,uBAAuB,EAAE;MAAK,CAAE,CAAC;IACrD,CAAC;EA0DL;EAtcW,OAAOqE,wBAAwBA,CAAClE,KAAwB,EAAEL,KAAwB;;IACrF,MAAMwE,SAAS,GAAG;MACdC,WAAW,EAAEpE,KAAK,CAACkC,GAAG;MACtBmC,WAAW,EAAErE,KAAK,CAACgC;KACtB;IAED,MAAMsC,YAAY,GAAGtE,KAAK,CAACgC,GAAG,KAAKrC,KAAK,CAAC0E,WAAW;IACpD,MAAME,YAAY,GAAGvE,KAAK,CAACkC,GAAG,KAAKvC,KAAK,CAACyE,WAAW;IACpD,MAAMI,eAAe,GAAGF,YAAY,IAAIC,YAAY;IAEpD;IACA;IACA,MAAMtE,KAAK,GAAG,CAAAqB,EAAA,IAAApB,EAAA,GAAAF,KAAK,CAACC,KAAK,cAAAC,EAAA,uBAAAA,EAAA,CAAEuE,QAAQ,EAAE,cAAAnD,EAAA,cAAAA,EAAA,GAAI3B,KAAK,CAACM,KAAK;IACpD,MAAMH,gBAAgB,GAAGP,YAAY,CAACQ,mBAAmB,CAACC,KAAK,CAAC;IAEhE,MAAM2D,cAAc,GAChB1D,KAAK,KAAKV,YAAY,CAACmF,WAAW,GAC5BnF,YAAY,CAACwD,kBAAkB,CAAC9C,KAAK,EAAEH,gBAAgB,EAAEE,KAAK,CAACgC,GAAG,EAAEhC,KAAK,CAACkC,GAAG,EAAE,CAAC,EAAElC,KAAK,CAACe,MAAM,CAAC,GAC/FxB,YAAY,CAACmF,WAAW;IAElC;IACA;IACA,IAAIF,eAAe,IAAIb,cAAc,KAAKhE,KAAK,CAACM,KAAK,EAAE;MACnD,OAAO;QAAE,GAAGkE,SAAS;QAAErE,gBAAgB;QAAEG,KAAK,EAAE0D;MAAc,CAAE;IACpE;IACA,OAAO;MAAE,GAAGQ,SAAS;MAAErE,gBAAgB;MAAEG;IAAK,CAAE;EACpD;EAMA;EACA;EACQ,OAAOF,mBAAmBA,CAACC,KAAuD;IACtF,IAAIA,KAAK,CAAC2E,aAAa,IAAI,IAAI,EAAE;MAC7B,OAAOpG,KAAK,CAACqG,kBAAkB,CAAC5E,KAAK,CAAC2E,aAAa,CAAC;IACxD,CAAC,MAAM;MACH,OAAOpG,KAAK,CAACqG,kBAAkB,CAAC5E,KAAK,CAAC6E,QAAS,CAAC;IACpD;EACJ;EAEQ,OAAO9B,kBAAkBA,CAC7B9C,KAAa,EACbH,gBAAwB,EACxBkC,GAAuB,EACvBE,GAAuB,EACvB7B,KAAK,GAAG,CAAC,EACTU,MAA0B;IAE1B,IAAI,CAAC/B,cAAc,CAACiB,KAAK,EAAEc,MAAM,CAAC,EAAE;MAChC,OAAOxB,YAAY,CAACmF,WAAW;IACnC;IACA,MAAMI,YAAY,GAAG7F,yBAAyB,CAACgB,KAAK,EAAEc,MAAM,CAAC;IAC7D,MAAMK,SAAS,GAAGhC,cAAc,CAAC0B,MAAM,CAACgE,YAAY,CAAC,GAAGzE,KAAK,EAAEP,gBAAgB,CAAC;IAChF,MAAMiF,YAAY,GAAGlG,UAAU,CAACuC,SAAS,EAAEY,GAAG,EAAEE,GAAG,CAAC;IACpD,OAAO/C,cAAc,CAAC4F,YAAY,EAAEhE,MAAM,CAAC;EAC/C;EA0BOiE,MAAMA,CAAA;IACT;IACA,MAAM;MAAEC,cAAc;MAAEC,SAAS;MAAEC,IAAI;MAAEC,KAAK;MAAEC,IAAI,GAAG,QAAQ;MAAEC;IAAK,CAAE,GAAG,IAAI,CAACtF,KAAK;IACrF,MAAMuF,gBAAgB,GAAG3H,UAAU,CAC/BI,OAAO,CAACwH,aAAa,EACrBxH,OAAO,CAACyH,SAAS,CAACJ,IAAI,EAAE;MAAED,KAAK;MAAEE;IAAK,CAAE,CAAC,EACzCJ,SAAS,CACZ;IACD,MAAMQ,OAAO,GAAG,IAAI,CAACC,aAAa,EAAE;IACpC,OACIC,KAAA,CAACjH,YAAY;MAACuG,SAAS,EAAEK,gBAAgB;MAAEJ,IAAI,EAAEA,IAAI;MAAAU,QAAA,GAChDZ,cAAc,KAAK9G,QAAQ,CAAC2H,IAAI,IAAIJ,OAAO,EAC3C,IAAI,CAACK,WAAW,EAAE,EAClBd,cAAc,KAAK9G,QAAQ,CAAC6H,KAAK,IAAIN,OAAO;IAAA,EAClC;EAEvB;EAEOO,kBAAkBA,CAACC,SAA4B,EAAEC,SAA4B;;IAChF,KAAK,CAACF,kBAAkB,CAACC,SAAS,EAAEC,SAAS,CAAC;IAE9C,IAAID,SAAS,CAAC3F,QAAQ,KAAK,IAAI,CAACP,KAAK,CAACO,QAAQ,EAAE;MAC5CjC,MAAM,CAAC4H,SAAS,CAAC3F,QAAQ,EAAE,IAAI,CAAC;MAChC,IAAI,CAACA,QAAQ,GAAGnC,UAAU,CAAC,IAAI,EAAE,cAAc,EAAE,IAAI,CAAC4B,KAAK,CAACO,QAAQ,CAAC;MACrEjC,MAAM,CAAC,IAAI,CAAC0B,KAAK,CAACO,QAAQ,EAAE,IAAI,CAACD,YAAY,CAAC;IAClD;IAEA,IAAI,IAAI,CAACX,KAAK,CAACE,uBAAuB,EAAE;MACpC,CAAAK,EAAA,OAAI,CAACI,YAAY,cAAAJ,EAAA,uBAAAA,EAAA,CAAEkG,iBAAiB,CAAC,CAAC,EAAE,IAAI,CAACzG,KAAK,CAACM,KAAK,CAAC2D,MAAM,CAAC;IACpE;IAEA,MAAMU,YAAY,GAAG,IAAI,CAACtE,KAAK,CAACgC,GAAG,KAAKkE,SAAS,CAAClE,GAAG;IACrD,MAAMuC,YAAY,GAAG,IAAI,CAACvE,KAAK,CAACkC,GAAG,KAAKgE,SAAS,CAAChE,GAAG;IACrD,MAAMsC,eAAe,GAAGF,YAAY,IAAIC,YAAY;IACpD,MAAM8B,eAAe,GAAG,IAAI,CAACrG,KAAK,CAACe,MAAM,KAAKmF,SAAS,CAACnF,MAAM;IAC9D,MAAMuF,cAAc,GAAG,IAAI,CAAC3G,KAAK,CAACM,KAAK,KAAKkG,SAAS,CAAClG,KAAK;IAE3D,IAAKuE,eAAe,IAAI8B,cAAc,IAAMD,eAAe,IAAIF,SAAS,CAAClG,KAAK,KAAKV,YAAY,CAACmF,WAAY,EAAE;MAC1G;MACA,MAAM6B,YAAY,GAAGF,eAAe,GAAGF,SAAS,CAAClG,KAAK,GAAG,IAAI,CAACN,KAAK,CAACM,KAAK;MACzE,MAAMuG,aAAa,GAAGvH,yBAAyB,CAACsH,YAAY,EAAEL,SAAS,CAACnF,MAAM,CAAC;MAC/E,MAAM0F,cAAc,GAAGtH,cAAc,CAAC,CAACqH,aAAa,EAAE,IAAI,CAACxG,KAAK,CAACe,MAAM,CAAC;MAExE,CAAAuB,EAAA,IAAAhB,EAAA,OAAI,CAACtB,KAAK,EAAC0G,aAAa,cAAApE,EAAA,uBAAAA,EAAA,CAAAd,IAAA,CAAAF,EAAA,EAAG,CAACkF,aAAa,EAAEC,cAAc,EAAE,IAAI,CAACnG,YAAY,CAAC;IACjF;EACJ;EAEUqG,aAAaA,CAACC,SAA6C;IACjE,MAAM;MAAEC,aAAa;MAAE3E,GAAG;MAAEF,GAAG;MAAE2C,aAAa;MAAEE,QAAQ;MAAE5E;IAAK,CAAE,GAAG2G,SAAS;IAC7E,IAAI5E,GAAG,IAAI,IAAI,IAAIE,GAAG,IAAI,IAAI,IAAIF,GAAG,GAAGE,GAAG,EAAE;MACzC4E,OAAO,CAACC,KAAK,CAACvI,MAAM,CAACwI,qBAAqB,CAAC;IAC/C;IACA,IAAInC,QAAS,IAAI,CAAC,EAAE;MAChBiC,OAAO,CAACC,KAAK,CAACvI,MAAM,CAACyI,oCAAoC,CAAC;IAC9D;IACA,IAAItC,aAAa,IAAIA,aAAa,IAAI,CAAC,EAAE;MACrCmC,OAAO,CAACC,KAAK,CAACvI,MAAM,CAAC0I,0CAA0C,CAAC;IACpE;IACA,IAAIL,aAAa,IAAIA,aAAa,IAAI,CAAC,EAAE;MACrCC,OAAO,CAACC,KAAK,CAACvI,MAAM,CAAC2I,0CAA0C,CAAC;IACpE;IACA,IAAIxC,aAAa,IAAIA,aAAa,GAAGE,QAAS,EAAE;MAC5CiC,OAAO,CAACC,KAAK,CAACvI,MAAM,CAAC4I,mCAAmC,CAAC;IAC7D;IACA,IAAIP,aAAa,IAAIA,aAAa,GAAGhC,QAAS,EAAE;MAC5CiC,OAAO,CAACC,KAAK,CAACvI,MAAM,CAAC6I,mCAAmC,CAAC;IAC7D;IAEA;IACA,IAAIpH,KAAK,IAAI,IAAI,EAAE;MACf,MAAMH,gBAAgB,GAAGP,YAAY,CAACQ,mBAAmB,CAAC6G,SAAS,CAAC;MACpE,MAAMjD,cAAc,GAAGpE,YAAY,CAACwD,kBAAkB,CAClD9C,KAAK,CAACwE,QAAQ,EAAE,EAChB3E,gBAAgB,EAChBkC,GAAG,EACHE,GAAG,EACH,CAAC,EACD,IAAI,CAAClC,KAAK,CAACe,MAAM,CACpB;MACD,MAAMuG,iBAAiB,GAAG3D,cAAc,KAAK1D,KAAK,CAACwE,QAAQ,EAAE;MAC7D,MAAMgC,cAAc,GAAGtH,cAAc,CACjC2B,MAAM,CAAC7B,yBAAyB,CAACgB,KAAK,EAAE,IAAI,CAACD,KAAK,CAACe,MAAM,CAAC,CAAC,EAC3D,IAAI,CAACf,KAAK,CAACe,MAAM,CACpB;MACD,MAAMwG,cAAc,GAAG5D,cAAc,KAAK8C,cAAc;MAExD,IAAIa,iBAAiB,IAAIC,cAAc,EAAE;QACrCT,OAAO,CAACU,IAAI,CAAChJ,MAAM,CAACiJ,sCAAsC,CAAC;MAC/D;IACJ;EACJ;EAEA;EACA;EAEQ9B,aAAaA,CAAA;IACjB,MAAM;MAAE+B,MAAM;MAAExF,GAAG;MAAEF,GAAG;MAAEjB;IAAM,CAAE,GAAG,IAAI,CAACf,KAAK;IAC/C,MAAMC,KAAK,GAAGhB,yBAAyB,CAAC,IAAI,CAACU,KAAK,CAACM,KAAK,EAAEc,MAAM,CAAC;IACjE,MAAMmC,QAAQ,GAAG,IAAI,CAAClD,KAAK,CAACkD,QAAQ,IAAI,IAAI,CAAClD,KAAK,CAACmD,QAAQ;IAC3D,MAAMwE,mBAAmB,GAAGzF,GAAG,KAAKD,SAAS,IAAIhC,KAAK,KAAK,EAAE,IAAI,CAACA,KAAK,IAAIiC,GAAG;IAC9E,MAAM0F,mBAAmB,GAAG5F,GAAG,KAAKC,SAAS,IAAIhC,KAAK,KAAK,EAAE,IAAI,CAACA,KAAK,IAAI+B,GAAG;IAE9E,OACI4D,KAAA,CAACnH,WAAW;MAACyG,SAAS,EAAElH,OAAO,CAAC6J,KAAK;MAAqBC,QAAQ,EAAE,IAAI;MAAAjC,QAAA,GACpEkC,IAAA,CAACrJ,MAAM;QAAA,cACQ,WAAW;QAAA,iBACP,IAAI,CAACe,cAAc;QAClCyD,QAAQ,EAAEA,QAAQ,IAAIyE,mBAAmB;QACzCK,IAAI,EAAED,IAAA,CAACjK,SAAS,KAAG;QACnB4J,MAAM,EAAEA,MAAM;QAAA,GACV,IAAI,CAAClH;MAAuB,EAClC,EACFuH,IAAA,CAACrJ,MAAM;QAAA,cACQ,WAAW;QAAA,iBACP,IAAI,CAACe,cAAc;QAClCyD,QAAQ,EAAEA,QAAQ,IAAI0E,mBAAmB;QACzCI,IAAI,EAAED,IAAA,CAAClK,WAAW,KAAG;QACrB6J,MAAM,EAAEA,MAAM;QAAA,GACV,IAAI,CAAC/G;MAAuB,EAClC;IAAA,GAhBqC,cAAc,CAiB3C;EAEtB;EAEQoF,WAAWA,CAAA;IACf,MAAMkC,mBAAmB,GAAG5J,kBAAkB,CAAC,IAAI,CAAC2B,KAAK,EAAEV,cAAc,EAAE,IAAI,CAAC;IAChF,MAAM8C,aAAa,GAAG,IAAI,CAACvB,uBAAuB,EAAE;IAEpD,OACIkH,IAAA,CAACnJ,UAAU;MACPsJ,YAAY,EAAE,IAAI,CAAClI,KAAK,CAACkI,YAAY;MACrCC,YAAY,EAAC,KAAK;MAClBC,EAAE,EAAE,IAAI,CAAC3I,cAAc;MACvB4I,IAAI,EAAE,IAAI,CAACrI,KAAK,CAACwD,0BAA0B,GAAG,YAAY,GAAGvB,SAAS;MAAA,GAClEgG,mBAAmB;MAAA,iBACR,IAAI,CAACjI,KAAK,CAACkC,GAAG;MAAA,iBACd,IAAI,CAAClC,KAAK,CAACgC,GAAG;MAAA,iBACdI,aAAa;MAC5BsF,MAAM,EAAE,IAAI,CAAC/H,KAAK,CAACC,sBAAsB,GAAG1B,MAAM,CAACoK,MAAM,GAAG,IAAI,CAACtI,KAAK,CAAC0H,MAAM;MAC7Ea,cAAc,EAAE,IAAI,CAACvI,KAAK,CAACuI,cAAc;MACzChI,QAAQ,EAAE,IAAI,CAACA,QAAQ;MACvBiI,SAAS,EAAE,IAAI,CAACxI,KAAK,CAACwI,SAAS;MAC/B;MACApD,KAAK,EAAE,IAAI,CAACpF,KAAK,CAACoF,KAAK;MACvBqD,WAAW,EAAE,IAAI,CAACzI,KAAK,CAACyI,WAAW;MACnCC,QAAQ,EAAE,IAAI,CAAC1I,KAAK,CAAC0I,QAAQ;MAC7BhG,OAAO,EAAE,IAAI,CAACH,gBAAgB;MAC9BS,MAAM,EAAE,IAAI,CAACL,eAAe;MAC5BgG,gBAAgB,EAAE,IAAI,CAACpF,oBAAoB;MAC3CqF,mBAAmB,EAAE,IAAI,CAAClF,uBAAuB;MACjDJ,SAAS,EAAE,IAAI,CAACL,kBAAkB;MAClC;MACAa,UAAU,EAAE,IAAI,CAACD,mBAAmB;MACpCG,OAAO,EAAE,IAAI,CAACD,gBAAgB;MAC9B2C,aAAa,EAAE,IAAI,CAACzC,iBAAiB;MACrC4E,YAAY,EAAE,IAAI,CAAC7I,KAAK,CAAC6I,YAAY;MACrCxD,IAAI,EAAE,IAAI,CAACrF,KAAK,CAACqF,IAAI;MACrB;MACAC,KAAK,EAAE,IAAI,CAACtF,KAAK,CAACsF,KAAK;MACvBrF,KAAK,EAAE,IAAI,CAACN,KAAK,CAACM;IAAK,EACzB;EAEV;EAEA;EACA;EAEQQ,sBAAsBA,CAACS,SAA6B;IACxD,OAAO;MACH;MACAoC,SAAS,EAAEwF,GAAG,IAAG;QACb,IAAI,CAAC,IAAI,CAAC9I,KAAK,CAACkD,QAAQ,IAAI3E,KAAK,CAACwK,eAAe,CAACD,GAAG,CAAC,EAAE;UACpD,IAAI,CAAC9H,iBAAiB,CAAC8H,GAAG,EAAE5H,SAAS,CAAC;QAC1C;MACJ,CAAC;MACD8H,WAAW,EAAEF,GAAG,IAAG;QACf,IAAI,CAAC,IAAI,CAAC9I,KAAK,CAACkD,QAAQ,EAAE;UACtB,IAAI,CAAClC,iBAAiB,CAAC8H,GAAG,EAAE5H,SAAS,CAAC;UACtC,IAAI,CAAC+H,qBAAqB,EAAE;QAChC;MACJ;KACH;EACL;EAQQA,qBAAqBA,CAAA;IACzB;IACA;IACA;IACApH,QAAQ,CAACqH,gBAAgB,CAAC,SAAS,EAAE,IAAI,CAACzH,oBAAoB,CAAC;IAE/D;IACA;IACA,IAAI,CAAC0H,UAAU,CAAC,MAAK;MACjB,IAAI,CAACvH,UAAU,GAAGwH,MAAM,CAACC,WAAW,CAAC,IAAI,CAACtH,sBAAsB,EAAExC,YAAY,CAAC+J,0BAA0B,CAAC;IAC9G,CAAC,EAAE/J,YAAY,CAACgK,uBAAuB,CAAC;EAC5C;EAkHA;EACA;EAEQzG,eAAeA,CAAC0D,aAAqB;;IACzC,IAAI,IAAI,CAACxG,KAAK,CAACC,KAAK,IAAI,IAAI,EAAE;MAC1B,IAAI,CAACuC,QAAQ,CAAC;QAAEvC,KAAK,EAAEuG;MAAa,CAAE,CAAC;IAC3C;IAEA,CAAAlF,EAAA,IAAApB,EAAA,OAAI,CAACF,KAAK,EAAC0G,aAAa,cAAApF,EAAA,uBAAAA,EAAA,CAAAE,IAAA,CAAAtB,EAAA,EACpBY,MAAM,CAAC7B,yBAAyB,CAACuH,aAAa,EAAE,IAAI,CAACxG,KAAK,CAACe,MAAM,CAAC,CAAC,EACnEyF,aAAa,EACb,IAAI,CAAClG,YAAY,CACpB;EACL;EAEQe,cAAcA,CAAChB,KAAa;IAChC;IACA,MAAMmJ,SAAS,GAAG,IAAI,CAAC7J,KAAK,CAACM,KAAK,KAAKV,YAAY,CAACmF,WAAW,GAAGnF,YAAY,CAACkK,UAAU,GAAG,IAAI,CAAC9J,KAAK,CAACM,KAAK;IAC5G,MAAMmB,SAAS,GAAG,IAAI,CAAC2B,kBAAkB,CAACyG,SAAS,EAAEnJ,KAAK,CAAC;IAE3D,IAAIe,SAAS,KAAK,IAAI,CAACzB,KAAK,CAACM,KAAK,EAAE;MAChC,IAAI,CAAC6C,eAAe,CAAC1B,SAAS,CAAC;MAC/B,IAAI,CAACoB,QAAQ,CAAC;QAAE3C,uBAAuB,EAAE,IAAI,CAACG,KAAK,CAAC0J;MAAqB,CAAE,CAAC;IAChF;IAEA;IACA,OAAOtI,SAAS;EACpB;EAEQuI,iBAAiBA,CAACzI,SAA6B,EAAE0I,iBAA0B,EAAEC,eAAwB;IACzG,MAAM;MAAEhD,aAAa;MAAElC,aAAa;MAAEE;IAAQ,CAAE,GAAG,IAAI,CAAC7E,KAAK;IAE7D,IAAI4J,iBAAiB,IAAI/C,aAAa,IAAI,IAAI,EAAE;MAC5C,OAAO3F,SAAS,GAAG2F,aAAa;IACpC,CAAC,MAAM,IAAIgD,eAAe,IAAIlF,aAAa,IAAI,IAAI,EAAE;MACjD,OAAOzD,SAAS,GAAGyD,aAAa;IACpC,CAAC,MAAM;MACH,OAAOzD,SAAS,GAAG2D,QAAS;IAChC;EACJ;EAEQ9B,kBAAkBA,CAAC9C,KAAa,EAAEI,KAAK,GAAG,CAAC;IAC/C,OAAOd,YAAY,CAACwD,kBAAkB,CAClC9C,KAAK,EACL,IAAI,CAACN,KAAK,CAACG,gBAAgB,EAC3B,IAAI,CAACE,KAAK,CAACgC,GAAG,EACd,IAAI,CAAChC,KAAK,CAACkC,GAAG,EACd7B,KAAK,EACL,IAAI,CAACL,KAAK,CAACe,MAAM,CACpB;EACL;EAEQI,WAAWA,CAACD,SAA6B,EAAED,CAAyC;IACxF,IAAI,CAACZ,KAAK,GAAG,IAAI,CAACsJ,iBAAiB,CAACzI,SAAS,EAAED,CAAC,CAAC6I,QAAQ,EAAE7I,CAAC,CAAC8I,MAAM,CAAC;IACpE,OAAO,IAAI,CAAC1J,KAAK;EACrB;;AA5dcd,YAAA,CAAAyK,WAAW,GAAG,GAAG/L,kBAAkB,eAAe;AAElDsB,YAAA,CAAAmF,WAAW,GAAG,EAAE;AAEhBnF,YAAA,CAAAkK,UAAU,GAAG,GAAG;AAIhBlK,YAAA,CAAA0K,YAAY,GAAsB;EAC5CzG,0BAA0B,EAAE,IAAI;EAChCyB,cAAc,EAAE9G,QAAQ,CAAC6H,KAAK;EAC9BpD,gBAAgB,EAAE,KAAK;EACvBzC,YAAY,EAAEZ,YAAY,CAACmF,WAAW;EACtCU,KAAK,EAAE,KAAK;EACZyB,aAAa,EAAE,EAAE;EACjBlC,aAAa,EAAE,GAAG;EAClBlC,gBAAgB,EAAE,KAAK;EACvBiH,oBAAoB,EAAE,KAAK;EAC3BrE,IAAI,EAAE,QAAQ;EACdC,KAAK,EAAE,KAAK;EACZT,QAAQ,EAAE;CACb;AA8BctF,YAAA,CAAAgK,uBAAuB,GAAG,GAAG;AAE7BhK,YAAA,CAAA+J,0BAA0B,GAAG,GAAG","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}