{"ast":null,"code":"import { jsx as _jsx } from \"react/jsx-runtime\";\n/*\n * Copyright 2021 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport classNames from \"classnames\";\nimport { useCallback, useMemo, useState } from \"react\";\nimport { CSSTransition, TransitionGroup } from \"react-transition-group\";\nimport { Classes, DISPLAYNAME_PREFIX } from \"../../common\";\nimport { usePrevious } from \"../../hooks\";\nimport { PanelView } from \"./panelView\";\n/**\n * Panel stack component.\n *\n * @see https://blueprintjs.com/docs/#core/components/panel-stack\n * @template T type union of all possible panels in this stack\n */\nexport const PanelStack = props => {\n  var _a;\n  const {\n    initialPanel,\n    onClose,\n    onOpen,\n    renderActivePanelOnly = true,\n    showPanelHeader = true,\n    stack: propsStack\n  } = props;\n  const isControlled = propsStack != null;\n  const [localStack, setLocalStack] = useState(initialPanel !== undefined ? [initialPanel] : []);\n  const stack = useMemo(() => isControlled ? propsStack.slice().reverse() : localStack, [localStack, isControlled, propsStack]);\n  const prevStackLength = (_a = usePrevious(stack.length)) !== null && _a !== void 0 ? _a : stack.length;\n  const direction = stack.length - prevStackLength < 0 ? \"pop\" : \"push\";\n  const handlePanelOpen = useCallback(panel => {\n    onOpen === null || onOpen === void 0 ? void 0 : onOpen(panel);\n    if (!isControlled) {\n      setLocalStack(prevStack => [panel, ...prevStack]);\n    }\n  }, [onOpen, isControlled]);\n  const handlePanelClose = useCallback(panel => {\n    onClose === null || onClose === void 0 ? void 0 : onClose(panel);\n    if (!isControlled) {\n      setLocalStack(prevStack => prevStack.slice(1));\n    }\n  }, [onClose, isControlled]);\n  // early return, after all hooks are called\n  if (stack.length === 0) {\n    return null;\n  }\n  const panelsToRender = renderActivePanelOnly ? [stack[0]] : stack;\n  const panels = panelsToRender.map((panel, index) => {\n    // With renderActivePanelOnly={false} we would keep all the CSSTransitions rendered,\n    // therefore they would not trigger the \"enter\" transition event as they were entered.\n    // To force the enter event, we want to change the key, but stack.length is not enough\n    // and a single panel should not rerender as long as it's hidden.\n    // This key contains two parts: first one, stack.length - index is constant (and unique) for each panel,\n    // second one, active changes only when the panel becomes or stops being active.\n    const layer = stack.length - index;\n    const key = renderActivePanelOnly ? stack.length : layer;\n    return _jsx(CSSTransition, {\n      classNames: Classes.PANEL_STACK,\n      timeout: 400,\n      children: _jsx(PanelView, {\n        onClose: handlePanelClose,\n        onOpen: handlePanelOpen,\n        panel: panel,\n        previousPanel: stack[index + 1],\n        showHeader: showPanelHeader\n      })\n    }, key);\n  }).reverse();\n  const classes = classNames(Classes.PANEL_STACK, `${Classes.PANEL_STACK}-${direction}`, props.className);\n  return _jsx(TransitionGroup, {\n    className: classes,\n    component: \"div\",\n    children: panels\n  });\n};\nPanelStack.displayName = `${DISPLAYNAME_PREFIX}.PanelStack`;\n/** @deprecated Use `PanelStack` instead */\nexport const PanelStack2 = PanelStack;","map":{"version":3,"names":["classNames","useCallback","useMemo","useState","CSSTransition","TransitionGroup","Classes","DISPLAYNAME_PREFIX","usePrevious","PanelView","PanelStack","props","initialPanel","onClose","onOpen","renderActivePanelOnly","showPanelHeader","stack","propsStack","isControlled","localStack","setLocalStack","undefined","slice","reverse","prevStackLength","_a","length","direction","handlePanelOpen","panel","prevStack","handlePanelClose","panelsToRender","panels","map","index","layer","key","_jsx","PANEL_STACK","timeout","children","previousPanel","showHeader","classes","className","component","displayName","PanelStack2"],"sources":["/Users/husseingalal/Desktop/Hackathon/Elrond/frontend/node_modules/@blueprintjs/core/src/components/panel-stack/panelStack.tsx"],"sourcesContent":["/*\n * Copyright 2021 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport classNames from \"classnames\";\nimport { useCallback, useMemo, useState } from \"react\";\nimport { CSSTransition, TransitionGroup } from \"react-transition-group\";\n\nimport { Classes, DISPLAYNAME_PREFIX, type Props } from \"../../common\";\nimport { usePrevious } from \"../../hooks\";\n\nimport type { Panel } from \"./panelTypes\";\nimport { PanelView } from \"./panelView\";\n\n/** @deprecated Use `PanelStackProps` instead */\nexport type PanelStack2Props<T extends Panel<object>> = PanelStackProps<T>;\n\n/**\n * @template T type union of all possible panels in this stack\n */\nexport interface PanelStackProps<T extends Panel<object>> extends Props {\n    /**\n     * The initial panel to show on mount. This panel cannot be removed from the\n     * stack and will appear when the stack is empty.\n     * This prop is only used in uncontrolled mode and is thus mutually\n     * exclusive with the `stack` prop.\n     */\n    initialPanel?: T;\n\n    /**\n     * Callback invoked when the user presses the back button or a panel\n     * closes itself with a `closePanel()` action.\n     */\n    onClose?: (removedPanel: T) => void;\n\n    /**\n     * Callback invoked when a panel opens a new panel with an `openPanel(panel)`\n     * action.\n     */\n    onOpen?: (addedPanel: T) => void;\n\n    /**\n     * If false, PanelStack will render all panels in the stack to the DOM, allowing their\n     * React component trees to maintain state as a user navigates through the stack.\n     * Panels other than the currently active one will be invisible.\n     *\n     * @default true\n     */\n    renderActivePanelOnly?: boolean;\n\n    /**\n     * Whether to show the header with the \"back\" button in each panel.\n     *\n     * @default true\n     */\n    showPanelHeader?: boolean;\n\n    /**\n     * The full stack of panels in controlled mode. The last panel in the stack\n     * will be displayed.\n     */\n    stack?: readonly T[];\n}\n\ninterface PanelStackComponent {\n    /**\n     * @template T type union of all possible panels in this stack\n     */\n    <T extends Panel<object>>(props: PanelStackProps<T>): React.JSX.Element | null;\n    displayName: string;\n}\n\n/**\n * Panel stack component.\n *\n * @see https://blueprintjs.com/docs/#core/components/panel-stack\n * @template T type union of all possible panels in this stack\n */\nexport const PanelStack: PanelStackComponent = <T extends Panel<object>>(props: PanelStackProps<T>) => {\n    const {\n        initialPanel,\n        onClose,\n        onOpen,\n        renderActivePanelOnly = true,\n        showPanelHeader = true,\n        stack: propsStack,\n    } = props;\n    const isControlled = propsStack != null;\n\n    const [localStack, setLocalStack] = useState<T[]>(initialPanel !== undefined ? [initialPanel] : []);\n    const stack = useMemo(\n        () => (isControlled ? propsStack.slice().reverse() : localStack),\n        [localStack, isControlled, propsStack],\n    );\n    const prevStackLength = usePrevious(stack.length) ?? stack.length;\n    const direction = stack.length - prevStackLength < 0 ? \"pop\" : \"push\";\n\n    const handlePanelOpen = useCallback(\n        (panel: T) => {\n            onOpen?.(panel);\n            if (!isControlled) {\n                setLocalStack(prevStack => [panel, ...prevStack]);\n            }\n        },\n        [onOpen, isControlled],\n    );\n    const handlePanelClose = useCallback(\n        (panel: T) => {\n            onClose?.(panel);\n            if (!isControlled) {\n                setLocalStack(prevStack => prevStack.slice(1));\n            }\n        },\n        [onClose, isControlled],\n    );\n\n    // early return, after all hooks are called\n    if (stack.length === 0) {\n        return null;\n    }\n\n    const panelsToRender = renderActivePanelOnly ? [stack[0]] : stack;\n    const panels = panelsToRender\n        .map((panel: T, index: number) => {\n            // With renderActivePanelOnly={false} we would keep all the CSSTransitions rendered,\n            // therefore they would not trigger the \"enter\" transition event as they were entered.\n            // To force the enter event, we want to change the key, but stack.length is not enough\n            // and a single panel should not rerender as long as it's hidden.\n            // This key contains two parts: first one, stack.length - index is constant (and unique) for each panel,\n            // second one, active changes only when the panel becomes or stops being active.\n            const layer = stack.length - index;\n            const key = renderActivePanelOnly ? stack.length : layer;\n\n            return (\n                <CSSTransition classNames={Classes.PANEL_STACK} key={key} timeout={400}>\n                    <PanelView<T>\n                        onClose={handlePanelClose}\n                        onOpen={handlePanelOpen}\n                        panel={panel}\n                        previousPanel={stack[index + 1]}\n                        showHeader={showPanelHeader}\n                    />\n                </CSSTransition>\n            );\n        })\n        .reverse();\n\n    const classes = classNames(Classes.PANEL_STACK, `${Classes.PANEL_STACK}-${direction}`, props.className);\n\n    return (\n        <TransitionGroup className={classes} component=\"div\">\n            {panels}\n        </TransitionGroup>\n    );\n};\nPanelStack.displayName = `${DISPLAYNAME_PREFIX}.PanelStack`;\n\n/** @deprecated Use `PanelStack` instead */\nexport const PanelStack2 = PanelStack;\nexport type PanelStack2 = PanelStackComponent;\n"],"mappings":";AAAA;;;;;;;;;;;;;;;AAgBA,OAAOA,UAAU,MAAM,YAAY;AACnC,SAASC,WAAW,EAAEC,OAAO,EAAEC,QAAQ,QAAQ,OAAO;AACtD,SAASC,aAAa,EAAEC,eAAe,QAAQ,wBAAwB;AAEvE,SAASC,OAAO,EAAEC,kBAAkB,QAAoB,cAAc;AACtE,SAASC,WAAW,QAAQ,aAAa;AAGzC,SAASC,SAAS,QAAQ,aAAa;AA4DvC;;;;;;AAMA,OAAO,MAAMC,UAAU,GAAkDC,KAAyB,IAAI;;EAClG,MAAM;IACFC,YAAY;IACZC,OAAO;IACPC,MAAM;IACNC,qBAAqB,GAAG,IAAI;IAC5BC,eAAe,GAAG,IAAI;IACtBC,KAAK,EAAEC;EAAU,CACpB,GAAGP,KAAK;EACT,MAAMQ,YAAY,GAAGD,UAAU,IAAI,IAAI;EAEvC,MAAM,CAACE,UAAU,EAAEC,aAAa,CAAC,GAAGlB,QAAQ,CAAMS,YAAY,KAAKU,SAAS,GAAG,CAACV,YAAY,CAAC,GAAG,EAAE,CAAC;EACnG,MAAMK,KAAK,GAAGf,OAAO,CACjB,MAAOiB,YAAY,GAAGD,UAAU,CAACK,KAAK,EAAE,CAACC,OAAO,EAAE,GAAGJ,UAAW,EAChE,CAACA,UAAU,EAAED,YAAY,EAAED,UAAU,CAAC,CACzC;EACD,MAAMO,eAAe,GAAG,CAAAC,EAAA,GAAAlB,WAAW,CAACS,KAAK,CAACU,MAAM,CAAC,cAAAD,EAAA,cAAAA,EAAA,GAAIT,KAAK,CAACU,MAAM;EACjE,MAAMC,SAAS,GAAGX,KAAK,CAACU,MAAM,GAAGF,eAAe,GAAG,CAAC,GAAG,KAAK,GAAG,MAAM;EAErE,MAAMI,eAAe,GAAG5B,WAAW,CAC9B6B,KAAQ,IAAI;IACThB,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAGgB,KAAK,CAAC;IACf,IAAI,CAACX,YAAY,EAAE;MACfE,aAAa,CAACU,SAAS,IAAI,CAACD,KAAK,EAAE,GAAGC,SAAS,CAAC,CAAC;IACrD;EACJ,CAAC,EACD,CAACjB,MAAM,EAAEK,YAAY,CAAC,CACzB;EACD,MAAMa,gBAAgB,GAAG/B,WAAW,CAC/B6B,KAAQ,IAAI;IACTjB,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAGiB,KAAK,CAAC;IAChB,IAAI,CAACX,YAAY,EAAE;MACfE,aAAa,CAACU,SAAS,IAAIA,SAAS,CAACR,KAAK,CAAC,CAAC,CAAC,CAAC;IAClD;EACJ,CAAC,EACD,CAACV,OAAO,EAAEM,YAAY,CAAC,CAC1B;EAED;EACA,IAAIF,KAAK,CAACU,MAAM,KAAK,CAAC,EAAE;IACpB,OAAO,IAAI;EACf;EAEA,MAAMM,cAAc,GAAGlB,qBAAqB,GAAG,CAACE,KAAK,CAAC,CAAC,CAAC,CAAC,GAAGA,KAAK;EACjE,MAAMiB,MAAM,GAAGD,cAAc,CACxBE,GAAG,CAAC,CAACL,KAAQ,EAAEM,KAAa,KAAI;IAC7B;IACA;IACA;IACA;IACA;IACA;IACA,MAAMC,KAAK,GAAGpB,KAAK,CAACU,MAAM,GAAGS,KAAK;IAClC,MAAME,GAAG,GAAGvB,qBAAqB,GAAGE,KAAK,CAACU,MAAM,GAAGU,KAAK;IAExD,OACIE,IAAA,CAACnC,aAAa;MAACJ,UAAU,EAAEM,OAAO,CAACkC,WAAW;MAAYC,OAAO,EAAE,GAAG;MAAAC,QAAA,EAClEH,IAAA,CAAC9B,SAAS;QACNI,OAAO,EAAEmB,gBAAgB;QACzBlB,MAAM,EAAEe,eAAe;QACvBC,KAAK,EAAEA,KAAK;QACZa,aAAa,EAAE1B,KAAK,CAACmB,KAAK,GAAG,CAAC,CAAC;QAC/BQ,UAAU,EAAE5B;MAAe;IAC7B,GAP+CsB,GAAG,CAQxC;EAExB,CAAC,CAAC,CACDd,OAAO,EAAE;EAEd,MAAMqB,OAAO,GAAG7C,UAAU,CAACM,OAAO,CAACkC,WAAW,EAAE,GAAGlC,OAAO,CAACkC,WAAW,IAAIZ,SAAS,EAAE,EAAEjB,KAAK,CAACmC,SAAS,CAAC;EAEvG,OACIP,IAAA,CAAClC,eAAe;IAACyC,SAAS,EAAED,OAAO;IAAEE,SAAS,EAAC,KAAK;IAAAL,QAAA,EAC/CR;EAAM,EACO;AAE1B,CAAC;AACDxB,UAAU,CAACsC,WAAW,GAAG,GAAGzC,kBAAkB,aAAa;AAE3D;AACA,OAAO,MAAM0C,WAAW,GAAGvC,UAAU","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}