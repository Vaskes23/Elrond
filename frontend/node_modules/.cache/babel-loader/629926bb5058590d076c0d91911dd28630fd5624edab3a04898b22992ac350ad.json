{"ast":null,"code":"import { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\n/*\n * Copyright 2021 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { createContext, useCallback, useMemo, useReducer } from \"react\";\nimport { shallowCompareKeys } from \"../../common/utils\";\nimport { HotkeysDialog } from \"../../components/hotkeys/hotkeysDialog\";\nconst initialHotkeysState = {\n  hasProvider: false,\n  hotkeys: [],\n  isDialogOpen: false\n};\nconst noOpDispatch = () => null;\n/**\n * A React context used to register and deregister hotkeys as components are mounted and unmounted in an application.\n * Users should take care to make sure that only _one_ of these is instantiated and used within an application, especially\n * if using global hotkeys.\n *\n * You will likely not be using this HotkeysContext directly, except in cases where you need to get a direct handle on an\n * existing context instance for advanced use cases involving nested HotkeysProviders.\n *\n * For more information, see the [HotkeysProvider documentation](https://blueprintjs.com/docs/#core/context/hotkeys-provider).\n */\nexport const HotkeysContext = createContext([initialHotkeysState, noOpDispatch]);\nconst hotkeysReducer = (state, action) => {\n  switch (action.type) {\n    case \"ADD_HOTKEYS\":\n      // only pick up unique hotkeys which haven't been registered already\n      const newUniqueHotkeys = [];\n      for (const a of action.payload) {\n        let isUnique = true;\n        for (const b of state.hotkeys) {\n          isUnique && (isUnique = !shallowCompareKeys(a, b, {\n            exclude: [\"onKeyDown\", \"onKeyUp\"]\n          }));\n        }\n        if (isUnique) {\n          newUniqueHotkeys.push(a);\n        }\n      }\n      return {\n        ...state,\n        hotkeys: [...state.hotkeys, ...newUniqueHotkeys]\n      };\n    case \"REMOVE_HOTKEYS\":\n      return {\n        ...state,\n        hotkeys: state.hotkeys.filter(key => action.payload.indexOf(key) === -1)\n      };\n    case \"OPEN_DIALOG\":\n      return {\n        ...state,\n        isDialogOpen: true\n      };\n    case \"CLOSE_DIALOG\":\n      return {\n        ...state,\n        isDialogOpen: false\n      };\n    default:\n      return state;\n  }\n};\n/**\n * Hotkeys context provider, necessary for the `useHotkeys` hook.\n *\n * @see https://blueprintjs.com/docs/#core/context/hotkeys-provider\n */\nexport const HotkeysProvider = ({\n  children,\n  dialogProps,\n  renderDialog,\n  value\n}) => {\n  var _a;\n  const hasExistingContext = value != null;\n  const fallbackReducer = useReducer(hotkeysReducer, {\n    ...initialHotkeysState,\n    hasProvider: true\n  });\n  const [state, dispatch] = value !== null && value !== void 0 ? value : fallbackReducer;\n  // The `useState` array isn't stable between renders -- so memo it outselves\n  const contextValue = useMemo(() => [state, dispatch], [state, dispatch]);\n  const handleDialogClose = useCallback(() => dispatch({\n    type: \"CLOSE_DIALOG\"\n  }), [dispatch]);\n  const dialog = (_a = renderDialog === null || renderDialog === void 0 ? void 0 : renderDialog(state, {\n    handleDialogClose\n  })) !== null && _a !== void 0 ? _a : _jsx(HotkeysDialog, {\n    ...dialogProps,\n    isOpen: state.isDialogOpen,\n    hotkeys: state.hotkeys,\n    onClose: handleDialogClose\n  });\n  // if we are working with an existing context, we don't need to generate our own dialog\n  return _jsxs(HotkeysContext.Provider, {\n    value: contextValue,\n    children: [children, hasExistingContext ? undefined : dialog]\n  });\n};","map":{"version":3,"names":["createContext","useCallback","useMemo","useReducer","shallowCompareKeys","HotkeysDialog","initialHotkeysState","hasProvider","hotkeys","isDialogOpen","noOpDispatch","HotkeysContext","hotkeysReducer","state","action","type","newUniqueHotkeys","a","payload","isUnique","b","exclude","push","filter","key","indexOf","HotkeysProvider","children","dialogProps","renderDialog","value","hasExistingContext","fallbackReducer","dispatch","contextValue","handleDialogClose","dialog","_a","_jsx","isOpen","onClose","_jsxs","Provider","undefined"],"sources":["/Users/husseingalal/Desktop/Hackathon/Elrond/frontend/node_modules/@blueprintjs/core/src/context/hotkeys/hotkeysProvider.tsx"],"sourcesContent":["/*\n * Copyright 2021 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { createContext, useCallback, useMemo, useReducer } from \"react\";\n\nimport { shallowCompareKeys } from \"../../common/utils\";\nimport { HotkeysDialog, type HotkeysDialogProps } from \"../../components/hotkeys/hotkeysDialog\";\nimport type { HotkeyConfig } from \"../../hooks\";\n\ninterface HotkeysContextState {\n    /**\n     * Whether the context instance is being used within a tree which has a <HotkeysProvider>.\n     * It's technically ok if this is false, but not recommended, since that means any hotkeys\n     * bound with that context instance will not show up in the hotkeys help dialog.\n     */\n    hasProvider: boolean;\n\n    /** List of hotkeys accessible in the current scope, registered by currently mounted components, can be global or local. */\n    hotkeys: HotkeyConfig[];\n\n    /** Whether the global hotkeys dialog is open. */\n    isDialogOpen: boolean;\n}\n\ntype HotkeysAction =\n    | { type: \"ADD_HOTKEYS\" | \"REMOVE_HOTKEYS\"; payload: HotkeyConfig[] }\n    | { type: \"CLOSE_DIALOG\" | \"OPEN_DIALOG\" };\n\nexport type HotkeysContextInstance = readonly [HotkeysContextState, React.Dispatch<HotkeysAction>];\n\nconst initialHotkeysState: HotkeysContextState = { hasProvider: false, hotkeys: [], isDialogOpen: false };\nconst noOpDispatch: React.Dispatch<HotkeysAction> = () => null;\n\n/**\n * A React context used to register and deregister hotkeys as components are mounted and unmounted in an application.\n * Users should take care to make sure that only _one_ of these is instantiated and used within an application, especially\n * if using global hotkeys.\n *\n * You will likely not be using this HotkeysContext directly, except in cases where you need to get a direct handle on an\n * existing context instance for advanced use cases involving nested HotkeysProviders.\n *\n * For more information, see the [HotkeysProvider documentation](https://blueprintjs.com/docs/#core/context/hotkeys-provider).\n */\nexport const HotkeysContext = createContext<HotkeysContextInstance>([initialHotkeysState, noOpDispatch]);\n\nconst hotkeysReducer = (state: HotkeysContextState, action: HotkeysAction) => {\n    switch (action.type) {\n        case \"ADD_HOTKEYS\":\n            // only pick up unique hotkeys which haven't been registered already\n            const newUniqueHotkeys = [];\n            for (const a of action.payload) {\n                let isUnique = true;\n                for (const b of state.hotkeys) {\n                    isUnique &&= !shallowCompareKeys(a, b, { exclude: [\"onKeyDown\", \"onKeyUp\"] });\n                }\n                if (isUnique) {\n                    newUniqueHotkeys.push(a);\n                }\n            }\n            return {\n                ...state,\n                hotkeys: [...state.hotkeys, ...newUniqueHotkeys],\n            };\n        case \"REMOVE_HOTKEYS\":\n            return {\n                ...state,\n                hotkeys: state.hotkeys.filter(key => action.payload.indexOf(key) === -1),\n            };\n        case \"OPEN_DIALOG\":\n            return { ...state, isDialogOpen: true };\n        case \"CLOSE_DIALOG\":\n            return { ...state, isDialogOpen: false };\n        default:\n            return state;\n    }\n};\n\nexport interface HotkeysProviderProps {\n    /** Optional props to customize the rendered hotkeys dialog. */\n    dialogProps?: Partial<Omit<HotkeysDialogProps, \"hotkeys\">>;\n\n    /** If provided, this dialog render function will be used in place of the default implementation. */\n    renderDialog?: (state: HotkeysContextState, contextActions: { handleDialogClose: () => void }) => React.JSX.Element;\n\n    /** If provided, we will use this context instance instead of generating our own. */\n    value?: HotkeysContextInstance;\n}\n\n/**\n * Hotkeys context provider, necessary for the `useHotkeys` hook.\n *\n * @see https://blueprintjs.com/docs/#core/context/hotkeys-provider\n */\nexport const HotkeysProvider = ({\n    children,\n    dialogProps,\n    renderDialog,\n    value,\n}: React.PropsWithChildren<HotkeysProviderProps>) => {\n    const hasExistingContext = value != null;\n    const fallbackReducer = useReducer(hotkeysReducer, { ...initialHotkeysState, hasProvider: true });\n    const [state, dispatch] = value ?? fallbackReducer;\n    // The `useState` array isn't stable between renders -- so memo it outselves\n    const contextValue = useMemo(() => [state, dispatch] as const, [state, dispatch]);\n    const handleDialogClose = useCallback(() => dispatch({ type: \"CLOSE_DIALOG\" }), [dispatch]);\n\n    const dialog = renderDialog?.(state, { handleDialogClose }) ?? (\n        <HotkeysDialog\n            {...dialogProps}\n            isOpen={state.isDialogOpen}\n            hotkeys={state.hotkeys}\n            onClose={handleDialogClose}\n        />\n    );\n\n    // if we are working with an existing context, we don't need to generate our own dialog\n    return (\n        <HotkeysContext.Provider value={contextValue}>\n            {children}\n            {hasExistingContext ? undefined : dialog}\n        </HotkeysContext.Provider>\n    );\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}