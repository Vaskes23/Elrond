{"ast":null,"code":"/*\n * Copyright 2018 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Children, cloneElement, createRef } from \"react\";\nimport { AbstractPureComponent, DISPLAYNAME_PREFIX } from \"../../common\";\n/**\n * Resize sensor component.\n *\n * It requires a single DOM element child and will error otherwise.\n *\n * @see https://blueprintjs.com/docs/#core/components/resize-sensor\n **/\nexport class ResizeSensor extends AbstractPureComponent {\n  constructor() {\n    var _a;\n    super(...arguments);\n    this.targetRef = (_a = this.props.targetRef) !== null && _a !== void 0 ? _a : createRef();\n    this.prevElement = undefined;\n  }\n  render() {\n    const onlyChild = Children.only(this.props.children);\n    // If we're provided a mutable ref to the child element already, we must re-use that one. This is necessary\n    // in cases where the child node is not a native DOM element and does not use `forwardRef`, since\n    // there's no way for us to know how to attach to the underlying DOM node.\n    if (this.props.targetRef !== undefined) {\n      return onlyChild;\n    }\n    return cloneElement(onlyChild, {\n      ref: this.targetRef\n    });\n  }\n  componentDidMount() {\n    // ResizeObserver is available in all modern browsers supported by Blueprint but not in server-side rendering\n    // and some test environments like jsdom, so we to do a feature check here.\n    this.observer = globalThis.ResizeObserver != null ? new ResizeObserver(entries => {\n      var _a, _b;\n      return (_b = (_a = this.props).onResize) === null || _b === void 0 ? void 0 : _b.call(_a, entries);\n    }) : undefined;\n    this.observeElement();\n  }\n  componentDidUpdate(prevProps) {\n    this.observeElement(this.props.observeParents !== prevProps.observeParents);\n  }\n  componentWillUnmount() {\n    var _a;\n    (_a = this.observer) === null || _a === void 0 ? void 0 : _a.disconnect();\n    this.prevElement = undefined;\n  }\n  /**\n   * Observe the DOM element, if defined and different from the currently\n   * observed element. Pass `force` argument to skip element checks and always\n   * re-observe.\n   */\n  observeElement(force = false) {\n    if (this.observer === undefined) {\n      return;\n    }\n    if (!(this.targetRef.current instanceof Element)) {\n      // stop everything if not defined\n      this.observer.disconnect();\n      return;\n    }\n    if (this.targetRef.current === this.prevElement && !force) {\n      // quit if given same element -- nothing to update (unless forced)\n      return;\n    } else {\n      // clear observer list if new element\n      this.observer.disconnect();\n      // remember element reference for next time\n      this.prevElement = this.targetRef.current;\n    }\n    // observer callback is invoked immediately when observing new elements\n    this.observer.observe(this.targetRef.current);\n    if (this.props.observeParents) {\n      let parent = this.targetRef.current.parentElement;\n      while (parent != null) {\n        this.observer.observe(parent);\n        parent = parent.parentElement;\n      }\n    }\n  }\n}\nResizeSensor.displayName = `${DISPLAYNAME_PREFIX}.ResizeSensor`;","map":{"version":3,"names":["Children","cloneElement","createRef","AbstractPureComponent","DISPLAYNAME_PREFIX","ResizeSensor","constructor","targetRef","_a","props","prevElement","undefined","render","onlyChild","only","children","ref","componentDidMount","observer","globalThis","ResizeObserver","entries","_b","onResize","call","observeElement","componentDidUpdate","prevProps","observeParents","componentWillUnmount","disconnect","force","current","Element","observe","parent","parentElement","displayName"],"sources":["/Users/husseingalal/Desktop/Hackathon/Elrond/frontend/node_modules/@blueprintjs/core/src/components/resize-sensor/resizeSensor.tsx"],"sourcesContent":["/*\n * Copyright 2018 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Children, cloneElement, createRef } from \"react\";\n\nimport { AbstractPureComponent, DISPLAYNAME_PREFIX } from \"../../common\";\n\n// backwards-compatible with @blueprintjs/core v4.x\nexport type ResizeEntry = ResizeObserverEntry;\n\n/** `ResizeSensor` requires a single DOM element child and will error otherwise. */\nexport interface ResizeSensorProps {\n    /**\n     * Single child, must be an element and not a string or fragment.\n     */\n    children: React.JSX.Element;\n\n    /**\n     * Callback invoked when the wrapped element resizes.\n     *\n     * The `entries` array contains an entry for each observed element. In the\n     * default case (no `observeParents`), the array will contain only one\n     * element: the single child of the `ResizeSensor`.\n     *\n     * Note that this method is called _asynchronously_ after a resize is\n     * detected and typically it will be called no more than once per frame.\n     */\n    onResize: (entries: ResizeObserverEntry[]) => void;\n\n    /**\n     * If `true`, all parent DOM elements of the container will also be\n     * observed for size changes. The array of entries passed to `onResize`\n     * will now contain an entry for each parent element up to the root of the\n     * document.\n     *\n     * Only enable this prop if a parent element resizes in a way that does\n     * not also cause the child element to resize.\n     *\n     * @default false\n     */\n    observeParents?: boolean;\n\n    /**\n     * If you attach a `ref` to the child yourself when rendering it, you must pass the\n     * same value here (otherwise, ResizeSensor won't be able to attach its own).\n     */\n    targetRef?: React.RefObject<HTMLElement>;\n}\n\n/**\n * Resize sensor component.\n *\n * It requires a single DOM element child and will error otherwise.\n *\n * @see https://blueprintjs.com/docs/#core/components/resize-sensor\n **/\nexport class ResizeSensor extends AbstractPureComponent<ResizeSensorProps> {\n    public static displayName = `${DISPLAYNAME_PREFIX}.ResizeSensor`;\n\n    private targetRef = this.props.targetRef ?? createRef<HTMLElement>();\n\n    private prevElement: HTMLElement | undefined = undefined;\n\n    private observer: ResizeObserver | undefined;\n\n    public render(): React.ReactNode {\n        const onlyChild = Children.only(this.props.children);\n\n        // If we're provided a mutable ref to the child element already, we must re-use that one. This is necessary\n        // in cases where the child node is not a native DOM element and does not use `forwardRef`, since\n        // there's no way for us to know how to attach to the underlying DOM node.\n        if (this.props.targetRef !== undefined) {\n            return onlyChild;\n        }\n\n        return cloneElement(onlyChild, { ref: this.targetRef });\n    }\n\n    public componentDidMount() {\n        // ResizeObserver is available in all modern browsers supported by Blueprint but not in server-side rendering\n        // and some test environments like jsdom, so we to do a feature check here.\n        this.observer =\n            globalThis.ResizeObserver != null\n                ? new ResizeObserver(entries => this.props.onResize?.(entries))\n                : undefined;\n        this.observeElement();\n    }\n\n    public componentDidUpdate(prevProps: ResizeSensorProps) {\n        this.observeElement(this.props.observeParents !== prevProps.observeParents);\n    }\n\n    public componentWillUnmount() {\n        this.observer?.disconnect();\n        this.prevElement = undefined;\n    }\n\n    /**\n     * Observe the DOM element, if defined and different from the currently\n     * observed element. Pass `force` argument to skip element checks and always\n     * re-observe.\n     */\n    private observeElement(force = false) {\n        if (this.observer === undefined) {\n            return;\n        }\n\n        if (!(this.targetRef.current instanceof Element)) {\n            // stop everything if not defined\n            this.observer.disconnect();\n            return;\n        }\n\n        if (this.targetRef.current === this.prevElement && !force) {\n            // quit if given same element -- nothing to update (unless forced)\n            return;\n        } else {\n            // clear observer list if new element\n            this.observer.disconnect();\n            // remember element reference for next time\n            this.prevElement = this.targetRef.current;\n        }\n\n        // observer callback is invoked immediately when observing new elements\n        this.observer.observe(this.targetRef.current);\n\n        if (this.props.observeParents) {\n            let parent = this.targetRef.current.parentElement;\n            while (parent != null) {\n                this.observer.observe(parent);\n                parent = parent.parentElement;\n            }\n        }\n    }\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;AAgBA,SAASA,QAAQ,EAAEC,YAAY,EAAEC,SAAS,QAAQ,OAAO;AAEzD,SAASC,qBAAqB,EAAEC,kBAAkB,QAAQ,cAAc;AA4CxE;;;;;;;AAOA,OAAM,MAAOC,YAAa,SAAQF,qBAAwC;EAA1EG,YAAA;;;IAGY,KAAAC,SAAS,GAAG,CAAAC,EAAA,OAAI,CAACC,KAAK,CAACF,SAAS,cAAAC,EAAA,cAAAA,EAAA,GAAIN,SAAS,EAAe;IAE5D,KAAAQ,WAAW,GAA4BC,SAAS;EAyE5D;EArEWC,MAAMA,CAAA;IACT,MAAMC,SAAS,GAAGb,QAAQ,CAACc,IAAI,CAAC,IAAI,CAACL,KAAK,CAACM,QAAQ,CAAC;IAEpD;IACA;IACA;IACA,IAAI,IAAI,CAACN,KAAK,CAACF,SAAS,KAAKI,SAAS,EAAE;MACpC,OAAOE,SAAS;IACpB;IAEA,OAAOZ,YAAY,CAACY,SAAS,EAAE;MAAEG,GAAG,EAAE,IAAI,CAACT;IAAS,CAAE,CAAC;EAC3D;EAEOU,iBAAiBA,CAAA;IACpB;IACA;IACA,IAAI,CAACC,QAAQ,GACTC,UAAU,CAACC,cAAc,IAAI,IAAI,GAC3B,IAAIA,cAAc,CAACC,OAAO,IAAG;MAAA,IAAAb,EAAA,EAAAc,EAAA;MAAC,QAAAA,EAAA,IAAAd,EAAA,OAAI,CAACC,KAAK,EAACc,QAAQ,cAAAD,EAAA,uBAAAA,EAAA,CAAAE,IAAA,CAAAhB,EAAA,EAAGa,OAAO,CAAC;IAAA,EAAC,GAC7DV,SAAS;IACnB,IAAI,CAACc,cAAc,EAAE;EACzB;EAEOC,kBAAkBA,CAACC,SAA4B;IAClD,IAAI,CAACF,cAAc,CAAC,IAAI,CAAChB,KAAK,CAACmB,cAAc,KAAKD,SAAS,CAACC,cAAc,CAAC;EAC/E;EAEOC,oBAAoBA,CAAA;;IACvB,CAAArB,EAAA,OAAI,CAACU,QAAQ,cAAAV,EAAA,uBAAAA,EAAA,CAAEsB,UAAU,EAAE;IAC3B,IAAI,CAACpB,WAAW,GAAGC,SAAS;EAChC;EAEA;;;;;EAKQc,cAAcA,CAACM,KAAK,GAAG,KAAK;IAChC,IAAI,IAAI,CAACb,QAAQ,KAAKP,SAAS,EAAE;MAC7B;IACJ;IAEA,IAAI,EAAE,IAAI,CAACJ,SAAS,CAACyB,OAAO,YAAYC,OAAO,CAAC,EAAE;MAC9C;MACA,IAAI,CAACf,QAAQ,CAACY,UAAU,EAAE;MAC1B;IACJ;IAEA,IAAI,IAAI,CAACvB,SAAS,CAACyB,OAAO,KAAK,IAAI,CAACtB,WAAW,IAAI,CAACqB,KAAK,EAAE;MACvD;MACA;IACJ,CAAC,MAAM;MACH;MACA,IAAI,CAACb,QAAQ,CAACY,UAAU,EAAE;MAC1B;MACA,IAAI,CAACpB,WAAW,GAAG,IAAI,CAACH,SAAS,CAACyB,OAAO;IAC7C;IAEA;IACA,IAAI,CAACd,QAAQ,CAACgB,OAAO,CAAC,IAAI,CAAC3B,SAAS,CAACyB,OAAO,CAAC;IAE7C,IAAI,IAAI,CAACvB,KAAK,CAACmB,cAAc,EAAE;MAC3B,IAAIO,MAAM,GAAG,IAAI,CAAC5B,SAAS,CAACyB,OAAO,CAACI,aAAa;MACjD,OAAOD,MAAM,IAAI,IAAI,EAAE;QACnB,IAAI,CAACjB,QAAQ,CAACgB,OAAO,CAACC,MAAM,CAAC;QAC7BA,MAAM,GAAGA,MAAM,CAACC,aAAa;MACjC;IACJ;EACJ;;AA5Ec/B,YAAA,CAAAgC,WAAW,GAAG,GAAGjC,kBAAkB,eAAe","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}