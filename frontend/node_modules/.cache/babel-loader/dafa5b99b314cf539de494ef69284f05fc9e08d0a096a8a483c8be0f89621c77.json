{"ast":null,"code":"import { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport classNames from \"classnames\";\nimport { Children, cloneElement, createElement, createRef } from \"react\";\nimport { Manager, Popper, Reference } from \"react-popper\";\nimport { AbstractPureComponent, Classes, DISPLAYNAME_PREFIX, mergeRefs, refHandler, Utils } from \"../../common\";\nimport * as Errors from \"../../common/errors\";\nimport { Overlay2 } from \"../overlay2/overlay2\";\nimport { ResizeSensor } from \"../resize-sensor/resizeSensor\";\n// eslint-disable-next-line import/no-cycle\nimport { Tooltip } from \"../tooltip/tooltip\";\nimport { matchReferenceWidthModifier } from \"./customModifiers\";\nimport { POPOVER_ARROW_SVG_SIZE, PopoverArrow } from \"./popoverArrow\";\nimport { positionToPlacement } from \"./popoverPlacementUtils\";\nimport { getBasePlacement, getTransformOrigin } from \"./popperUtils\";\nexport const PopoverInteractionKind = {\n  CLICK: \"click\",\n  CLICK_TARGET_ONLY: \"click-target\",\n  HOVER: \"hover\",\n  HOVER_TARGET_ONLY: \"hover-target\"\n};\n/**\n * Popover component, used to display a floating UI next to and tethered to a target element.\n *\n * @template T target element props interface. Consumers wishing to stay in sync with Blueprint's default target HTML\n * props interface should use the `DefaultPopoverTargetHTMLProps` type (although this is already the default type for\n * this type param).\n * @see https://blueprintjs.com/docs/#core/components/popover\n */\nexport class Popover extends AbstractPureComponent {\n  constructor() {\n    super(...arguments);\n    this.state = {\n      hasDarkParent: false,\n      isClosingViaEscapeKeypress: false,\n      isOpen: this.getIsOpen(this.props)\n    };\n    /**\n     * DOM element that contains the popover.\n     * When `usePortal={true}`, this element will be portaled outside the usual DOM flow,\n     * so this reference can be very useful for testing.\n     *\n     * @public for testing\n     */\n    this.popoverElement = null;\n    /** Popover ref handler */\n    this.popoverRef = refHandler(this, \"popoverElement\", this.props.popoverRef);\n    /**\n     * Target DOM element ref.\n     *\n     * N.B. this must be a ref object since we pass it to `<ResizeSensor>`, which needs to know about the target\n     * DOM element in order to observe its dimensions.\n     *\n     * @public for testing\n     */\n    this.targetRef = createRef();\n    /**\n     * Overlay2 transition container element ref.\n     */\n    this.transitionContainerElement = createRef();\n    // a flag that lets us detect mouse movement between the target and popover,\n    // now that mouseleave is triggered when you cross the gap between the two.\n    this.isMouseInTargetOrPopover = false;\n    // a flag that indicates whether the target previously lost focus to another\n    // element on the same page.\n    this.lostFocusOnSamePage = true;\n    this.isControlled = () => this.props.isOpen !== undefined;\n    // arrow is disabled if minimal, or if the arrow modifier was explicitly disabled\n    this.isArrowEnabled = () => {\n      var _a, _b;\n      return !this.props.minimal && ((_b = (_a = this.props.modifiers) === null || _a === void 0 ? void 0 : _a.arrow) === null || _b === void 0 ? void 0 : _b.enabled) !== false;\n    };\n    this.isHoverInteractionKind = () => {\n      return this.props.interactionKind === PopoverInteractionKind.HOVER || this.props.interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY;\n    };\n    /**\n     * Instance method to instruct the `Popover` to recompute its position.\n     *\n     * This method should only be used if you are updating the target in a way\n     * that does not cause it to re-render, such as changing its _position_\n     * without changing its _size_ (since `Popover` already repositions when it\n     * detects a resize).\n     */\n    this.reposition = () => {\n      var _a;\n      return (_a = this.popperScheduleUpdate) === null || _a === void 0 ? void 0 : _a.call(this);\n    };\n    this.renderTarget = ({\n      ref: popperChildRef\n    }) => {\n      var _a, _b;\n      const {\n        children,\n        className,\n        disabled,\n        fill,\n        openOnTargetFocus,\n        renderTarget\n      } = this.props;\n      const {\n        isOpen\n      } = this.state;\n      const isControlled = this.isControlled();\n      const isHoverInteractionKind = this.isHoverInteractionKind();\n      let {\n        targetTagName\n      } = this.props;\n      if (fill) {\n        targetTagName = \"div\";\n      }\n      // N.B. react-popper has a wide type for this ref, but we can narrow it based on the source,\n      // see https://github.com/floating-ui/react-popper/blob/beac280d61082852c4efc302be902911ce2d424c/src/Reference.js#L17\n      const ref = mergeRefs(popperChildRef, this.targetRef);\n      const targetEventHandlers = isHoverInteractionKind ? {\n        // HOVER handlers\n        onBlur: this.handleTargetBlur,\n        onContextMenu: this.handleTargetContextMenu,\n        onFocus: this.handleTargetFocus,\n        onMouseEnter: this.handleMouseEnter,\n        onMouseLeave: this.handleMouseLeave\n      } : {\n        // CLICK needs only one handler\n        onClick: this.handleTargetClick,\n        // For keyboard accessibility, trigger the same behavior as a click event upon pressing ENTER/SPACE\n        onKeyDown: this.handleKeyDown\n      };\n      // Ensure target is focusable if relevant prop enabled\n      const targetTabIndex = !this.getIsContentEmpty() && !disabled && openOnTargetFocus && isHoverInteractionKind ? 0 : undefined;\n      const ownTargetProps = {\n        // N.B. this.props.className is passed along to renderTarget even though the user would have access to it.\n        // If, instead, renderTarget is undefined and the target is provided as a child, this.props.className is\n        // applied to the generated target wrapper element.\n        className: classNames(className, Classes.POPOVER_TARGET, {\n          [Classes.POPOVER_OPEN]: isOpen,\n          // this class is mainly useful for button targets\n          [Classes.ACTIVE]: isOpen && !isControlled && !isHoverInteractionKind\n        }),\n        ref,\n        ...targetEventHandlers\n      };\n      const childTargetProps = {\n        \"aria-expanded\": isHoverInteractionKind ? undefined : isOpen,\n        \"aria-haspopup\": this.props.interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY ? undefined : (_a = this.props.popupKind) !== null && _a !== void 0 ? _a : \"menu\"\n      };\n      const targetModifierClasses = {\n        // this class is mainly useful for Blueprint <Button> targets; we should only apply it for\n        // uncontrolled popovers when they are opened by a user interaction\n        [Classes.ACTIVE]: isOpen && !isControlled && !isHoverInteractionKind,\n        // similarly, this class is mainly useful for targets like <Button>, <InputGroup>, etc.\n        [Classes.FILL]: fill\n      };\n      let target;\n      if (renderTarget !== undefined) {\n        target = renderTarget({\n          ...ownTargetProps,\n          ...childTargetProps,\n          className: classNames(ownTargetProps.className, targetModifierClasses),\n          // if the consumer renders a tooltip target, it's their responsibility to disable that tooltip\n          // when *this* popover is open\n          isOpen,\n          tabIndex: targetTabIndex\n        });\n      } else {\n        const childTarget = Utils.ensureElement(Children.toArray(children)[0]);\n        if (childTarget === undefined) {\n          return null;\n        }\n        const clonedTarget = cloneElement(childTarget, {\n          ...childTargetProps,\n          className: classNames(childTarget.props.className, targetModifierClasses),\n          // force disable single Tooltip child when popover is open\n          disabled: isOpen && Utils.isElementOfType(childTarget, Tooltip) ? true : childTarget.props.disabled,\n          tabIndex: (_b = childTarget.props.tabIndex) !== null && _b !== void 0 ? _b : targetTabIndex\n        });\n        const wrappedTarget = createElement(targetTagName, {\n          ...ownTargetProps,\n          ...this.props.targetProps\n        }, clonedTarget);\n        target = wrappedTarget;\n      }\n      // No need to use the merged `ref` here, that only needs to be forwarded to the child node so that React can\n      // notify both popper.js and our components about the mounted DOM element.\n      return _jsx(ResizeSensor, {\n        targetRef: this.targetRef,\n        onResize: this.reposition,\n        children: target\n      });\n    };\n    this.renderPopover = popperProps => {\n      const {\n        autoFocus,\n        enforceFocus,\n        backdropProps,\n        canEscapeKeyClose,\n        hasBackdrop,\n        interactionKind,\n        usePortal\n      } = this.props;\n      const {\n        isClosingViaEscapeKeypress,\n        isOpen\n      } = this.state;\n      // compute an appropriate transform origin so the scale animation points towards target\n      const transformOrigin = getTransformOrigin(popperProps.placement, this.isArrowEnabled() ? popperProps.arrowProps.style : undefined);\n      // need to update our reference to this function on every render as it will change.\n      this.popperScheduleUpdate = popperProps.update;\n      const popoverHandlers = {\n        // always check popover clicks for dismiss class\n        onClick: this.handlePopoverClick,\n        // treat ENTER/SPACE keys the same as a click for accessibility\n        onKeyDown: event => Utils.isKeyboardClick(event) && this.handlePopoverClick(event)\n      };\n      if (interactionKind === PopoverInteractionKind.HOVER || !usePortal && interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY) {\n        popoverHandlers.onMouseEnter = this.handleMouseEnter;\n        popoverHandlers.onMouseLeave = this.handleMouseLeave;\n      }\n      const basePlacement = getBasePlacement(popperProps.placement);\n      const popoverClasses = classNames(Classes.POPOVER, {\n        [Classes.DARK]: this.props.inheritDarkTheme && this.state.hasDarkParent,\n        [Classes.MINIMAL]: this.props.minimal,\n        [Classes.POPOVER_CAPTURING_DISMISS]: this.props.captureDismiss,\n        [Classes.POPOVER_MATCH_TARGET_WIDTH]: this.props.matchTargetWidth,\n        [Classes.POPOVER_REFERENCE_HIDDEN]: popperProps.isReferenceHidden === true,\n        [Classes.POPOVER_POPPER_ESCAPED]: popperProps.hasPopperEscaped === true\n      }, `${Classes.POPOVER_CONTENT_PLACEMENT}-${basePlacement}`, this.props.popoverClassName);\n      const defaultAutoFocus = this.isHoverInteractionKind() ? false : undefined;\n      // if hover interaction, it doesn't make sense to take over focus control\n      const shouldReturnFocusOnClose = this.isHoverInteractionKind() ? false : isClosingViaEscapeKeypress ? true : this.props.shouldReturnFocusOnClose;\n      return _jsx(Overlay2, {\n        autoFocus: autoFocus !== null && autoFocus !== void 0 ? autoFocus : defaultAutoFocus,\n        backdropClassName: Classes.POPOVER_BACKDROP,\n        backdropProps: backdropProps,\n        canEscapeKeyClose: canEscapeKeyClose,\n        canOutsideClickClose: interactionKind === PopoverInteractionKind.CLICK,\n        childRef: this.transitionContainerElement,\n        enforceFocus: enforceFocus,\n        hasBackdrop: hasBackdrop,\n        isOpen: isOpen,\n        lazy: this.props.lazy,\n        onClose: this.handleOverlayClose,\n        onClosed: this.props.onClosed,\n        onClosing: this.props.onClosing,\n        onOpened: this.props.onOpened,\n        onOpening: this.props.onOpening,\n        transitionDuration: this.props.transitionDuration,\n        transitionName: Classes.POPOVER,\n        usePortal: usePortal,\n        portalClassName: this.props.portalClassName,\n        portalContainer: this.props.portalContainer,\n        // eslint-disable-next-line @typescript-eslint/no-deprecated\n        portalStopPropagationEvents: this.props.portalStopPropagationEvents,\n        shouldReturnFocusOnClose: shouldReturnFocusOnClose,\n        children: _jsx(\"div\", {\n          className: Classes.POPOVER_TRANSITION_CONTAINER,\n          // We need to attach a ref that notifies both react-popper and our Popover component about the DOM\n          // element inside the Overlay2. We cannot re-use `PopperChildrenProps.ref` because Overlay2 only\n          // accepts a ref object (not a callback) due to a CSSTransition API limitation.\n          // N.B. react-popper has a wide type for this ref, but we can narrow it based on the source,\n          // see https://github.com/floating-ui/react-popper/blob/beac280d61082852c4efc302be902911ce2d424c/src/Popper.js#L94\n          ref: mergeRefs(popperProps.ref, this.transitionContainerElement),\n          style: popperProps.style,\n          children: _jsx(ResizeSensor, {\n            onResize: this.reposition,\n            children: _jsxs(\"div\", {\n              className: popoverClasses,\n              style: {\n                transformOrigin\n              },\n              ref: this.popoverRef,\n              ...popoverHandlers,\n              children: [this.isArrowEnabled() && _jsx(PopoverArrow, {\n                arrowProps: popperProps.arrowProps,\n                placement: popperProps.placement\n              }), _jsx(\"div\", {\n                className: Classes.POPOVER_CONTENT,\n                children: this.props.content\n              })]\n            })\n          })\n        })\n      });\n    };\n    this.handleTargetFocus = e => {\n      if (this.props.openOnTargetFocus && this.isHoverInteractionKind()) {\n        if (e.relatedTarget == null && !this.lostFocusOnSamePage) {\n          // ignore this focus event -- the target was already focused but the page itself\n          // lost focus (e.g. due to switching tabs).\n          return;\n        }\n        this.handleMouseEnter(e);\n      }\n    };\n    this.handleTargetBlur = e => {\n      if (this.props.openOnTargetFocus && this.isHoverInteractionKind()) {\n        if (e.relatedTarget != null) {\n          // if the next element to receive focus is within the popover, we'll want to leave the\n          // popover open.\n          if (e.relatedTarget !== this.popoverElement && !this.isElementInPopover(e.relatedTarget)) {\n            this.handleMouseLeave(e);\n          }\n        } else {\n          this.handleMouseLeave(e);\n        }\n      }\n      this.lostFocusOnSamePage = e.relatedTarget != null;\n    };\n    this.handleTargetContextMenu = e => {\n      // we assume that when someone prevents the default interaction on this event (a browser native context menu),\n      // they are showing a custom context menu (as ContextMenu2 does); in this case, we should close this popover/tooltip\n      if (e.defaultPrevented) {\n        this.setOpenState(false, e);\n      }\n    };\n    this.handleMouseEnter = e => {\n      this.isMouseInTargetOrPopover = true;\n      // if we're entering the popover, and the mode is set to be HOVER_TARGET_ONLY, we want to manually\n      // trigger the mouse leave event, as hovering over the popover shouldn't count.\n      if (!this.props.usePortal && this.isElementInPopover(e.target) && this.props.interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY && !this.props.openOnTargetFocus) {\n        this.handleMouseLeave(e);\n      } else if (!this.props.disabled) {\n        // only begin opening popover when it is enabled\n        this.setOpenState(true, e, this.props.hoverOpenDelay);\n      }\n    };\n    this.handleMouseLeave = e => {\n      this.isMouseInTargetOrPopover = false;\n      // Wait until the event queue is flushed, because we want to leave the\n      // popover open if the mouse entered the popover immediately after\n      // leaving the target (or vice versa). Make sure to persist the event since\n      // we need to access `nativeEvent` in `this.setOpenState()`.\n      e.persist();\n      this.setTimeout(() => {\n        if (this.isMouseInTargetOrPopover) {\n          return;\n        }\n        // user-configurable closing delay is helpful when moving mouse from target to popover\n        this.setOpenState(false, e, this.props.hoverCloseDelay);\n      });\n    };\n    this.handlePopoverClick = e => {\n      var _a, _b, _c;\n      const eventTarget = e.target;\n      const eventPopover = eventTarget.closest(`.${Classes.POPOVER}`);\n      const eventPopoverV1 = eventTarget.closest(`.${Classes.POPOVER}`);\n      const isEventFromSelf = (eventPopover !== null && eventPopover !== void 0 ? eventPopover : eventPopoverV1) === this.getPopoverElement();\n      const isEventPopoverCapturing = (_b = (_a = eventPopover === null || eventPopover === void 0 ? void 0 : eventPopover.classList.contains(Classes.POPOVER_CAPTURING_DISMISS)) !== null && _a !== void 0 ? _a : eventPopoverV1 === null || eventPopoverV1 === void 0 ? void 0 : eventPopoverV1.classList.contains(Classes.POPOVER_CAPTURING_DISMISS)) !== null && _b !== void 0 ? _b : false;\n      // an OVERRIDE inside a DISMISS does not dismiss, and a DISMISS inside an OVERRIDE will dismiss.\n      const dismissElement = eventTarget.closest(`.${Classes.POPOVER_DISMISS}, .${Classes.POPOVER_DISMISS_OVERRIDE}`);\n      const shouldDismiss = (_c = dismissElement === null || dismissElement === void 0 ? void 0 : dismissElement.classList.contains(Classes.POPOVER_DISMISS)) !== null && _c !== void 0 ? _c : false;\n      const isDisabled = eventTarget.closest(`:disabled, .${Classes.DISABLED}`) != null;\n      if (shouldDismiss && !isDisabled && (!isEventPopoverCapturing || isEventFromSelf)) {\n        this.setOpenState(false, e);\n      }\n    };\n    this.handleOverlayClose = e => {\n      var _a;\n      if (this.targetRef.current == null || e === undefined) {\n        return;\n      }\n      const event = (_a = e.nativeEvent) !== null && _a !== void 0 ? _a : e;\n      const eventTarget = event.composed ? event.composedPath()[0] : event.target;\n      // if click was in target, target event listener will handle things, so don't close\n      if (!Utils.elementIsOrContains(this.targetRef.current, eventTarget) || e.nativeEvent instanceof KeyboardEvent) {\n        this.setOpenState(false, e);\n      }\n    };\n    this.handleKeyDown = e => {\n      const isKeyboardClick = Utils.isKeyboardClick(e);\n      // For keyboard accessibility, trigger the same behavior as a click event upon pressing ENTER/SPACE\n      if (isKeyboardClick) {\n        this.handleTargetClick(e);\n      }\n    };\n    this.handleTargetClick = e => {\n      // Target element(s) may fire simulated click event upon pressing ENTER/SPACE, which we should ignore\n      // see: https://github.com/palantir/blueprint/issues/5775\n      const shouldIgnoreClick = this.state.isOpen && this.isSimulatedButtonClick(e);\n      if (!shouldIgnoreClick) {\n        // ensure click did not originate from within inline popover before closing\n        if (!this.props.disabled && !this.isElementInPopover(e.target)) {\n          if (this.props.isOpen == null) {\n            this.setState(prevState => ({\n              isOpen: !prevState.isOpen\n            }));\n          } else {\n            this.setOpenState(!this.props.isOpen, e);\n          }\n        }\n      }\n    };\n    this.isSimulatedButtonClick = e => {\n      return !e.isTrusted && e.target.matches(`.${Classes.BUTTON}`);\n    };\n  }\n  // popper innerRef gives us a handle on the transition container, since that's what we render as the overlay child,\n  // so if we want to look at our actual popover element, we need to reach inside a bit\n  getPopoverElement() {\n    var _a;\n    return (_a = this.popoverElement) === null || _a === void 0 ? void 0 : _a.querySelector(`.${Classes.POPOVER}`);\n  }\n  getIsOpen(props) {\n    var _a;\n    // disabled popovers should never be allowed to open.\n    if (props.disabled) {\n      return false;\n    } else {\n      return (_a = props.isOpen) !== null && _a !== void 0 ? _a : props.defaultIsOpen;\n    }\n  }\n  render() {\n    const {\n      disabled,\n      placement,\n      position = \"auto\",\n      positioningStrategy\n    } = this.props;\n    const {\n      isOpen\n    } = this.state;\n    if (this.getIsContentEmpty()) {\n      // need to do this check in render(), because `isOpen` is derived from\n      // state, and state can't necessarily be accessed in validateProps.\n      if (!disabled && isOpen !== false && !Utils.isNodeEnv(\"production\")) {\n        console.warn(Errors.POPOVER_WARN_EMPTY_CONTENT);\n      }\n      // just render the target without a content overlay if there is no content to display\n      return this.renderTarget({\n        ref: noop\n      });\n    }\n    // Important: do not use <Reference innerRef> since it has a bug when used in React 18 strict mode\n    // see https://github.com/floating-ui/react-popper/pull/459\n    return _jsxs(Manager, {\n      children: [_jsx(Reference, {\n        children: this.renderTarget\n      }), _jsx(Popper, {\n        innerRef: this.popoverRef,\n        placement: placement !== null && placement !== void 0 ? placement : positionToPlacement(position),\n        strategy: positioningStrategy,\n        modifiers: this.getPopperModifiers(),\n        children: this.renderPopover\n      })]\n    });\n  }\n  componentDidMount() {\n    this.updateDarkParent();\n  }\n  componentDidUpdate(props, state) {\n    super.componentDidUpdate(props, state);\n    this.updateDarkParent();\n    const nextIsOpen = this.getIsOpen(this.props);\n    if (this.props.isOpen != null && nextIsOpen !== this.state.isOpen) {\n      this.setOpenState(nextIsOpen);\n      // tricky: setOpenState calls setState only if this.props.isOpen is\n      // not controlled, so we need to invoke setState manually here.\n      this.setState({\n        isOpen: nextIsOpen\n      });\n    } else if (this.props.disabled && this.state.isOpen && this.props.isOpen == null) {\n      // special case: close an uncontrolled popover when disabled is set to true\n      this.setOpenState(false);\n    }\n  }\n  validateProps(props) {\n    if (props.isOpen == null && props.onInteraction != null) {\n      console.warn(Errors.POPOVER_WARN_UNCONTROLLED_ONINTERACTION);\n    }\n    if (props.hasBackdrop && !props.usePortal) {\n      console.warn(Errors.POPOVER_WARN_HAS_BACKDROP_INLINE);\n    }\n    if (props.hasBackdrop && props.interactionKind !== PopoverInteractionKind.CLICK) {\n      console.warn(Errors.POPOVER_HAS_BACKDROP_INTERACTION);\n    }\n    if (props.placement !== undefined && props.position !== undefined) {\n      console.warn(Errors.POPOVER_WARN_PLACEMENT_AND_POSITION_MUTEX);\n    }\n    const childrenCount = Children.count(props.children);\n    const hasRenderTargetProp = props.renderTarget !== undefined;\n    const hasTargetPropsProp = props.targetProps !== undefined;\n    if (childrenCount === 0 && !hasRenderTargetProp) {\n      console.warn(Errors.POPOVER_REQUIRES_TARGET);\n    }\n    if (childrenCount > 1) {\n      console.warn(Errors.POPOVER_WARN_TOO_MANY_CHILDREN);\n    }\n    if (childrenCount > 0 && hasRenderTargetProp) {\n      console.warn(Errors.POPOVER_WARN_DOUBLE_TARGET);\n    }\n    if (hasRenderTargetProp && hasTargetPropsProp) {\n      console.warn(Errors.POPOVER_WARN_TARGET_PROPS_WITH_RENDER_TARGET);\n    }\n  }\n  getPopperModifiers() {\n    var _a, _b, _c, _d;\n    const {\n      matchTargetWidth,\n      modifiers,\n      modifiersCustom\n    } = this.props;\n    const popperModifiers = [{\n      enabled: this.isArrowEnabled(),\n      name: \"arrow\",\n      ...(modifiers === null || modifiers === void 0 ? void 0 : modifiers.arrow)\n    }, {\n      name: \"computeStyles\",\n      ...(modifiers === null || modifiers === void 0 ? void 0 : modifiers.computeStyles),\n      options: {\n        adaptive: true,\n        // We disable the built-in gpuAcceleration so that\n        // Popper.js will return us easy to interpolate values\n        // (top, left instead of transform: translate3d)\n        // We'll then use these values to generate the needed\n        // css transform values blended with the react-spring values\n        gpuAcceleration: false,\n        ...((_a = modifiers === null || modifiers === void 0 ? void 0 : modifiers.computeStyles) === null || _a === void 0 ? void 0 : _a.options)\n      }\n    }, {\n      enabled: this.isArrowEnabled(),\n      name: \"offset\",\n      ...(modifiers === null || modifiers === void 0 ? void 0 : modifiers.offset),\n      options: {\n        offset: [0, POPOVER_ARROW_SVG_SIZE / 2],\n        ...((_b = modifiers === null || modifiers === void 0 ? void 0 : modifiers.offset) === null || _b === void 0 ? void 0 : _b.options)\n      }\n    }, {\n      name: \"flip\",\n      ...(modifiers === null || modifiers === void 0 ? void 0 : modifiers.flip),\n      options: {\n        boundary: this.props.boundary,\n        rootBoundary: this.props.rootBoundary,\n        ...((_c = modifiers === null || modifiers === void 0 ? void 0 : modifiers.flip) === null || _c === void 0 ? void 0 : _c.options)\n      }\n    }, {\n      name: \"preventOverflow\",\n      ...(modifiers === null || modifiers === void 0 ? void 0 : modifiers.preventOverflow),\n      options: {\n        boundary: this.props.boundary,\n        rootBoundary: this.props.rootBoundary,\n        ...((_d = modifiers === null || modifiers === void 0 ? void 0 : modifiers.preventOverflow) === null || _d === void 0 ? void 0 : _d.options)\n      }\n    }];\n    if (matchTargetWidth) {\n      popperModifiers.push(matchReferenceWidthModifier);\n    }\n    if (modifiersCustom !== undefined) {\n      popperModifiers.push(...modifiersCustom);\n    }\n    return popperModifiers;\n  }\n  // a wrapper around setState({ isOpen }) that will call props.onInteraction instead when in controlled mode.\n  // starts a timeout to delay changing the state if a non-zero duration is provided.\n  setOpenState(isOpen, e, timeout) {\n    var _a, _b, _c, _d, _e;\n    // cancel any existing timeout because we have new state\n    (_a = this.cancelOpenTimeout) === null || _a === void 0 ? void 0 : _a.call(this);\n    if (timeout !== undefined && timeout > 0) {\n      // Persist the react event since it will be used in a later macrotask.\n      e === null || e === void 0 ? void 0 : e.persist();\n      this.cancelOpenTimeout = this.setTimeout(() => {\n        this.setOpenState(isOpen, e);\n      }, timeout);\n    } else {\n      if (this.props.isOpen == null) {\n        this.setState({\n          isOpen\n        });\n      } else {\n        (_c = (_b = this.props).onInteraction) === null || _c === void 0 ? void 0 : _c.call(_b, isOpen, e);\n      }\n      if (!isOpen) {\n        // non-null assertion because the only time `e` is undefined is when in controlled mode\n        // or the rare special case in uncontrolled mode when the `disabled` flag is toggled true\n        (_e = (_d = this.props).onClose) === null || _e === void 0 ? void 0 : _e.call(_d, e);\n        this.setState({\n          isClosingViaEscapeKeypress: isEscapeKeypressEvent(e === null || e === void 0 ? void 0 : e.nativeEvent)\n        });\n      }\n    }\n  }\n  updateDarkParent() {\n    var _a;\n    if (this.props.usePortal && this.state.isOpen) {\n      const hasDarkParent = ((_a = this.targetRef.current) === null || _a === void 0 ? void 0 : _a.closest(`.${Classes.DARK}`)) != null;\n      this.setState({\n        hasDarkParent\n      });\n    }\n  }\n  isElementInPopover(element) {\n    var _a, _b;\n    return (_b = (_a = this.getPopoverElement()) === null || _a === void 0 ? void 0 : _a.contains(element)) !== null && _b !== void 0 ? _b : false;\n  }\n  getIsContentEmpty() {\n    const {\n      content\n    } = this.props;\n    return content == null || Utils.isEmptyString(content);\n  }\n}\nPopover.displayName = `${DISPLAYNAME_PREFIX}.Popover`;\nPopover.defaultProps = {\n  boundary: \"clippingParents\",\n  captureDismiss: false,\n  defaultIsOpen: false,\n  disabled: false,\n  fill: false,\n  hasBackdrop: false,\n  hoverCloseDelay: 300,\n  hoverOpenDelay: 150,\n  inheritDarkTheme: true,\n  interactionKind: PopoverInteractionKind.CLICK,\n  matchTargetWidth: false,\n  minimal: false,\n  openOnTargetFocus: true,\n  // N.B. we don't set a default for `placement` or `position` here because that would trigger\n  // a warning in validateProps if the other prop is specified by a user of this component\n  positioningStrategy: \"absolute\",\n  renderTarget: undefined,\n  shouldReturnFocusOnClose: false,\n  targetTagName: \"span\",\n  transitionDuration: 300,\n  usePortal: true\n};\nfunction isEscapeKeypressEvent(e) {\n  return e instanceof KeyboardEvent && e.key === \"Escape\";\n}\nfunction noop() {\n  // no-op\n}","map":{"version":3,"names":["classNames","Children","cloneElement","createElement","createRef","Manager","Popper","Reference","AbstractPureComponent","Classes","DISPLAYNAME_PREFIX","mergeRefs","refHandler","Utils","Errors","Overlay2","ResizeSensor","Tooltip","matchReferenceWidthModifier","POPOVER_ARROW_SVG_SIZE","PopoverArrow","positionToPlacement","getBasePlacement","getTransformOrigin","PopoverInteractionKind","CLICK","CLICK_TARGET_ONLY","HOVER","HOVER_TARGET_ONLY","Popover","constructor","state","hasDarkParent","isClosingViaEscapeKeypress","isOpen","getIsOpen","props","popoverElement","popoverRef","targetRef","transitionContainerElement","isMouseInTargetOrPopover","lostFocusOnSamePage","isControlled","undefined","isArrowEnabled","_a","_b","minimal","modifiers","arrow","enabled","isHoverInteractionKind","interactionKind","reposition","popperScheduleUpdate","call","renderTarget","ref","popperChildRef","children","className","disabled","fill","openOnTargetFocus","targetTagName","targetEventHandlers","onBlur","handleTargetBlur","onContextMenu","handleTargetContextMenu","onFocus","handleTargetFocus","onMouseEnter","handleMouseEnter","onMouseLeave","handleMouseLeave","onClick","handleTargetClick","onKeyDown","handleKeyDown","targetTabIndex","getIsContentEmpty","ownTargetProps","POPOVER_TARGET","POPOVER_OPEN","ACTIVE","childTargetProps","popupKind","targetModifierClasses","FILL","target","tabIndex","childTarget","ensureElement","toArray","clonedTarget","isElementOfType","wrappedTarget","targetProps","_jsx","onResize","renderPopover","popperProps","autoFocus","enforceFocus","backdropProps","canEscapeKeyClose","hasBackdrop","usePortal","transformOrigin","placement","arrowProps","style","update","popoverHandlers","handlePopoverClick","event","isKeyboardClick","basePlacement","popoverClasses","POPOVER","DARK","inheritDarkTheme","MINIMAL","POPOVER_CAPTURING_DISMISS","captureDismiss","POPOVER_MATCH_TARGET_WIDTH","matchTargetWidth","POPOVER_REFERENCE_HIDDEN","isReferenceHidden","POPOVER_POPPER_ESCAPED","hasPopperEscaped","POPOVER_CONTENT_PLACEMENT","popoverClassName","defaultAutoFocus","shouldReturnFocusOnClose","backdropClassName","POPOVER_BACKDROP","canOutsideClickClose","childRef","lazy","onClose","handleOverlayClose","onClosed","onClosing","onOpened","onOpening","transitionDuration","transitionName","portalClassName","portalContainer","portalStopPropagationEvents","POPOVER_TRANSITION_CONTAINER","_jsxs","POPOVER_CONTENT","content","e","relatedTarget","isElementInPopover","defaultPrevented","setOpenState","hoverOpenDelay","persist","setTimeout","hoverCloseDelay","eventTarget","eventPopover","closest","eventPopoverV1","isEventFromSelf","getPopoverElement","isEventPopoverCapturing","classList","contains","dismissElement","POPOVER_DISMISS","POPOVER_DISMISS_OVERRIDE","shouldDismiss","_c","isDisabled","DISABLED","current","nativeEvent","composed","composedPath","elementIsOrContains","KeyboardEvent","shouldIgnoreClick","isSimulatedButtonClick","setState","prevState","isTrusted","matches","BUTTON","querySelector","defaultIsOpen","render","position","positioningStrategy","isNodeEnv","console","warn","POPOVER_WARN_EMPTY_CONTENT","noop","innerRef","strategy","getPopperModifiers","componentDidMount","updateDarkParent","componentDidUpdate","nextIsOpen","validateProps","onInteraction","POPOVER_WARN_UNCONTROLLED_ONINTERACTION","POPOVER_WARN_HAS_BACKDROP_INLINE","POPOVER_HAS_BACKDROP_INTERACTION","POPOVER_WARN_PLACEMENT_AND_POSITION_MUTEX","childrenCount","count","hasRenderTargetProp","hasTargetPropsProp","POPOVER_REQUIRES_TARGET","POPOVER_WARN_TOO_MANY_CHILDREN","POPOVER_WARN_DOUBLE_TARGET","POPOVER_WARN_TARGET_PROPS_WITH_RENDER_TARGET","modifiersCustom","popperModifiers","name","computeStyles","options","adaptive","gpuAcceleration","offset","flip","boundary","rootBoundary","preventOverflow","_d","push","timeout","cancelOpenTimeout","_e","isEscapeKeypressEvent","element","isEmptyString","displayName","defaultProps","key"],"sources":["/Users/husseingalal/Desktop/Hackathon/Elrond/frontend/node_modules/@blueprintjs/core/src/components/popover/popover.tsx"],"sourcesContent":["/*\n * Copyright 2021 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { State as PopperState, PositioningStrategy } from \"@popperjs/core\";\nimport classNames from \"classnames\";\nimport { Children, cloneElement, createElement, createRef } from \"react\";\nimport {\n    Manager,\n    type Modifier,\n    Popper,\n    type PopperChildrenProps,\n    Reference,\n    type ReferenceChildrenProps,\n} from \"react-popper\";\n\nimport {\n    AbstractPureComponent,\n    Classes,\n    DISPLAYNAME_PREFIX,\n    type HTMLDivProps,\n    mergeRefs,\n    refHandler,\n    Utils,\n} from \"../../common\";\nimport * as Errors from \"../../common/errors\";\nimport { Overlay2 } from \"../overlay2/overlay2\";\nimport { ResizeSensor } from \"../resize-sensor/resizeSensor\";\n// eslint-disable-next-line import/no-cycle\nimport { Tooltip } from \"../tooltip/tooltip\";\n\nimport { matchReferenceWidthModifier } from \"./customModifiers\";\nimport { POPOVER_ARROW_SVG_SIZE, PopoverArrow } from \"./popoverArrow\";\nimport { positionToPlacement } from \"./popoverPlacementUtils\";\nimport type {\n    DefaultPopoverTargetHTMLProps,\n    PopoverClickTargetHandlers,\n    PopoverHoverTargetHandlers,\n    PopoverSharedProps,\n} from \"./popoverSharedProps\";\nimport { getBasePlacement, getTransformOrigin } from \"./popperUtils\";\nimport type { PopupKind } from \"./popupKind\";\n\nexport const PopoverInteractionKind = {\n    CLICK: \"click\" as const,\n    CLICK_TARGET_ONLY: \"click-target\" as const,\n    HOVER: \"hover\" as const,\n    HOVER_TARGET_ONLY: \"hover-target\" as const,\n};\nexport type PopoverInteractionKind = (typeof PopoverInteractionKind)[keyof typeof PopoverInteractionKind];\n\nexport interface PopoverProps<TProps extends DefaultPopoverTargetHTMLProps = DefaultPopoverTargetHTMLProps>\n    extends PopoverSharedProps<TProps> {\n    /**\n     * Whether the popover/tooltip should acquire application focus when it first opens.\n     *\n     * @default true for click interactions, false for hover interactions\n     */\n    autoFocus?: boolean;\n\n    /** HTML props for the backdrop element. Can be combined with `backdropClassName`. */\n    backdropProps?: React.HTMLProps<HTMLDivElement>;\n\n    /**\n     * The kind of interaction that triggers the display of the popover.\n     *\n     * @default \"click\"\n     */\n    interactionKind?: PopoverInteractionKind;\n\n    /**\n     * The kind of popup displayed by the popover. Gets directly applied to the\n     * `aria-haspopup` attribute of the target element. This property is\n     * ignored if `interactionKind` is {@link PopoverInteractionKind.HOVER_TARGET_ONLY}.\n     *\n     * @default \"menu\" or undefined\n     */\n    popupKind?: PopupKind;\n\n    /**\n     * Enables an invisible overlay beneath the popover that captures clicks and\n     * prevents interaction with the rest of the document until the popover is\n     * closed. This prop is only available when `interactionKind` is\n     * `PopoverInteractionKind.CLICK`. When popovers with backdrop are opened,\n     * they become focused.\n     *\n     * @default false\n     */\n    hasBackdrop?: boolean;\n\n    /**\n     * Whether the application should return focus to the last active element in the\n     * document after this popover closes.\n     *\n     * This is automatically set (overridden) to:\n     *  - `false` for hover interaction popovers\n     *  - `true` when a popover closes due to an ESC keypress\n     *\n     * If you are attaching a popover _and_ a tooltip to the same target, you must take\n     * care to either disable this prop for the popover _or_ disable the tooltip's\n     * `openOnTargetFocus` prop.\n     *\n     * @default false\n     */\n    shouldReturnFocusOnClose?: boolean;\n\n    /**\n     * Popper.js positioning strategy.\n     *\n     * @see https://popper.js.org/docs/v2/constructors/#strategy\n     * @default \"absolute\"\n     */\n    positioningStrategy?: PositioningStrategy;\n}\n\nexport interface PopoverState {\n    hasDarkParent: boolean;\n    // when an ESC keypress interaction closes the overlay, we want to force-enable `shouldReturnFocusOnClose` behavior\n    isClosingViaEscapeKeypress: boolean;\n    isOpen: boolean;\n}\n\n/**\n * Popover component, used to display a floating UI next to and tethered to a target element.\n *\n * @template T target element props interface. Consumers wishing to stay in sync with Blueprint's default target HTML\n * props interface should use the `DefaultPopoverTargetHTMLProps` type (although this is already the default type for\n * this type param).\n * @see https://blueprintjs.com/docs/#core/components/popover\n */\nexport class Popover<\n    T extends DefaultPopoverTargetHTMLProps = DefaultPopoverTargetHTMLProps,\n> extends AbstractPureComponent<PopoverProps<T>, PopoverState> {\n    public static displayName = `${DISPLAYNAME_PREFIX}.Popover`;\n\n    public static defaultProps: PopoverProps = {\n        boundary: \"clippingParents\",\n        captureDismiss: false,\n        defaultIsOpen: false,\n        disabled: false,\n        fill: false,\n        hasBackdrop: false,\n        hoverCloseDelay: 300,\n        hoverOpenDelay: 150,\n        inheritDarkTheme: true,\n        interactionKind: PopoverInteractionKind.CLICK,\n        matchTargetWidth: false,\n        minimal: false,\n        openOnTargetFocus: true,\n        // N.B. we don't set a default for `placement` or `position` here because that would trigger\n        // a warning in validateProps if the other prop is specified by a user of this component\n        positioningStrategy: \"absolute\",\n        renderTarget: undefined,\n        shouldReturnFocusOnClose: false,\n        targetTagName: \"span\",\n        transitionDuration: 300,\n        usePortal: true,\n    };\n\n    public state: PopoverState = {\n        hasDarkParent: false,\n        isClosingViaEscapeKeypress: false,\n        isOpen: this.getIsOpen(this.props),\n    };\n\n    /**\n     * DOM element that contains the popover.\n     * When `usePortal={true}`, this element will be portaled outside the usual DOM flow,\n     * so this reference can be very useful for testing.\n     *\n     * @public for testing\n     */\n    public popoverElement: HTMLElement | null = null;\n\n    /** Popover ref handler */\n    private popoverRef: React.RefCallback<HTMLDivElement> = refHandler(this, \"popoverElement\", this.props.popoverRef);\n\n    /**\n     * Target DOM element ref.\n     *\n     * N.B. this must be a ref object since we pass it to `<ResizeSensor>`, which needs to know about the target\n     * DOM element in order to observe its dimensions.\n     *\n     * @public for testing\n     */\n    public targetRef = createRef<HTMLElement>();\n\n    /**\n     * Overlay2 transition container element ref.\n     */\n    private transitionContainerElement = createRef<HTMLDivElement>();\n\n    private cancelOpenTimeout?: () => void;\n\n    // a flag that lets us detect mouse movement between the target and popover,\n    // now that mouseleave is triggered when you cross the gap between the two.\n    private isMouseInTargetOrPopover = false;\n\n    // a flag that indicates whether the target previously lost focus to another\n    // element on the same page.\n    private lostFocusOnSamePage = true;\n\n    // Reference to the Poppper.scheduleUpdate() function, this changes every time the popper is mounted\n    private popperScheduleUpdate?: () => Promise<Partial<PopperState> | null>;\n\n    private isControlled = () => this.props.isOpen !== undefined;\n\n    // arrow is disabled if minimal, or if the arrow modifier was explicitly disabled\n    private isArrowEnabled = () => !this.props.minimal && this.props.modifiers?.arrow?.enabled !== false;\n\n    private isHoverInteractionKind = () => {\n        return (\n            this.props.interactionKind === PopoverInteractionKind.HOVER ||\n            this.props.interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY\n        );\n    };\n\n    // popper innerRef gives us a handle on the transition container, since that's what we render as the overlay child,\n    // so if we want to look at our actual popover element, we need to reach inside a bit\n    private getPopoverElement() {\n        return this.popoverElement?.querySelector<HTMLElement>(`.${Classes.POPOVER}`);\n    }\n\n    private getIsOpen(props: PopoverProps<T>) {\n        // disabled popovers should never be allowed to open.\n        if (props.disabled) {\n            return false;\n        } else {\n            return props.isOpen ?? props.defaultIsOpen!;\n        }\n    }\n\n    public render() {\n        const { disabled, placement, position = \"auto\", positioningStrategy } = this.props;\n        const { isOpen } = this.state;\n\n        if (this.getIsContentEmpty()) {\n            // need to do this check in render(), because `isOpen` is derived from\n            // state, and state can't necessarily be accessed in validateProps.\n            if (!disabled && isOpen !== false && !Utils.isNodeEnv(\"production\")) {\n                console.warn(Errors.POPOVER_WARN_EMPTY_CONTENT);\n            }\n            // just render the target without a content overlay if there is no content to display\n            return this.renderTarget({ ref: noop });\n        }\n\n        // Important: do not use <Reference innerRef> since it has a bug when used in React 18 strict mode\n        // see https://github.com/floating-ui/react-popper/pull/459\n        return (\n            <Manager>\n                <Reference>{this.renderTarget}</Reference>\n                <Popper\n                    innerRef={this.popoverRef}\n                    placement={placement ?? positionToPlacement(position)}\n                    strategy={positioningStrategy}\n                    modifiers={this.getPopperModifiers()}\n                >\n                    {this.renderPopover}\n                </Popper>\n            </Manager>\n        );\n    }\n\n    public componentDidMount() {\n        this.updateDarkParent();\n    }\n\n    public componentDidUpdate(props: PopoverProps<T>, state: PopoverState) {\n        super.componentDidUpdate(props, state);\n        this.updateDarkParent();\n\n        const nextIsOpen = this.getIsOpen(this.props);\n\n        if (this.props.isOpen != null && nextIsOpen !== this.state.isOpen) {\n            this.setOpenState(nextIsOpen);\n            // tricky: setOpenState calls setState only if this.props.isOpen is\n            // not controlled, so we need to invoke setState manually here.\n            this.setState({ isOpen: nextIsOpen });\n        } else if (this.props.disabled && this.state.isOpen && this.props.isOpen == null) {\n            // special case: close an uncontrolled popover when disabled is set to true\n            this.setOpenState(false);\n        }\n    }\n\n    protected validateProps(props: PopoverProps<T>) {\n        if (props.isOpen == null && props.onInteraction != null) {\n            console.warn(Errors.POPOVER_WARN_UNCONTROLLED_ONINTERACTION);\n        }\n        if (props.hasBackdrop && !props.usePortal) {\n            console.warn(Errors.POPOVER_WARN_HAS_BACKDROP_INLINE);\n        }\n        if (props.hasBackdrop && props.interactionKind !== PopoverInteractionKind.CLICK) {\n            console.warn(Errors.POPOVER_HAS_BACKDROP_INTERACTION);\n        }\n        if (props.placement !== undefined && props.position !== undefined) {\n            console.warn(Errors.POPOVER_WARN_PLACEMENT_AND_POSITION_MUTEX);\n        }\n\n        const childrenCount = Children.count(props.children);\n        const hasRenderTargetProp = props.renderTarget !== undefined;\n        const hasTargetPropsProp = props.targetProps !== undefined;\n\n        if (childrenCount === 0 && !hasRenderTargetProp) {\n            console.warn(Errors.POPOVER_REQUIRES_TARGET);\n        }\n        if (childrenCount > 1) {\n            console.warn(Errors.POPOVER_WARN_TOO_MANY_CHILDREN);\n        }\n        if (childrenCount > 0 && hasRenderTargetProp) {\n            console.warn(Errors.POPOVER_WARN_DOUBLE_TARGET);\n        }\n        if (hasRenderTargetProp && hasTargetPropsProp) {\n            console.warn(Errors.POPOVER_WARN_TARGET_PROPS_WITH_RENDER_TARGET);\n        }\n    }\n\n    /**\n     * Instance method to instruct the `Popover` to recompute its position.\n     *\n     * This method should only be used if you are updating the target in a way\n     * that does not cause it to re-render, such as changing its _position_\n     * without changing its _size_ (since `Popover` already repositions when it\n     * detects a resize).\n     */\n    public reposition = () => this.popperScheduleUpdate?.();\n\n    private renderTarget = ({ ref: popperChildRef }: ReferenceChildrenProps) => {\n        const { children, className, disabled, fill, openOnTargetFocus, renderTarget } = this.props;\n        const { isOpen } = this.state;\n        const isControlled = this.isControlled();\n        const isHoverInteractionKind = this.isHoverInteractionKind();\n\n        let { targetTagName } = this.props;\n        if (fill) {\n            targetTagName = \"div\";\n        }\n\n        // N.B. react-popper has a wide type for this ref, but we can narrow it based on the source,\n        // see https://github.com/floating-ui/react-popper/blob/beac280d61082852c4efc302be902911ce2d424c/src/Reference.js#L17\n        const ref = mergeRefs(popperChildRef as React.RefCallback<HTMLElement>, this.targetRef);\n\n        const targetEventHandlers: PopoverHoverTargetHandlers<T> | PopoverClickTargetHandlers<T> =\n            isHoverInteractionKind\n                ? {\n                      // HOVER handlers\n                      onBlur: this.handleTargetBlur,\n                      onContextMenu: this.handleTargetContextMenu,\n                      onFocus: this.handleTargetFocus,\n                      onMouseEnter: this.handleMouseEnter,\n                      onMouseLeave: this.handleMouseLeave,\n                  }\n                : {\n                      // CLICK needs only one handler\n                      onClick: this.handleTargetClick,\n                      // For keyboard accessibility, trigger the same behavior as a click event upon pressing ENTER/SPACE\n                      onKeyDown: this.handleKeyDown,\n                  };\n        // Ensure target is focusable if relevant prop enabled\n        const targetTabIndex =\n            !this.getIsContentEmpty() && !disabled && openOnTargetFocus && isHoverInteractionKind ? 0 : undefined;\n        const ownTargetProps = {\n            // N.B. this.props.className is passed along to renderTarget even though the user would have access to it.\n            // If, instead, renderTarget is undefined and the target is provided as a child, this.props.className is\n            // applied to the generated target wrapper element.\n            className: classNames(className, Classes.POPOVER_TARGET, {\n                [Classes.POPOVER_OPEN]: isOpen,\n                // this class is mainly useful for button targets\n                [Classes.ACTIVE]: isOpen && !isControlled && !isHoverInteractionKind,\n            }),\n            ref,\n            ...targetEventHandlers,\n        } satisfies React.HTMLProps<HTMLElement>;\n        const childTargetProps = {\n            \"aria-expanded\": isHoverInteractionKind ? undefined : isOpen,\n            \"aria-haspopup\":\n                this.props.interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY\n                    ? undefined\n                    : this.props.popupKind ?? \"menu\",\n        } satisfies React.HTMLProps<HTMLElement>;\n\n        const targetModifierClasses = {\n            // this class is mainly useful for Blueprint <Button> targets; we should only apply it for\n            // uncontrolled popovers when they are opened by a user interaction\n            [Classes.ACTIVE]: isOpen && !isControlled && !isHoverInteractionKind,\n            // similarly, this class is mainly useful for targets like <Button>, <InputGroup>, etc.\n            [Classes.FILL]: fill,\n        };\n\n        let target: React.JSX.Element | undefined;\n\n        if (renderTarget !== undefined) {\n            target = renderTarget({\n                ...ownTargetProps,\n                ...childTargetProps,\n                className: classNames(ownTargetProps.className, targetModifierClasses),\n                // if the consumer renders a tooltip target, it's their responsibility to disable that tooltip\n                // when *this* popover is open\n                isOpen,\n                tabIndex: targetTabIndex,\n            });\n        } else {\n            const childTarget = Utils.ensureElement(Children.toArray(children)[0]);\n\n            if (childTarget === undefined) {\n                return null;\n            }\n\n            const clonedTarget: React.JSX.Element = cloneElement(childTarget, {\n                ...childTargetProps,\n                className: classNames(childTarget.props.className, targetModifierClasses),\n                // force disable single Tooltip child when popover is open\n                disabled: isOpen && Utils.isElementOfType(childTarget, Tooltip) ? true : childTarget.props.disabled,\n                tabIndex: childTarget.props.tabIndex ?? targetTabIndex,\n            });\n            const wrappedTarget = createElement(\n                targetTagName!,\n                {\n                    ...ownTargetProps,\n                    ...this.props.targetProps,\n                },\n                clonedTarget,\n            );\n            target = wrappedTarget;\n        }\n\n        // No need to use the merged `ref` here, that only needs to be forwarded to the child node so that React can\n        // notify both popper.js and our components about the mounted DOM element.\n        return (\n            <ResizeSensor targetRef={this.targetRef} onResize={this.reposition}>\n                {target}\n            </ResizeSensor>\n        );\n    };\n\n    private renderPopover = (popperProps: PopperChildrenProps) => {\n        const { autoFocus, enforceFocus, backdropProps, canEscapeKeyClose, hasBackdrop, interactionKind, usePortal } =\n            this.props;\n        const { isClosingViaEscapeKeypress, isOpen } = this.state;\n\n        // compute an appropriate transform origin so the scale animation points towards target\n        const transformOrigin = getTransformOrigin(\n            popperProps.placement,\n            this.isArrowEnabled() ? (popperProps.arrowProps.style as any) : undefined,\n        );\n\n        // need to update our reference to this function on every render as it will change.\n        this.popperScheduleUpdate = popperProps.update;\n\n        const popoverHandlers: HTMLDivProps = {\n            // always check popover clicks for dismiss class\n            onClick: this.handlePopoverClick,\n            // treat ENTER/SPACE keys the same as a click for accessibility\n            onKeyDown: event => Utils.isKeyboardClick(event) && this.handlePopoverClick(event),\n        };\n        if (\n            interactionKind === PopoverInteractionKind.HOVER ||\n            (!usePortal && interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY)\n        ) {\n            popoverHandlers.onMouseEnter = this.handleMouseEnter;\n            popoverHandlers.onMouseLeave = this.handleMouseLeave;\n        }\n\n        const basePlacement = getBasePlacement(popperProps.placement);\n        const popoverClasses = classNames(\n            Classes.POPOVER,\n            {\n                [Classes.DARK]: this.props.inheritDarkTheme && this.state.hasDarkParent,\n                [Classes.MINIMAL]: this.props.minimal,\n                [Classes.POPOVER_CAPTURING_DISMISS]: this.props.captureDismiss,\n                [Classes.POPOVER_MATCH_TARGET_WIDTH]: this.props.matchTargetWidth,\n                [Classes.POPOVER_REFERENCE_HIDDEN]: popperProps.isReferenceHidden === true,\n                [Classes.POPOVER_POPPER_ESCAPED]: popperProps.hasPopperEscaped === true,\n            },\n            `${Classes.POPOVER_CONTENT_PLACEMENT}-${basePlacement}`,\n            this.props.popoverClassName,\n        );\n\n        const defaultAutoFocus = this.isHoverInteractionKind() ? false : undefined;\n        // if hover interaction, it doesn't make sense to take over focus control\n        const shouldReturnFocusOnClose = this.isHoverInteractionKind()\n            ? false\n            : isClosingViaEscapeKeypress\n              ? true\n              : this.props.shouldReturnFocusOnClose;\n\n        return (\n            <Overlay2\n                autoFocus={autoFocus ?? defaultAutoFocus}\n                backdropClassName={Classes.POPOVER_BACKDROP}\n                backdropProps={backdropProps}\n                canEscapeKeyClose={canEscapeKeyClose}\n                canOutsideClickClose={interactionKind === PopoverInteractionKind.CLICK}\n                childRef={this.transitionContainerElement}\n                enforceFocus={enforceFocus}\n                hasBackdrop={hasBackdrop}\n                isOpen={isOpen}\n                lazy={this.props.lazy}\n                onClose={this.handleOverlayClose}\n                onClosed={this.props.onClosed}\n                onClosing={this.props.onClosing}\n                onOpened={this.props.onOpened}\n                onOpening={this.props.onOpening}\n                transitionDuration={this.props.transitionDuration}\n                transitionName={Classes.POPOVER}\n                usePortal={usePortal}\n                portalClassName={this.props.portalClassName}\n                portalContainer={this.props.portalContainer}\n                // eslint-disable-next-line @typescript-eslint/no-deprecated\n                portalStopPropagationEvents={this.props.portalStopPropagationEvents}\n                shouldReturnFocusOnClose={shouldReturnFocusOnClose}\n            >\n                <div\n                    className={Classes.POPOVER_TRANSITION_CONTAINER}\n                    // We need to attach a ref that notifies both react-popper and our Popover component about the DOM\n                    // element inside the Overlay2. We cannot re-use `PopperChildrenProps.ref` because Overlay2 only\n                    // accepts a ref object (not a callback) due to a CSSTransition API limitation.\n                    // N.B. react-popper has a wide type for this ref, but we can narrow it based on the source,\n                    // see https://github.com/floating-ui/react-popper/blob/beac280d61082852c4efc302be902911ce2d424c/src/Popper.js#L94\n                    ref={mergeRefs(popperProps.ref as React.RefCallback<HTMLElement>, this.transitionContainerElement)}\n                    style={popperProps.style}\n                >\n                    <ResizeSensor onResize={this.reposition}>\n                        <div\n                            className={popoverClasses}\n                            style={{ transformOrigin }}\n                            ref={this.popoverRef}\n                            {...popoverHandlers}\n                        >\n                            {this.isArrowEnabled() && (\n                                <PopoverArrow arrowProps={popperProps.arrowProps} placement={popperProps.placement} />\n                            )}\n                            <div className={Classes.POPOVER_CONTENT}>{this.props.content}</div>\n                        </div>\n                    </ResizeSensor>\n                </div>\n            </Overlay2>\n        );\n    };\n\n    private getPopperModifiers(): ReadonlyArray<Modifier<any>> {\n        const { matchTargetWidth, modifiers, modifiersCustom } = this.props;\n        const popperModifiers: Array<Modifier<any>> = [\n            {\n                enabled: this.isArrowEnabled(),\n                name: \"arrow\",\n                ...modifiers?.arrow,\n            },\n            {\n                name: \"computeStyles\",\n                ...modifiers?.computeStyles,\n                options: {\n                    adaptive: true,\n                    // We disable the built-in gpuAcceleration so that\n                    // Popper.js will return us easy to interpolate values\n                    // (top, left instead of transform: translate3d)\n                    // We'll then use these values to generate the needed\n                    // css transform values blended with the react-spring values\n                    gpuAcceleration: false,\n                    ...modifiers?.computeStyles?.options,\n                },\n            },\n            {\n                enabled: this.isArrowEnabled(),\n                name: \"offset\",\n                ...modifiers?.offset,\n                options: {\n                    offset: [0, POPOVER_ARROW_SVG_SIZE / 2],\n                    ...modifiers?.offset?.options,\n                },\n            },\n            {\n                name: \"flip\",\n                ...modifiers?.flip,\n                options: {\n                    boundary: this.props.boundary,\n                    rootBoundary: this.props.rootBoundary,\n                    ...modifiers?.flip?.options,\n                },\n            },\n            {\n                name: \"preventOverflow\",\n                ...modifiers?.preventOverflow,\n                options: {\n                    boundary: this.props.boundary,\n                    rootBoundary: this.props.rootBoundary,\n                    ...modifiers?.preventOverflow?.options,\n                },\n            },\n        ];\n\n        if (matchTargetWidth) {\n            popperModifiers.push(matchReferenceWidthModifier);\n        }\n\n        if (modifiersCustom !== undefined) {\n            popperModifiers.push(...modifiersCustom);\n        }\n\n        return popperModifiers;\n    }\n\n    private handleTargetFocus = (e: React.FocusEvent<HTMLElement>) => {\n        if (this.props.openOnTargetFocus && this.isHoverInteractionKind()) {\n            if (e.relatedTarget == null && !this.lostFocusOnSamePage) {\n                // ignore this focus event -- the target was already focused but the page itself\n                // lost focus (e.g. due to switching tabs).\n                return;\n            }\n            this.handleMouseEnter(e as unknown as React.MouseEvent<HTMLElement>);\n        }\n    };\n\n    private handleTargetBlur = (e: React.FocusEvent<HTMLElement>) => {\n        if (this.props.openOnTargetFocus && this.isHoverInteractionKind()) {\n            if (e.relatedTarget != null) {\n                // if the next element to receive focus is within the popover, we'll want to leave the\n                // popover open.\n                if (\n                    e.relatedTarget !== this.popoverElement &&\n                    !this.isElementInPopover(e.relatedTarget as HTMLElement)\n                ) {\n                    this.handleMouseLeave(e as unknown as React.MouseEvent<HTMLElement>);\n                }\n            } else {\n                this.handleMouseLeave(e as unknown as React.MouseEvent<HTMLElement>);\n            }\n        }\n        this.lostFocusOnSamePage = e.relatedTarget != null;\n    };\n\n    private handleTargetContextMenu = (e: React.MouseEvent<HTMLElement>) => {\n        // we assume that when someone prevents the default interaction on this event (a browser native context menu),\n        // they are showing a custom context menu (as ContextMenu2 does); in this case, we should close this popover/tooltip\n        if (e.defaultPrevented) {\n            this.setOpenState(false, e);\n        }\n    };\n\n    private handleMouseEnter = (e: React.MouseEvent<HTMLElement>) => {\n        this.isMouseInTargetOrPopover = true;\n\n        // if we're entering the popover, and the mode is set to be HOVER_TARGET_ONLY, we want to manually\n        // trigger the mouse leave event, as hovering over the popover shouldn't count.\n        if (\n            !this.props.usePortal &&\n            this.isElementInPopover(e.target as Element) &&\n            this.props.interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY &&\n            !this.props.openOnTargetFocus\n        ) {\n            this.handleMouseLeave(e);\n        } else if (!this.props.disabled) {\n            // only begin opening popover when it is enabled\n            this.setOpenState(true, e, this.props.hoverOpenDelay);\n        }\n    };\n\n    private handleMouseLeave = (e: React.MouseEvent<HTMLElement>) => {\n        this.isMouseInTargetOrPopover = false;\n\n        // Wait until the event queue is flushed, because we want to leave the\n        // popover open if the mouse entered the popover immediately after\n        // leaving the target (or vice versa). Make sure to persist the event since\n        // we need to access `nativeEvent` in `this.setOpenState()`.\n        e.persist();\n        this.setTimeout(() => {\n            if (this.isMouseInTargetOrPopover) {\n                return;\n            }\n            // user-configurable closing delay is helpful when moving mouse from target to popover\n            this.setOpenState(false, e, this.props.hoverCloseDelay);\n        });\n    };\n\n    private handlePopoverClick = (e: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>) => {\n        const eventTarget = e.target as HTMLElement;\n        const eventPopover = eventTarget.closest(`.${Classes.POPOVER}`);\n        const eventPopoverV1 = eventTarget.closest(`.${Classes.POPOVER}`);\n        const isEventFromSelf = (eventPopover ?? eventPopoverV1) === this.getPopoverElement();\n\n        const isEventPopoverCapturing =\n            eventPopover?.classList.contains(Classes.POPOVER_CAPTURING_DISMISS) ??\n            eventPopoverV1?.classList.contains(Classes.POPOVER_CAPTURING_DISMISS) ??\n            false;\n\n        // an OVERRIDE inside a DISMISS does not dismiss, and a DISMISS inside an OVERRIDE will dismiss.\n        const dismissElement = eventTarget.closest(`.${Classes.POPOVER_DISMISS}, .${Classes.POPOVER_DISMISS_OVERRIDE}`);\n        const shouldDismiss = dismissElement?.classList.contains(Classes.POPOVER_DISMISS) ?? false;\n        const isDisabled = eventTarget.closest(`:disabled, .${Classes.DISABLED}`) != null;\n\n        if (shouldDismiss && !isDisabled && (!isEventPopoverCapturing || isEventFromSelf)) {\n            this.setOpenState(false, e);\n        }\n    };\n\n    private handleOverlayClose = (e?: React.SyntheticEvent<HTMLElement>) => {\n        if (this.targetRef.current == null || e === undefined) {\n            return;\n        }\n\n        const event = (e.nativeEvent ?? e) as Event;\n        const eventTarget = (event.composed ? event.composedPath()[0] : event.target) as HTMLElement;\n        // if click was in target, target event listener will handle things, so don't close\n        if (!Utils.elementIsOrContains(this.targetRef.current, eventTarget) || e.nativeEvent instanceof KeyboardEvent) {\n            this.setOpenState(false, e);\n        }\n    };\n\n    private handleKeyDown = (e: React.KeyboardEvent<HTMLElement>) => {\n        const isKeyboardClick = Utils.isKeyboardClick(e);\n\n        // For keyboard accessibility, trigger the same behavior as a click event upon pressing ENTER/SPACE\n        if (isKeyboardClick) {\n            this.handleTargetClick(e);\n        }\n    };\n\n    private handleTargetClick = (e: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>) => {\n        // Target element(s) may fire simulated click event upon pressing ENTER/SPACE, which we should ignore\n        // see: https://github.com/palantir/blueprint/issues/5775\n        const shouldIgnoreClick = this.state.isOpen && this.isSimulatedButtonClick(e);\n        if (!shouldIgnoreClick) {\n            // ensure click did not originate from within inline popover before closing\n            if (!this.props.disabled && !this.isElementInPopover(e.target as HTMLElement)) {\n                if (this.props.isOpen == null) {\n                    this.setState(prevState => ({ isOpen: !prevState.isOpen }));\n                } else {\n                    this.setOpenState(!this.props.isOpen, e);\n                }\n            }\n        }\n    };\n\n    private isSimulatedButtonClick = (e: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>) => {\n        return !e.isTrusted && (e.target as HTMLElement).matches(`.${Classes.BUTTON}`);\n    };\n\n    // a wrapper around setState({ isOpen }) that will call props.onInteraction instead when in controlled mode.\n    // starts a timeout to delay changing the state if a non-zero duration is provided.\n    private setOpenState(isOpen: boolean, e?: React.SyntheticEvent<HTMLElement>, timeout?: number) {\n        // cancel any existing timeout because we have new state\n        this.cancelOpenTimeout?.();\n        if (timeout !== undefined && timeout > 0) {\n            // Persist the react event since it will be used in a later macrotask.\n            e?.persist();\n            this.cancelOpenTimeout = this.setTimeout(() => {\n                this.setOpenState(isOpen, e);\n            }, timeout);\n        } else {\n            if (this.props.isOpen == null) {\n                this.setState({ isOpen });\n            } else {\n                this.props.onInteraction?.(isOpen, e);\n            }\n            if (!isOpen) {\n                // non-null assertion because the only time `e` is undefined is when in controlled mode\n                // or the rare special case in uncontrolled mode when the `disabled` flag is toggled true\n                this.props.onClose?.(e!);\n                this.setState({ isClosingViaEscapeKeypress: isEscapeKeypressEvent(e?.nativeEvent) });\n            }\n        }\n    }\n\n    private updateDarkParent() {\n        if (this.props.usePortal && this.state.isOpen) {\n            const hasDarkParent = this.targetRef.current?.closest(`.${Classes.DARK}`) != null;\n            this.setState({ hasDarkParent });\n        }\n    }\n\n    private isElementInPopover(element: Element) {\n        return this.getPopoverElement()?.contains(element) ?? false;\n    }\n\n    private getIsContentEmpty() {\n        const { content } = this.props;\n        return content == null || Utils.isEmptyString(content);\n    }\n}\n\nfunction isEscapeKeypressEvent(e?: Event) {\n    return e instanceof KeyboardEvent && e.key === \"Escape\";\n}\n\nfunction noop() {\n    // no-op\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}