{"ast":null,"code":"import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from \"react/jsx-runtime\";\n/*\n * Copyright 2021 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport classNames from \"classnames\";\nimport { createElement, forwardRef, useCallback, useContext, useEffect, useMemo, useRef, useState } from \"react\";\nimport { Classes, DISPLAYNAME_PREFIX, mergeRefs, Utils } from \"../../common\";\nimport { TooltipContext, TooltipProvider } from \"../popover/tooltipContext\";\nimport { ContextMenuPopover } from \"./contextMenuPopover\";\n/**\n * Context menu component.\n *\n * @see https://blueprintjs.com/docs/#core/components/context-menu\n */\nexport const ContextMenu = forwardRef((props, userRef) => {\n  const {\n    className,\n    children,\n    content,\n    disabled = false,\n    onClose,\n    onContextMenu,\n    popoverProps,\n    tagName = \"div\",\n    ...restProps\n  } = props;\n  // ancestor TooltipContext state doesn't affect us since we don't care about parent ContextMenus, we only want to\n  // force disable parent Tooltips in certain cases through dispatching actions\n  // N.B. any calls to this dispatch function will be no-ops if there is no TooltipProvider ancestor of this component\n  const [, tooltipCtxDispatch] = useContext(TooltipContext);\n  // click target offset relative to the viewport (e.clientX/clientY), since the target will be rendered in a Portal\n  const [targetOffset, setTargetOffset] = useState(undefined);\n  // hold a reference to the click mouse event to pass to content/child render functions\n  const [mouseEvent, setMouseEvent] = useState();\n  const [isOpen, setIsOpen] = useState(false);\n  // we need a ref on the child element (or the wrapper we generate) to check for dark theme\n  const childRef = useRef(null);\n  // If disabled prop is changed, we don't want our old context menu to stick around.\n  // If it has just been enabled (disabled = false), then the menu ought to be opened by\n  // a new mouse event. Users should not be updating this prop in the onContextMenu callback\n  // for this component (that will lead to unpredictable behavior).\n  useEffect(() => {\n    setIsOpen(false);\n    tooltipCtxDispatch({\n      type: \"RESET_DISABLED_STATE\"\n    });\n  }, [disabled, tooltipCtxDispatch]);\n  const handlePopoverClose = useCallback(() => {\n    setIsOpen(false);\n    setMouseEvent(undefined);\n    tooltipCtxDispatch({\n      type: \"RESET_DISABLED_STATE\"\n    });\n    onClose === null || onClose === void 0 ? void 0 : onClose();\n  }, [onClose, tooltipCtxDispatch]);\n  // if the menu was just opened, we should check for dark theme (but don't do this on every render)\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const isDarkTheme = useMemo(() => Utils.isDarkTheme(childRef.current), [childRef, isOpen]);\n  const contentProps = useMemo(() => ({\n    isOpen,\n    mouseEvent,\n    targetOffset\n  }), [isOpen, mouseEvent, targetOffset]);\n  // create a memoized function to render the menu so that we can call it if necessary in the \"contextmenu\" event\n  // handler which runs before this render function has a chance to re-run and update the `menu` variable\n  const renderMenu = useCallback(menuContentProps => disabled ? undefined : Utils.isFunction(content) ? content(menuContentProps) : content, [disabled, content]);\n  const menuContent = useMemo(() => renderMenu(contentProps), [contentProps, renderMenu]);\n  // only render the popover if there is content in the context menu;\n  // this avoid doing unnecessary rendering & computation\n  const maybePopover = menuContent === undefined ? undefined : _jsx(ContextMenuPopover, {\n    ...popoverProps,\n    content: menuContent,\n    isDarkTheme: isDarkTheme,\n    isOpen: isOpen,\n    targetOffset: targetOffset,\n    onClose: handlePopoverClose\n  });\n  const handleContextMenu = useCallback(e => {\n    // support nested menus (inner menu target would have called preventDefault())\n    if (e.defaultPrevented) {\n      return;\n    }\n    // If disabled, we should avoid the extra work in this event handler.\n    // Otherwise: if using the child or content function APIs, we need to make sure contentProps gets updated,\n    // so we handle the event regardless of whether the consumer returned an undefined menu.\n    const shouldHandleEvent = !disabled && (Utils.isFunction(children) || Utils.isFunction(content) || content !== undefined);\n    if (shouldHandleEvent) {\n      setIsOpen(true);\n      e.persist();\n      setMouseEvent(e);\n      const newTargetOffset = {\n        left: e.clientX,\n        top: e.clientY\n      };\n      setTargetOffset(newTargetOffset);\n      tooltipCtxDispatch({\n        type: \"FORCE_DISABLED_STATE\"\n      });\n      const newMenuContent = renderMenu({\n        isOpen: true,\n        mouseEvent: e,\n        targetOffset: newTargetOffset\n      });\n      if (newMenuContent === undefined) {\n        // If there is no menu content, we shouldn't automatically swallow the contextmenu event, since the\n        // user probably wants to fall back to default browser behavior. If they still want to disable the\n        // native context menu in that case, they can do so with their own `onContextMenu` handler.\n      } else {\n        e.preventDefault();\n      }\n    }\n    onContextMenu === null || onContextMenu === void 0 ? void 0 : onContextMenu(e);\n  }, [disabled, children, content, onContextMenu, tooltipCtxDispatch, renderMenu]);\n  const containerClassName = classNames(className, Classes.CONTEXT_MENU);\n  const child = Utils.isFunction(children) ? children({\n    className: containerClassName,\n    contentProps,\n    onContextMenu: handleContextMenu,\n    popover: maybePopover,\n    ref: childRef\n  }) : _jsxs(_Fragment, {\n    children: [maybePopover, createElement(tagName, {\n      className: containerClassName,\n      onContextMenu: handleContextMenu,\n      ref: mergeRefs(childRef, userRef),\n      ...restProps\n    }, children)]\n  });\n  // force descendant Tooltips to be disabled when this context menu is open\n  return _jsx(TooltipProvider, {\n    forceDisable: isOpen,\n    children: child\n  });\n});\nContextMenu.displayName = `${DISPLAYNAME_PREFIX}.ContextMenu`;","map":{"version":3,"names":["classNames","createElement","forwardRef","useCallback","useContext","useEffect","useMemo","useRef","useState","Classes","DISPLAYNAME_PREFIX","mergeRefs","Utils","TooltipContext","TooltipProvider","ContextMenuPopover","ContextMenu","props","userRef","className","children","content","disabled","onClose","onContextMenu","popoverProps","tagName","restProps","tooltipCtxDispatch","targetOffset","setTargetOffset","undefined","mouseEvent","setMouseEvent","isOpen","setIsOpen","childRef","type","handlePopoverClose","isDarkTheme","current","contentProps","renderMenu","menuContentProps","isFunction","menuContent","maybePopover","_jsx","handleContextMenu","e","defaultPrevented","shouldHandleEvent","persist","newTargetOffset","left","clientX","top","clientY","newMenuContent","preventDefault","containerClassName","CONTEXT_MENU","child","popover","ref","_jsxs","_Fragment","forceDisable","displayName"],"sources":["/Users/husseingalal/Desktop/Hackathon/Elrond/frontend/node_modules/@blueprintjs/core/src/components/context-menu/contextMenu.tsx"],"sourcesContent":["/*\n * Copyright 2021 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport classNames from \"classnames\";\nimport { createElement, forwardRef, useCallback, useContext, useEffect, useMemo, useRef, useState } from \"react\";\n\nimport { Classes, DISPLAYNAME_PREFIX, mergeRefs, type Props, Utils } from \"../../common\";\nimport { TooltipContext, TooltipProvider } from \"../popover/tooltipContext\";\n\nimport { ContextMenuPopover } from \"./contextMenuPopover\";\nimport type { ContextMenuPopoverOptions, Offset } from \"./contextMenuShared\";\n\n/**\n * Render props relevant to the _content_ of a context menu (rendered as the underlying Popover's content).\n */\nexport interface ContextMenuContentProps {\n    /** Whether the context menu is currently open. */\n    isOpen: boolean;\n\n    /**\n     * The computed target offset (x, y) coordinates for the context menu click event.\n     * On first render, before any context menu click event has occurred, this will be undefined.\n     */\n    targetOffset: Offset | undefined;\n\n    /** The context menu click event. If isOpen is false, this will be undefined. */\n    mouseEvent: React.MouseEvent<HTMLElement> | undefined;\n}\n\n/**\n * Render props for advanced usage of ContextMenu.\n */\nexport interface ContextMenuChildrenProps {\n    /** Context menu container element class */\n    className: string;\n\n    /** Render props relevant to the content of this context menu */\n    contentProps: ContextMenuContentProps;\n\n    /** Context menu handler which implements the custom context menu interaction */\n    onContextMenu: React.MouseEventHandler<HTMLElement>;\n\n    /** Popover element rendered by ContextMenu, used to establish a click target to position the menu */\n    popover: React.JSX.Element | undefined;\n\n    /** DOM ref for the context menu target, used to detect dark theme */\n    ref: React.Ref<any>;\n}\n\nexport interface ContextMenuProps\n    extends Omit<React.HTMLAttributes<HTMLElement>, \"children\" | \"className\" | \"content\" | \"onContextMenu\">,\n        React.RefAttributes<any>,\n        Props {\n    /**\n     * Menu content. This will usually be a Blueprint `<Menu>` component.\n     * This optionally functions as a render prop so you can use component state to render content.\n     */\n    content: React.JSX.Element | ((props: ContextMenuContentProps) => React.JSX.Element | undefined) | undefined;\n\n    /**\n     * The context menu target. This may optionally be a render function so you can use\n     * component state to render the target.\n     */\n    children: React.ReactNode | ((props: ContextMenuChildrenProps) => React.ReactElement);\n\n    /**\n     * Whether the context menu is disabled.\n     *\n     * @default false\n     */\n    disabled?: boolean;\n\n    /**\n     * Callback invoked when the popover overlay closes.\n     */\n    onClose?: () => void;\n\n    /**\n     * An optional context menu event handler. This can be useful if you want to do something with the\n     * mouse event unrelated to rendering the context menu itself, especially if that involves setting\n     * React state (which is an error to do in the render code path of this component).\n     */\n    onContextMenu?: React.MouseEventHandler<HTMLElement>;\n\n    /**\n     * A limited subset of props to forward along to the popover overlay generated by this component.\n     */\n    popoverProps?: ContextMenuPopoverOptions;\n\n    /**\n     * HTML tag to use for container element. Only used if this component's children are specified as\n     * React node(s), not when it is a render function (in that case, you get to render whatever tag\n     * you wish).\n     *\n     * @default \"div\"\n     */\n    tagName?: keyof React.JSX.IntrinsicElements;\n}\n\n/**\n * Context menu component.\n *\n * @see https://blueprintjs.com/docs/#core/components/context-menu\n */\nexport const ContextMenu: React.FC<ContextMenuProps> = forwardRef<any, ContextMenuProps>((props, userRef) => {\n    const {\n        className,\n        children,\n        content,\n        disabled = false,\n        onClose,\n        onContextMenu,\n        popoverProps,\n        tagName = \"div\",\n        ...restProps\n    } = props;\n\n    // ancestor TooltipContext state doesn't affect us since we don't care about parent ContextMenus, we only want to\n    // force disable parent Tooltips in certain cases through dispatching actions\n    // N.B. any calls to this dispatch function will be no-ops if there is no TooltipProvider ancestor of this component\n    const [, tooltipCtxDispatch] = useContext(TooltipContext);\n    // click target offset relative to the viewport (e.clientX/clientY), since the target will be rendered in a Portal\n    const [targetOffset, setTargetOffset] = useState<Offset | undefined>(undefined);\n    // hold a reference to the click mouse event to pass to content/child render functions\n    const [mouseEvent, setMouseEvent] = useState<React.MouseEvent<HTMLElement>>();\n    const [isOpen, setIsOpen] = useState<boolean>(false);\n    // we need a ref on the child element (or the wrapper we generate) to check for dark theme\n    const childRef = useRef<HTMLDivElement>(null);\n\n    // If disabled prop is changed, we don't want our old context menu to stick around.\n    // If it has just been enabled (disabled = false), then the menu ought to be opened by\n    // a new mouse event. Users should not be updating this prop in the onContextMenu callback\n    // for this component (that will lead to unpredictable behavior).\n    useEffect(() => {\n        setIsOpen(false);\n        tooltipCtxDispatch({ type: \"RESET_DISABLED_STATE\" });\n    }, [disabled, tooltipCtxDispatch]);\n\n    const handlePopoverClose = useCallback(() => {\n        setIsOpen(false);\n        setMouseEvent(undefined);\n        tooltipCtxDispatch({ type: \"RESET_DISABLED_STATE\" });\n        onClose?.();\n    }, [onClose, tooltipCtxDispatch]);\n\n    // if the menu was just opened, we should check for dark theme (but don't do this on every render)\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    const isDarkTheme = useMemo(() => Utils.isDarkTheme(childRef.current), [childRef, isOpen]);\n\n    const contentProps: ContextMenuContentProps = useMemo(\n        () => ({\n            isOpen,\n            mouseEvent,\n            targetOffset,\n        }),\n        [isOpen, mouseEvent, targetOffset],\n    );\n    // create a memoized function to render the menu so that we can call it if necessary in the \"contextmenu\" event\n    // handler which runs before this render function has a chance to re-run and update the `menu` variable\n    const renderMenu = useCallback(\n        (menuContentProps: ContextMenuContentProps) =>\n            disabled ? undefined : Utils.isFunction(content) ? content(menuContentProps) : content,\n        [disabled, content],\n    );\n    const menuContent = useMemo(() => renderMenu(contentProps), [contentProps, renderMenu]);\n\n    // only render the popover if there is content in the context menu;\n    // this avoid doing unnecessary rendering & computation\n    const maybePopover =\n        menuContent === undefined ? undefined : (\n            <ContextMenuPopover\n                {...popoverProps}\n                content={menuContent}\n                isDarkTheme={isDarkTheme}\n                isOpen={isOpen}\n                targetOffset={targetOffset}\n                onClose={handlePopoverClose}\n            />\n        );\n\n    const handleContextMenu = useCallback(\n        (e: React.MouseEvent<HTMLElement>) => {\n            // support nested menus (inner menu target would have called preventDefault())\n            if (e.defaultPrevented) {\n                return;\n            }\n\n            // If disabled, we should avoid the extra work in this event handler.\n            // Otherwise: if using the child or content function APIs, we need to make sure contentProps gets updated,\n            // so we handle the event regardless of whether the consumer returned an undefined menu.\n            const shouldHandleEvent =\n                !disabled && (Utils.isFunction(children) || Utils.isFunction(content) || content !== undefined);\n\n            if (shouldHandleEvent) {\n                setIsOpen(true);\n                e.persist();\n                setMouseEvent(e);\n                const newTargetOffset = { left: e.clientX, top: e.clientY };\n                setTargetOffset(newTargetOffset);\n                tooltipCtxDispatch({ type: \"FORCE_DISABLED_STATE\" });\n\n                const newMenuContent = renderMenu({ isOpen: true, mouseEvent: e, targetOffset: newTargetOffset });\n\n                if (newMenuContent === undefined) {\n                    // If there is no menu content, we shouldn't automatically swallow the contextmenu event, since the\n                    // user probably wants to fall back to default browser behavior. If they still want to disable the\n                    // native context menu in that case, they can do so with their own `onContextMenu` handler.\n                } else {\n                    e.preventDefault();\n                }\n            }\n\n            onContextMenu?.(e);\n        },\n        [disabled, children, content, onContextMenu, tooltipCtxDispatch, renderMenu],\n    );\n\n    const containerClassName = classNames(className, Classes.CONTEXT_MENU);\n\n    const child = Utils.isFunction(children) ? (\n        children({\n            className: containerClassName,\n            contentProps,\n            onContextMenu: handleContextMenu,\n            popover: maybePopover,\n            ref: childRef,\n        })\n    ) : (\n        <>\n            {maybePopover}\n            {createElement<React.HTMLAttributes<any> & React.ClassAttributes<any>>(\n                tagName,\n                {\n                    className: containerClassName,\n                    onContextMenu: handleContextMenu,\n                    ref: mergeRefs(childRef, userRef),\n                    ...restProps,\n                },\n                children,\n            )}\n        </>\n    );\n\n    // force descendant Tooltips to be disabled when this context menu is open\n    return <TooltipProvider forceDisable={isOpen}>{child}</TooltipProvider>;\n});\nContextMenu.displayName = `${DISPLAYNAME_PREFIX}.ContextMenu`;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}