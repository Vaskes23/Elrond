{"ast":null,"code":"import { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\n/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport classNames from \"classnames\";\nimport { AbstractPureComponent, Classes } from \"../../common\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\nimport { clamp } from \"../../common/utils\";\nconst BUFFER_WIDTH_DEFAULT = 5;\n/**\n * EditableText component.\n *\n * @see https://blueprintjs.com/docs/#core/components/editable-text\n */\nexport class EditableText extends AbstractPureComponent {\n  constructor(props) {\n    super(props);\n    this.inputElement = null;\n    this.valueElement = null;\n    this.refHandlers = {\n      content: spanElement => {\n        this.valueElement = spanElement;\n      },\n      input: input => {\n        if (input != null) {\n          this.inputElement = input;\n          // temporary fix for #3882\n          if (!this.props.alwaysRenderInput) {\n            this.inputElement.focus();\n          }\n          if (this.state != null && this.state.isEditing) {\n            const supportsSelection = inputSupportsSelection(input);\n            if (supportsSelection) {\n              const {\n                length\n              } = input.value;\n              input.setSelectionRange(this.props.selectAllOnFocus ? 0 : length, length);\n            }\n            if (!supportsSelection || !this.props.selectAllOnFocus) {\n              input.scrollLeft = input.scrollWidth;\n            }\n          }\n        }\n      }\n    };\n    this.cancelEditing = () => {\n      var _a, _b, _c, _d;\n      const {\n        lastValue,\n        value\n      } = this.state;\n      this.setState({\n        isEditing: false,\n        value: lastValue\n      });\n      if (value !== lastValue) {\n        (_b = (_a = this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, lastValue);\n      }\n      (_d = (_c = this.props).onCancel) === null || _d === void 0 ? void 0 : _d.call(_c, lastValue);\n    };\n    this.toggleEditing = () => {\n      var _a, _b;\n      if (this.state.isEditing) {\n        const {\n          value\n        } = this.state;\n        this.setState({\n          isEditing: false,\n          lastValue: value\n        });\n        (_b = (_a = this.props).onConfirm) === null || _b === void 0 ? void 0 : _b.call(_a, value);\n      } else if (!this.props.disabled) {\n        this.setState({\n          isEditing: true\n        });\n      }\n    };\n    this.handleFocus = () => {\n      const {\n        alwaysRenderInput,\n        disabled,\n        selectAllOnFocus\n      } = this.props;\n      if (!disabled) {\n        this.setState({\n          isEditing: true\n        });\n      }\n      if (alwaysRenderInput && selectAllOnFocus && this.inputElement != null) {\n        const {\n          length\n        } = this.inputElement.value;\n        this.inputElement.setSelectionRange(0, length);\n      }\n    };\n    this.handleTextChange = event => {\n      var _a, _b;\n      const value = event.target.value;\n      // state value should be updated only when uncontrolled\n      if (this.props.value == null) {\n        this.setState({\n          value\n        });\n      }\n      (_b = (_a = this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, value);\n    };\n    this.handleKeyEvent = event => {\n      // During IME composition, Enter and Escape has special meanings that we will not override\n      if (event.nativeEvent.isComposing) {\n        return;\n      }\n      const {\n        altKey,\n        ctrlKey,\n        metaKey,\n        shiftKey\n      } = event;\n      if (event.key === \"Escape\") {\n        this.cancelEditing();\n        return;\n      }\n      const hasModifierKey = altKey || ctrlKey || metaKey || shiftKey;\n      if (event.key === \"Enter\") {\n        // prevent browsers (Edge?) from full screening with alt + enter\n        // shift + enter adds a newline by default\n        if (altKey || shiftKey) {\n          event.preventDefault();\n        }\n        if (this.props.confirmOnEnterKey && this.props.multiline) {\n          if (event.target != null && hasModifierKey) {\n            insertAtCaret(event.target, \"\\n\");\n            this.handleTextChange(event);\n          } else {\n            this.toggleEditing();\n          }\n        } else if (!this.props.multiline || hasModifierKey) {\n          this.toggleEditing();\n        }\n      }\n    };\n    const value = props.value == null ? props.defaultValue : props.value;\n    this.state = {\n      inputHeight: 0,\n      inputWidth: 0,\n      isEditing: props.isEditing === true && props.disabled === false,\n      lastValue: value,\n      value\n    };\n  }\n  render() {\n    var _a;\n    const {\n      alwaysRenderInput,\n      disabled,\n      elementRef,\n      multiline,\n      contentId\n    } = this.props;\n    const value = (_a = this.props.value) !== null && _a !== void 0 ? _a : this.state.value;\n    const hasValue = value != null && value !== \"\";\n    const classes = classNames(Classes.EDITABLE_TEXT, Classes.intentClass(this.props.intent), {\n      [Classes.DISABLED]: disabled,\n      [Classes.EDITABLE_TEXT_EDITING]: this.state.isEditing,\n      [Classes.EDITABLE_TEXT_PLACEHOLDER]: !hasValue,\n      [Classes.MULTILINE]: multiline\n    }, this.props.className);\n    let contentStyle;\n    if (multiline) {\n      // set height only in multiline mode when not editing\n      // otherwise we're measuring this element to determine appropriate height of text\n      contentStyle = {\n        height: !this.state.isEditing ? this.state.inputHeight : undefined\n      };\n    } else {\n      // minWidth only applies in single line mode (multiline == width 100%)\n      contentStyle = {\n        height: this.state.inputHeight,\n        lineHeight: this.state.inputHeight != null ? `${this.state.inputHeight}px` : undefined,\n        minWidth: this.props.minWidth\n      };\n    }\n    // If we are always rendering an input, then NEVER make the container div focusable.\n    // Otherwise, make container div focusable when not editing, so it can still be tabbed\n    // to focus (when the input is rendered, it is itself focusable so container div doesn't need to be)\n    const tabIndex = alwaysRenderInput || this.state.isEditing || disabled ? undefined : 0;\n    // we need the contents to be rendered while editing so that we can measure their height\n    // and size the container element responsively\n    const shouldHideContents = alwaysRenderInput && !this.state.isEditing;\n    const spanProps = contentId != null ? {\n      id: contentId\n    } : {};\n    return _jsxs(\"div\", {\n      className: classes,\n      onFocus: this.handleFocus,\n      tabIndex: tabIndex,\n      ref: elementRef,\n      children: [alwaysRenderInput || this.state.isEditing ? this.renderInput(value) : undefined, shouldHideContents ? undefined : _jsx(\"span\", {\n        ...spanProps,\n        className: Classes.EDITABLE_TEXT_CONTENT,\n        ref: this.refHandlers.content,\n        style: contentStyle,\n        children: hasValue ? value : this.props.placeholder\n      })]\n    });\n  }\n  componentDidMount() {\n    this.updateInputDimensions();\n  }\n  componentDidUpdate(prevProps, prevState) {\n    var _a, _b;\n    const newState = {};\n    // allow setting the value to undefined/null in controlled mode\n    if (this.props.value !== prevProps.value && (prevProps.value != null || this.props.value != null)) {\n      newState.value = this.props.value;\n    }\n    if (this.props.isEditing != null && this.props.isEditing !== prevProps.isEditing) {\n      newState.isEditing = this.props.isEditing;\n    }\n    if (this.props.disabled || this.props.disabled == null && prevProps.disabled) {\n      newState.isEditing = false;\n    }\n    this.setState(newState);\n    if (this.state.isEditing && !prevState.isEditing) {\n      (_b = (_a = this.props).onEdit) === null || _b === void 0 ? void 0 : _b.call(_a, this.state.value);\n    }\n    // updateInputDimensions is an expensive method. Call it only when the props\n    // it depends on change\n    if (this.state.value !== prevState.value || this.props.alwaysRenderInput !== prevProps.alwaysRenderInput || this.props.maxLines !== prevProps.maxLines || this.props.minLines !== prevProps.minLines || this.props.minWidth !== prevProps.minWidth || this.props.multiline !== prevProps.multiline || this.props.placeholder !== prevProps.placeholder) {\n      this.updateInputDimensions();\n    }\n  }\n  renderInput(value) {\n    const {\n      disabled,\n      maxLength,\n      multiline,\n      type,\n      placeholder,\n      customInputAttributes\n    } = this.props;\n    const props = {\n      className: Classes.EDITABLE_TEXT_INPUT,\n      disabled,\n      maxLength,\n      onBlur: this.toggleEditing,\n      onChange: this.handleTextChange,\n      onKeyDown: this.handleKeyEvent,\n      placeholder,\n      value\n    };\n    const {\n      inputHeight,\n      inputWidth\n    } = this.state;\n    if (inputHeight !== 0 && inputWidth !== 0) {\n      props.style = {\n        height: inputHeight,\n        lineHeight: !multiline && inputHeight != null ? `${inputHeight}px` : undefined,\n        width: multiline ? \"100%\" : inputWidth\n      };\n    }\n    return multiline ? _jsx(\"textarea\", {\n      ref: this.refHandlers.input,\n      ...props,\n      ...customInputAttributes\n    }) : _jsx(\"input\", {\n      ref: this.refHandlers.input,\n      type: type,\n      ...props,\n      ...customInputAttributes\n    });\n  }\n  updateInputDimensions() {\n    if (this.valueElement != null) {\n      const {\n        maxLines,\n        minLines,\n        minWidth,\n        multiline\n      } = this.props;\n      const {\n        parentElement,\n        textContent\n      } = this.valueElement;\n      let {\n        scrollHeight,\n        scrollWidth\n      } = this.valueElement;\n      const lineHeight = getLineHeight(this.valueElement);\n      // add one line to computed <span> height if text ends in newline\n      // because <span> collapses that trailing whitespace but <textarea> shows it\n      if (multiline && this.state.isEditing && /\\n$/.test(textContent !== null && textContent !== void 0 ? textContent : \"\")) {\n        scrollHeight += lineHeight;\n      }\n      if (lineHeight > 0) {\n        // line height could be 0 if the isNaN block from getLineHeight kicks in\n        scrollHeight = clamp(scrollHeight, minLines * lineHeight, maxLines * lineHeight);\n      }\n      // Chrome's input caret height misaligns text so the line-height must be larger than font-size.\n      // The computed scrollHeight must also account for a larger inherited line-height from the parent.\n      scrollHeight = Math.max(scrollHeight, getFontSize(this.valueElement) + 1, getLineHeight(parentElement));\n      // Need to add a small buffer so text does not shift prior to resizing, causing an infinite loop.\n      scrollWidth += BUFFER_WIDTH_DEFAULT;\n      this.setState({\n        inputHeight: scrollHeight,\n        inputWidth: Math.max(scrollWidth, minWidth)\n      });\n      // synchronizes the ::before pseudo-element's height while editing for Chrome 53\n      if (multiline && this.state.isEditing) {\n        this.setTimeout(() => parentElement.style.height = `${scrollHeight}px`);\n      }\n    }\n  }\n}\nEditableText.displayName = `${DISPLAYNAME_PREFIX}.EditableText`;\nEditableText.defaultProps = {\n  alwaysRenderInput: false,\n  confirmOnEnterKey: false,\n  defaultValue: \"\",\n  disabled: false,\n  maxLines: Infinity,\n  minLines: 1,\n  minWidth: 80,\n  multiline: false,\n  placeholder: \"Click to Edit\",\n  type: \"text\"\n};\nfunction getFontSize(element) {\n  const fontSize = getComputedStyle(element).fontSize;\n  return fontSize === \"\" ? 0 : parseInt(fontSize.slice(0, -2), 10);\n}\nfunction getLineHeight(element) {\n  // getComputedStyle() => 18.0001px => 18\n  let lineHeight = parseInt(getComputedStyle(element).lineHeight.slice(0, -2), 10);\n  // this check will be true if line-height is a keyword like \"normal\"\n  if (isNaN(lineHeight)) {\n    // @see http://stackoverflow.com/a/18430767/6342931\n    const line = document.createElement(\"span\");\n    line.innerHTML = \"<br>\";\n    element.appendChild(line);\n    const singleLineHeight = element.offsetHeight;\n    line.innerHTML = \"<br><br>\";\n    const doubleLineHeight = element.offsetHeight;\n    element.removeChild(line);\n    // this can return 0 in edge cases\n    lineHeight = doubleLineHeight - singleLineHeight;\n  }\n  return lineHeight;\n}\nfunction insertAtCaret(el, text) {\n  const {\n    selectionEnd,\n    selectionStart,\n    value\n  } = el;\n  if (selectionStart >= 0) {\n    const before = value.substring(0, selectionStart);\n    const after = value.substring(selectionEnd, value.length);\n    const len = text.length;\n    el.value = `${before}${text}${after}`;\n    el.selectionStart = selectionStart + len;\n    el.selectionEnd = selectionStart + len;\n  }\n}\nfunction inputSupportsSelection(input) {\n  switch (input.type) {\n    // HTMLTextAreaElement\n    case \"textarea\":\n      return true;\n    // HTMLInputElement\n    // see https://html.spec.whatwg.org/multipage/input.html#do-not-apply\n    case \"text\":\n    case \"search\":\n    case \"tel\":\n    case \"url\":\n    case \"password\":\n      return true;\n    default:\n      return false;\n  }\n}","map":{"version":3,"names":["classNames","AbstractPureComponent","Classes","DISPLAYNAME_PREFIX","clamp","BUFFER_WIDTH_DEFAULT","EditableText","constructor","props","inputElement","valueElement","refHandlers","content","spanElement","input","alwaysRenderInput","focus","state","isEditing","supportsSelection","inputSupportsSelection","length","value","setSelectionRange","selectAllOnFocus","scrollLeft","scrollWidth","cancelEditing","lastValue","setState","_b","_a","onChange","call","_d","_c","onCancel","toggleEditing","onConfirm","disabled","handleFocus","handleTextChange","event","target","handleKeyEvent","nativeEvent","isComposing","altKey","ctrlKey","metaKey","shiftKey","key","hasModifierKey","preventDefault","confirmOnEnterKey","multiline","insertAtCaret","defaultValue","inputHeight","inputWidth","render","elementRef","contentId","hasValue","classes","EDITABLE_TEXT","intentClass","intent","DISABLED","EDITABLE_TEXT_EDITING","EDITABLE_TEXT_PLACEHOLDER","MULTILINE","className","contentStyle","height","undefined","lineHeight","minWidth","tabIndex","shouldHideContents","spanProps","id","_jsxs","onFocus","ref","children","renderInput","_jsx","EDITABLE_TEXT_CONTENT","style","placeholder","componentDidMount","updateInputDimensions","componentDidUpdate","prevProps","prevState","newState","onEdit","maxLines","minLines","maxLength","type","customInputAttributes","EDITABLE_TEXT_INPUT","onBlur","onKeyDown","width","parentElement","textContent","scrollHeight","getLineHeight","test","Math","max","getFontSize","setTimeout","displayName","defaultProps","Infinity","element","fontSize","getComputedStyle","parseInt","slice","isNaN","line","document","createElement","innerHTML","appendChild","singleLineHeight","offsetHeight","doubleLineHeight","removeChild","el","text","selectionEnd","selectionStart","before","substring","after","len"],"sources":["/Users/husseingalal/Desktop/Hackathon/Elrond/frontend/node_modules/@blueprintjs/core/src/components/editable-text/editableText.tsx"],"sourcesContent":["/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport classNames from \"classnames\";\n\nimport { AbstractPureComponent, Classes } from \"../../common\";\nimport {\n    DISPLAYNAME_PREFIX,\n    type HTMLInputProps,\n    type HTMLTextAreaProps,\n    type IntentProps,\n    type Props,\n} from \"../../common/props\";\nimport { clamp } from \"../../common/utils\";\n\nexport interface EditableTextProps extends IntentProps, Props {\n    /**\n     * Custom attributes that will be passed to the underlying input (or textarea) element.\n     * This allows you to specify additional attributes like\n     * `aria-` attributes, `data-` attributes, etc.\n     */\n    customInputAttributes?: HTMLInputProps & HTMLTextAreaProps;\n    /**\n     * EXPERIMENTAL FEATURE.\n     *\n     * When true, this forces the component to _always_ render an editable input (or textarea)\n     * both when the component is focussed and unfocussed, instead of the component's default\n     * behavior of switching between a text span and a text input upon interaction.\n     *\n     * This behavior can help in certain applications where, for example, a custom right-click\n     * context menu is used to supply clipboard copy and paste functionality.\n     *\n     * @default false\n     */\n    alwaysRenderInput?: boolean;\n\n    /**\n     * If `true` and in multiline mode, the `enter` key will trigger onConfirm and `mod+enter`\n     * will insert a newline. If `false`, the key bindings are inverted such that `enter`\n     * adds a newline.\n     *\n     * @default false\n     */\n    confirmOnEnterKey?: boolean;\n\n    /** Default text value of uncontrolled input. */\n    defaultValue?: string;\n\n    /**\n     * Whether the text can be edited.\n     *\n     * @default false\n     */\n    disabled?: boolean;\n\n    /**\n     * Ref to attach to the root element rendered by this component.\n     *\n     * N.B. this may be renamed to simply `ref` in a future major version of Blueprint, when this class component is\n     * refactored into a function.\n     */\n    elementRef?: React.Ref<HTMLDivElement>;\n\n    /** Whether the component is currently being edited. */\n    isEditing?: boolean;\n\n    /** Maximum number of characters allowed. Unlimited by default. */\n    maxLength?: number;\n\n    /** Minimum width in pixels of the input, when not `multiline`. */\n    minWidth?: number;\n\n    /**\n     * Whether the component supports multiple lines of text.\n     * This prop should not be changed during the component's lifetime.\n     *\n     * @default false\n     */\n    multiline?: boolean;\n\n    /**\n     * Maximum number of lines before scrolling begins, when `multiline`.\n     */\n    maxLines?: number;\n\n    /**\n     * Minimum number of lines (essentially minimum height), when `multiline`.\n     *\n     * @default 1\n     */\n    minLines?: number;\n\n    /**\n     * Placeholder text when there is no value.\n     *\n     * @default \"Click to Edit\"\n     */\n    placeholder?: string;\n\n    /**\n     * Whether the entire text field should be selected on focus.\n     * If `false`, the cursor is placed at the end of the text.\n     * This prop is ignored on inputs with type other then text, search, url, tel and password. See https://html.spec.whatwg.org/multipage/input.html#do-not-apply for details.\n     *\n     * @default false\n     */\n    selectAllOnFocus?: boolean;\n\n    /**\n     * The type of input that should be shown, when not `multiline`.\n     */\n    type?: string;\n\n    /** Text value of controlled input. */\n    value?: string;\n\n    /** ID attribute to pass to the underlying element that contains the text contents. This allows for referencing via aria attributes */\n    contentId?: string;\n\n    /** Callback invoked when user cancels input with the `esc` key. Receives last confirmed value. */\n    onCancel?(value: string): void;\n\n    /** Callback invoked when user changes input in any way. */\n    onChange?(value: string): void;\n\n    /** Callback invoked when user confirms value with `enter` key or by blurring input. */\n    onConfirm?(value: string): void;\n\n    /** Callback invoked after the user enters edit mode. */\n    onEdit?(value: string | undefined): void;\n}\n\nexport interface EditableTextState {\n    /** Pixel height of the input, measured from span size */\n    inputHeight?: number;\n    /** Pixel width of the input, measured from span size */\n    inputWidth?: number;\n    /** Whether the value is currently being edited */\n    isEditing?: boolean;\n    /** The last confirmed value */\n    lastValue?: string;\n    /** The controlled input value, may be different from prop during editing */\n    value?: string;\n}\n\nconst BUFFER_WIDTH_DEFAULT = 5;\n\n/**\n * EditableText component.\n *\n * @see https://blueprintjs.com/docs/#core/components/editable-text\n */\nexport class EditableText extends AbstractPureComponent<EditableTextProps, EditableTextState> {\n    public static displayName = `${DISPLAYNAME_PREFIX}.EditableText`;\n\n    public static defaultProps: EditableTextProps = {\n        alwaysRenderInput: false,\n        confirmOnEnterKey: false,\n        defaultValue: \"\",\n        disabled: false,\n        maxLines: Infinity,\n        minLines: 1,\n        minWidth: 80,\n        multiline: false,\n        placeholder: \"Click to Edit\",\n        type: \"text\",\n    };\n\n    private inputElement: HTMLInputElement | HTMLTextAreaElement | null = null;\n\n    private valueElement: HTMLSpanElement | null = null;\n\n    private refHandlers = {\n        content: (spanElement: HTMLSpanElement | null) => {\n            this.valueElement = spanElement;\n        },\n        input: (input: HTMLInputElement | HTMLTextAreaElement | null) => {\n            if (input != null) {\n                this.inputElement = input;\n\n                // temporary fix for #3882\n                if (!this.props.alwaysRenderInput) {\n                    this.inputElement.focus();\n                }\n\n                if (this.state != null && this.state.isEditing) {\n                    const supportsSelection = inputSupportsSelection(input);\n                    if (supportsSelection) {\n                        const { length } = input.value;\n                        input.setSelectionRange(this.props.selectAllOnFocus ? 0 : length, length);\n                    }\n                    if (!supportsSelection || !this.props.selectAllOnFocus) {\n                        input.scrollLeft = input.scrollWidth;\n                    }\n                }\n            }\n        },\n    };\n\n    public constructor(props: EditableTextProps) {\n        super(props);\n\n        const value = props.value == null ? props.defaultValue : props.value;\n        this.state = {\n            inputHeight: 0,\n            inputWidth: 0,\n            isEditing: props.isEditing === true && props.disabled === false,\n            lastValue: value,\n            value,\n        };\n    }\n\n    public render() {\n        const { alwaysRenderInput, disabled, elementRef, multiline, contentId } = this.props;\n        const value = this.props.value ?? this.state.value;\n        const hasValue = value != null && value !== \"\";\n\n        const classes = classNames(\n            Classes.EDITABLE_TEXT,\n            Classes.intentClass(this.props.intent),\n            {\n                [Classes.DISABLED]: disabled,\n                [Classes.EDITABLE_TEXT_EDITING]: this.state.isEditing,\n                [Classes.EDITABLE_TEXT_PLACEHOLDER]: !hasValue,\n                [Classes.MULTILINE]: multiline,\n            },\n            this.props.className,\n        );\n\n        let contentStyle: React.CSSProperties;\n        if (multiline) {\n            // set height only in multiline mode when not editing\n            // otherwise we're measuring this element to determine appropriate height of text\n            contentStyle = { height: !this.state.isEditing ? this.state.inputHeight : undefined };\n        } else {\n            // minWidth only applies in single line mode (multiline == width 100%)\n            contentStyle = {\n                height: this.state.inputHeight,\n                lineHeight: this.state.inputHeight != null ? `${this.state.inputHeight}px` : undefined,\n                minWidth: this.props.minWidth,\n            };\n        }\n\n        // If we are always rendering an input, then NEVER make the container div focusable.\n        // Otherwise, make container div focusable when not editing, so it can still be tabbed\n        // to focus (when the input is rendered, it is itself focusable so container div doesn't need to be)\n        const tabIndex = alwaysRenderInput || this.state.isEditing || disabled ? undefined : 0;\n\n        // we need the contents to be rendered while editing so that we can measure their height\n        // and size the container element responsively\n        const shouldHideContents = alwaysRenderInput && !this.state.isEditing;\n\n        const spanProps: React.HTMLProps<HTMLSpanElement> = contentId != null ? { id: contentId } : {};\n\n        return (\n            <div className={classes} onFocus={this.handleFocus} tabIndex={tabIndex} ref={elementRef}>\n                {alwaysRenderInput || this.state.isEditing ? this.renderInput(value) : undefined}\n                {shouldHideContents ? undefined : (\n                    <span\n                        {...spanProps}\n                        className={Classes.EDITABLE_TEXT_CONTENT}\n                        ref={this.refHandlers.content}\n                        style={contentStyle}\n                    >\n                        {hasValue ? value : this.props.placeholder}\n                    </span>\n                )}\n            </div>\n        );\n    }\n\n    public componentDidMount() {\n        this.updateInputDimensions();\n    }\n\n    public componentDidUpdate(prevProps: EditableTextProps, prevState: EditableTextState) {\n        const newState: EditableTextState = {};\n        // allow setting the value to undefined/null in controlled mode\n        if (this.props.value !== prevProps.value && (prevProps.value != null || this.props.value != null)) {\n            newState.value = this.props.value;\n        }\n        if (this.props.isEditing != null && this.props.isEditing !== prevProps.isEditing) {\n            newState.isEditing = this.props.isEditing;\n        }\n        if (this.props.disabled || (this.props.disabled == null && prevProps.disabled)) {\n            newState.isEditing = false;\n        }\n\n        this.setState(newState);\n\n        if (this.state.isEditing && !prevState.isEditing) {\n            this.props.onEdit?.(this.state.value);\n        }\n        // updateInputDimensions is an expensive method. Call it only when the props\n        // it depends on change\n        if (\n            this.state.value !== prevState.value ||\n            this.props.alwaysRenderInput !== prevProps.alwaysRenderInput ||\n            this.props.maxLines !== prevProps.maxLines ||\n            this.props.minLines !== prevProps.minLines ||\n            this.props.minWidth !== prevProps.minWidth ||\n            this.props.multiline !== prevProps.multiline ||\n            this.props.placeholder !== prevProps.placeholder\n        ) {\n            this.updateInputDimensions();\n        }\n    }\n\n    public cancelEditing = () => {\n        const { lastValue, value } = this.state;\n        this.setState({ isEditing: false, value: lastValue });\n        if (value !== lastValue) {\n            this.props.onChange?.(lastValue!);\n        }\n        this.props.onCancel?.(lastValue!);\n    };\n\n    public toggleEditing = () => {\n        if (this.state.isEditing) {\n            const { value } = this.state;\n            this.setState({ isEditing: false, lastValue: value });\n            this.props.onConfirm?.(value!);\n        } else if (!this.props.disabled) {\n            this.setState({ isEditing: true });\n        }\n    };\n\n    private handleFocus = () => {\n        const { alwaysRenderInput, disabled, selectAllOnFocus } = this.props;\n\n        if (!disabled) {\n            this.setState({ isEditing: true });\n        }\n\n        if (alwaysRenderInput && selectAllOnFocus && this.inputElement != null) {\n            const { length } = this.inputElement.value;\n            this.inputElement.setSelectionRange(0, length);\n        }\n    };\n\n    private handleTextChange = (event: React.FormEvent<HTMLElement>) => {\n        const value = (event.target as HTMLInputElement).value;\n        // state value should be updated only when uncontrolled\n        if (this.props.value == null) {\n            this.setState({ value });\n        }\n        this.props.onChange?.(value);\n    };\n\n    private handleKeyEvent = (event: React.KeyboardEvent<HTMLElement>) => {\n        // During IME composition, Enter and Escape has special meanings that we will not override\n        if (event.nativeEvent.isComposing) {\n            return;\n        }\n\n        const { altKey, ctrlKey, metaKey, shiftKey } = event;\n        if (event.key === \"Escape\") {\n            this.cancelEditing();\n            return;\n        }\n\n        const hasModifierKey = altKey || ctrlKey || metaKey || shiftKey;\n        if (event.key === \"Enter\") {\n            // prevent browsers (Edge?) from full screening with alt + enter\n            // shift + enter adds a newline by default\n            if (altKey || shiftKey) {\n                event.preventDefault();\n            }\n\n            if (this.props.confirmOnEnterKey && this.props.multiline) {\n                if (event.target != null && hasModifierKey) {\n                    insertAtCaret(event.target as HTMLTextAreaElement, \"\\n\");\n                    this.handleTextChange(event);\n                } else {\n                    this.toggleEditing();\n                }\n            } else if (!this.props.multiline || hasModifierKey) {\n                this.toggleEditing();\n            }\n        }\n    };\n\n    private renderInput(value: string | undefined) {\n        const { disabled, maxLength, multiline, type, placeholder, customInputAttributes } = this.props;\n        const props: React.InputHTMLAttributes<HTMLInputElement | HTMLTextAreaElement> = {\n            className: Classes.EDITABLE_TEXT_INPUT,\n            disabled,\n            maxLength,\n            onBlur: this.toggleEditing,\n            onChange: this.handleTextChange,\n            onKeyDown: this.handleKeyEvent,\n            placeholder,\n            value,\n        };\n\n        const { inputHeight, inputWidth } = this.state;\n        if (inputHeight !== 0 && inputWidth !== 0) {\n            props.style = {\n                height: inputHeight,\n                lineHeight: !multiline && inputHeight != null ? `${inputHeight}px` : undefined,\n                width: multiline ? \"100%\" : inputWidth,\n            };\n        }\n\n        return multiline ? (\n            <textarea ref={this.refHandlers.input} {...props} {...customInputAttributes} />\n        ) : (\n            <input ref={this.refHandlers.input} type={type} {...props} {...customInputAttributes} />\n        );\n    }\n\n    private updateInputDimensions() {\n        if (this.valueElement != null) {\n            const { maxLines, minLines, minWidth, multiline } = this.props;\n            const { parentElement, textContent } = this.valueElement;\n            let { scrollHeight, scrollWidth } = this.valueElement;\n            const lineHeight = getLineHeight(this.valueElement);\n            // add one line to computed <span> height if text ends in newline\n            // because <span> collapses that trailing whitespace but <textarea> shows it\n            if (multiline && this.state.isEditing && /\\n$/.test(textContent ?? \"\")) {\n                scrollHeight += lineHeight;\n            }\n            if (lineHeight > 0) {\n                // line height could be 0 if the isNaN block from getLineHeight kicks in\n                scrollHeight = clamp(scrollHeight, minLines! * lineHeight, maxLines! * lineHeight);\n            }\n            // Chrome's input caret height misaligns text so the line-height must be larger than font-size.\n            // The computed scrollHeight must also account for a larger inherited line-height from the parent.\n            scrollHeight = Math.max(scrollHeight, getFontSize(this.valueElement) + 1, getLineHeight(parentElement!));\n            // Need to add a small buffer so text does not shift prior to resizing, causing an infinite loop.\n            scrollWidth += BUFFER_WIDTH_DEFAULT;\n\n            this.setState({\n                inputHeight: scrollHeight,\n                inputWidth: Math.max(scrollWidth, minWidth!),\n            });\n            // synchronizes the ::before pseudo-element's height while editing for Chrome 53\n            if (multiline && this.state.isEditing) {\n                this.setTimeout(() => (parentElement!.style.height = `${scrollHeight}px`));\n            }\n        }\n    }\n}\n\nfunction getFontSize(element: HTMLElement) {\n    const fontSize = getComputedStyle(element).fontSize;\n    return fontSize === \"\" ? 0 : parseInt(fontSize.slice(0, -2), 10);\n}\n\nfunction getLineHeight(element: HTMLElement) {\n    // getComputedStyle() => 18.0001px => 18\n    let lineHeight = parseInt(getComputedStyle(element).lineHeight.slice(0, -2), 10);\n    // this check will be true if line-height is a keyword like \"normal\"\n    if (isNaN(lineHeight)) {\n        // @see http://stackoverflow.com/a/18430767/6342931\n        const line = document.createElement(\"span\");\n        line.innerHTML = \"<br>\";\n        element.appendChild(line);\n        const singleLineHeight = element.offsetHeight;\n        line.innerHTML = \"<br><br>\";\n        const doubleLineHeight = element.offsetHeight;\n        element.removeChild(line);\n        // this can return 0 in edge cases\n        lineHeight = doubleLineHeight - singleLineHeight;\n    }\n    return lineHeight;\n}\n\nfunction insertAtCaret(el: HTMLTextAreaElement, text: string) {\n    const { selectionEnd, selectionStart, value } = el;\n    if (selectionStart >= 0) {\n        const before = value.substring(0, selectionStart);\n        const after = value.substring(selectionEnd, value.length);\n        const len = text.length;\n        el.value = `${before}${text}${after}`;\n        el.selectionStart = selectionStart + len;\n        el.selectionEnd = selectionStart + len;\n    }\n}\n\nfunction inputSupportsSelection(input: HTMLInputElement | HTMLTextAreaElement) {\n    switch (input.type) {\n        // HTMLTextAreaElement\n        case \"textarea\":\n            return true;\n        // HTMLInputElement\n        // see https://html.spec.whatwg.org/multipage/input.html#do-not-apply\n        case \"text\":\n        case \"search\":\n        case \"tel\":\n        case \"url\":\n        case \"password\":\n            return true;\n        default:\n            return false;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}