{"ast":null,"code":"import { jsx as _jsx } from \"react/jsx-runtime\";\n/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport classNames from \"classnames\";\nimport { AbstractPureComponent, Classes, Utils } from \"../../common\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\nimport { formatPercentage } from \"./sliderUtils\";\n// props that require number values, for validation\nconst NUMBER_PROPS = [\"max\", \"min\", \"stepSize\", \"tickSize\", \"value\"];\n/** Internal component for a Handle with click/drag/keyboard logic to determine a new value. */\nexport class Handle extends AbstractPureComponent {\n  constructor() {\n    super(...arguments);\n    this.state = {\n      isMoving: false\n    };\n    this.handleElement = null;\n    this.refHandlers = {\n      handle: el => this.handleElement = el\n    };\n    this.beginHandleMovement = event => {\n      document.addEventListener(\"mousemove\", this.handleHandleMovement);\n      document.addEventListener(\"mouseup\", this.endHandleMovement);\n      this.setState({\n        isMoving: true\n      });\n      this.changeValue(this.clientToValue(this.mouseEventClientOffset(event)));\n    };\n    this.beginHandleTouchMovement = event => {\n      document.addEventListener(\"touchmove\", this.handleHandleTouchMovement);\n      document.addEventListener(\"touchend\", this.endHandleTouchMovement);\n      document.addEventListener(\"touchcancel\", this.endHandleTouchMovement);\n      this.setState({\n        isMoving: true\n      });\n      this.changeValue(this.clientToValue(this.touchEventClientOffset(event)));\n    };\n    this.getStyleProperties = () => {\n      if (this.handleElement == null) {\n        return {};\n      }\n      // The handle midpoint of RangeSlider is actually shifted by a margin to\n      // be on the edge of the visible handle element. Because the midpoint\n      // calculation does not take this margin into account, we instead\n      // measure the long side (which is equal to the short side plus the\n      // margin).\n      const {\n        min = 0,\n        tickSizeRatio,\n        value,\n        vertical\n      } = this.props;\n      const {\n        handleMidpoint\n      } = this.getHandleMidpointAndOffset(this.handleElement, true);\n      const offsetRatio = (value - min) * tickSizeRatio;\n      const offsetCalc = `calc(${formatPercentage(offsetRatio)} - ${handleMidpoint}px)`;\n      return vertical ? {\n        bottom: offsetCalc\n      } : {\n        left: offsetCalc\n      };\n    };\n    this.endHandleMovement = event => {\n      this.handleMoveEndedAt(this.mouseEventClientOffset(event));\n    };\n    this.endHandleTouchMovement = event => {\n      this.handleMoveEndedAt(this.touchEventClientOffset(event));\n    };\n    this.handleMoveEndedAt = clientPixel => {\n      var _a, _b;\n      this.removeDocumentEventListeners();\n      this.setState({\n        isMoving: false\n      });\n      // always invoke onRelease; changeValue may call onChange if value is different\n      const finalValue = this.changeValue(this.clientToValue(clientPixel));\n      (_b = (_a = this.props).onRelease) === null || _b === void 0 ? void 0 : _b.call(_a, finalValue);\n    };\n    this.handleHandleMovement = event => {\n      this.handleMovedTo(this.mouseEventClientOffset(event));\n    };\n    this.handleHandleTouchMovement = event => {\n      this.handleMovedTo(this.touchEventClientOffset(event));\n    };\n    this.handleMovedTo = clientPixel => {\n      if (this.state.isMoving && !this.props.disabled) {\n        this.changeValue(this.clientToValue(clientPixel));\n      }\n    };\n    this.handleKeyDown = event => {\n      const {\n        stepSize,\n        value\n      } = this.props;\n      const direction = Utils.getArrowKeyDirection(event, [\"ArrowLeft\", \"ArrowDown\"], [\"ArrowRight\", \"ArrowUp\"]);\n      if (direction !== undefined) {\n        this.changeValue(value + stepSize * direction);\n        // this key event has been handled! prevent browser scroll on up/down\n        event.preventDefault();\n      }\n    };\n    this.handleKeyUp = event => {\n      var _a, _b;\n      if (Utils.isArrowKey(event)) {\n        (_b = (_a = this.props).onRelease) === null || _b === void 0 ? void 0 : _b.call(_a, this.props.value);\n      }\n    };\n  }\n  componentDidMount() {\n    // The first time this component renders, it has no ref to the handle and thus incorrectly centers the handle.\n    // Therefore, on the first mount, force a re-render to center the handle with the ref'd component.\n    this.forceUpdate();\n  }\n  render() {\n    const {\n      className,\n      disabled,\n      label,\n      min,\n      max,\n      value,\n      vertical,\n      htmlProps\n    } = this.props;\n    const {\n      isMoving\n    } = this.state;\n    return _jsx(\"span\", {\n      role: \"slider\",\n      tabIndex: 0,\n      ...htmlProps,\n      className: classNames(Classes.SLIDER_HANDLE, {\n        [Classes.ACTIVE]: isMoving\n      }, className),\n      onKeyDown: disabled ? undefined : this.handleKeyDown,\n      onKeyUp: disabled ? undefined : this.handleKeyUp,\n      onMouseDown: disabled ? undefined : this.beginHandleMovement,\n      onTouchStart: disabled ? undefined : this.beginHandleTouchMovement,\n      ref: this.refHandlers.handle,\n      style: this.getStyleProperties(),\n      \"aria-valuemin\": min,\n      \"aria-valuemax\": max,\n      \"aria-valuenow\": value,\n      \"aria-disabled\": disabled,\n      \"aria-orientation\": vertical ? \"vertical\" : \"horizontal\",\n      children: label == null ? null : _jsx(\"span\", {\n        className: Classes.SLIDER_LABEL,\n        children: label\n      })\n    });\n  }\n  componentWillUnmount() {\n    this.removeDocumentEventListeners();\n  }\n  /** Convert client pixel to value between min and max. */\n  clientToValue(clientPixel) {\n    const {\n      stepSize,\n      tickSize,\n      value,\n      vertical\n    } = this.props;\n    if (this.handleElement == null) {\n      return value;\n    }\n    // #1769: this logic doesn't work perfectly when the tick size is\n    // smaller than the handle size; it may be off by a tick or two.\n    const clientPixelNormalized = vertical ? window.innerHeight - clientPixel : clientPixel;\n    const handleCenterPixel = this.getHandleElementCenterPixel(this.handleElement);\n    const pixelDelta = clientPixelNormalized - handleCenterPixel;\n    if (isNaN(pixelDelta)) {\n      return value;\n    }\n    // convert pixels to range value in increments of `stepSize`\n    return value + Math.round(pixelDelta / (tickSize * stepSize)) * stepSize;\n  }\n  mouseEventClientOffset(event) {\n    return this.props.vertical ? event.clientY : event.clientX;\n  }\n  touchEventClientOffset(event) {\n    const touch = event.changedTouches[0];\n    return this.props.vertical ? touch.clientY : touch.clientX;\n  }\n  validateProps(props) {\n    for (const prop of NUMBER_PROPS) {\n      if (typeof props[prop] !== \"number\") {\n        throw new Error(`[Blueprint] <Handle> requires number value for ${prop} prop`);\n      }\n    }\n  }\n  /** Clamp value and invoke callback if it differs from current value */\n  changeValue(newValue, callback = this.props.onChange) {\n    newValue = this.clamp(newValue);\n    if (!isNaN(newValue) && this.props.value !== newValue) {\n      callback === null || callback === void 0 ? void 0 : callback(newValue);\n    }\n    return newValue;\n  }\n  /** Clamp value between min and max props */\n  clamp(value) {\n    return Utils.clamp(value, this.props.min, this.props.max);\n  }\n  getHandleElementCenterPixel(handleElement) {\n    const {\n      handleMidpoint,\n      handleOffset\n    } = this.getHandleMidpointAndOffset(handleElement);\n    return handleOffset + handleMidpoint;\n  }\n  getHandleMidpointAndOffset(handleElement, useOppositeDimension = false) {\n    if (handleElement == null) {\n      return {\n        handleMidpoint: 0,\n        handleOffset: 0\n      };\n    }\n    const {\n      vertical\n    } = this.props;\n    // N.B. element.clientHeight does not include border size.\n    // Also, element.getBoundingClientRect() is useful to get the top & left position on the page, but\n    // it fails to accurately measure element width & height inside absolutely-positioned and CSS-transformed\n    // containers like Popovers, so we use element.offsetWidth & offsetHeight instead (see https://github.com/palantir/blueprint/issues/4417).\n    const handleRect = handleElement.getBoundingClientRect();\n    handleRect.width = handleElement.offsetWidth;\n    handleRect.height = handleElement.offsetHeight;\n    const sizeKey = vertical ? useOppositeDimension ? \"width\" : \"height\" : useOppositeDimension ? \"height\" : \"width\";\n    // \"bottom\" value seems to be consistently incorrect, so explicitly\n    // calculate it using the window offset instead.\n    const handleOffset = vertical ? window.innerHeight - (handleRect.top + handleRect[sizeKey]) : handleRect.left;\n    return {\n      handleMidpoint: handleRect[sizeKey] / 2,\n      handleOffset\n    };\n  }\n  removeDocumentEventListeners() {\n    document.removeEventListener(\"mousemove\", this.handleHandleMovement);\n    document.removeEventListener(\"mouseup\", this.endHandleMovement);\n    document.removeEventListener(\"touchmove\", this.handleHandleTouchMovement);\n    document.removeEventListener(\"touchend\", this.endHandleTouchMovement);\n    document.removeEventListener(\"touchcancel\", this.endHandleTouchMovement);\n  }\n}\nHandle.displayName = `${DISPLAYNAME_PREFIX}.SliderHandle`;","map":{"version":3,"names":["classNames","AbstractPureComponent","Classes","Utils","DISPLAYNAME_PREFIX","formatPercentage","NUMBER_PROPS","Handle","constructor","state","isMoving","handleElement","refHandlers","handle","el","beginHandleMovement","event","document","addEventListener","handleHandleMovement","endHandleMovement","setState","changeValue","clientToValue","mouseEventClientOffset","beginHandleTouchMovement","handleHandleTouchMovement","endHandleTouchMovement","touchEventClientOffset","getStyleProperties","min","tickSizeRatio","value","vertical","props","handleMidpoint","getHandleMidpointAndOffset","offsetRatio","offsetCalc","bottom","left","handleMoveEndedAt","clientPixel","removeDocumentEventListeners","finalValue","_b","_a","onRelease","call","handleMovedTo","disabled","handleKeyDown","stepSize","direction","getArrowKeyDirection","undefined","preventDefault","handleKeyUp","isArrowKey","componentDidMount","forceUpdate","render","className","label","max","htmlProps","_jsx","role","tabIndex","SLIDER_HANDLE","ACTIVE","onKeyDown","onKeyUp","onMouseDown","onTouchStart","ref","style","children","SLIDER_LABEL","componentWillUnmount","tickSize","clientPixelNormalized","window","innerHeight","handleCenterPixel","getHandleElementCenterPixel","pixelDelta","isNaN","Math","round","clientY","clientX","touch","changedTouches","validateProps","prop","Error","newValue","callback","onChange","clamp","handleOffset","useOppositeDimension","handleRect","getBoundingClientRect","width","offsetWidth","height","offsetHeight","sizeKey","top","removeEventListener","displayName"],"sources":["/Users/husseingalal/Desktop/Hackathon/Elrond/frontend/node_modules/@blueprintjs/core/src/components/slider/handle.tsx"],"sourcesContent":["/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport classNames from \"classnames\";\n\nimport { AbstractPureComponent, Classes, Utils } from \"../../common\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\n\nimport type { HandleProps } from \"./handleProps\";\nimport { formatPercentage } from \"./sliderUtils\";\n\n/**\n * Props for the internal <Handle> component needs some additional info from the parent Slider.\n */\nexport interface InternalHandleProps extends HandleProps {\n    disabled?: boolean;\n    label: React.JSX.Element | string | undefined;\n    max: number;\n    min: number;\n    stepSize: number;\n    tickSize: number;\n    tickSizeRatio: number;\n    vertical: boolean;\n}\n\nexport interface HandleState {\n    /** whether slider handle is currently being dragged */\n    isMoving?: boolean;\n}\n\n// props that require number values, for validation\nconst NUMBER_PROPS = [\"max\", \"min\", \"stepSize\", \"tickSize\", \"value\"] satisfies Array<keyof InternalHandleProps>;\n\n/** Internal component for a Handle with click/drag/keyboard logic to determine a new value. */\nexport class Handle extends AbstractPureComponent<InternalHandleProps, HandleState> {\n    public static displayName = `${DISPLAYNAME_PREFIX}.SliderHandle`;\n\n    public state = {\n        isMoving: false,\n    };\n\n    private handleElement: HTMLElement | null = null;\n\n    private refHandlers = {\n        handle: (el: HTMLSpanElement) => (this.handleElement = el),\n    };\n\n    public componentDidMount() {\n        // The first time this component renders, it has no ref to the handle and thus incorrectly centers the handle.\n        // Therefore, on the first mount, force a re-render to center the handle with the ref'd component.\n        this.forceUpdate();\n    }\n\n    public render() {\n        const { className, disabled, label, min, max, value, vertical, htmlProps } = this.props;\n        const { isMoving } = this.state;\n\n        return (\n            <span\n                role=\"slider\"\n                tabIndex={0}\n                {...htmlProps}\n                className={classNames(Classes.SLIDER_HANDLE, { [Classes.ACTIVE]: isMoving }, className)}\n                onKeyDown={disabled ? undefined : this.handleKeyDown}\n                onKeyUp={disabled ? undefined : this.handleKeyUp}\n                onMouseDown={disabled ? undefined : this.beginHandleMovement}\n                onTouchStart={disabled ? undefined : this.beginHandleTouchMovement}\n                ref={this.refHandlers.handle}\n                style={this.getStyleProperties()}\n                aria-valuemin={min}\n                aria-valuemax={max}\n                aria-valuenow={value}\n                aria-disabled={disabled}\n                aria-orientation={vertical ? \"vertical\" : \"horizontal\"}\n            >\n                {label == null ? null : <span className={Classes.SLIDER_LABEL}>{label}</span>}\n            </span>\n        );\n    }\n\n    public componentWillUnmount() {\n        this.removeDocumentEventListeners();\n    }\n\n    /** Convert client pixel to value between min and max. */\n    public clientToValue(clientPixel: number) {\n        const { stepSize, tickSize, value, vertical } = this.props;\n        if (this.handleElement == null) {\n            return value;\n        }\n\n        // #1769: this logic doesn't work perfectly when the tick size is\n        // smaller than the handle size; it may be off by a tick or two.\n        const clientPixelNormalized = vertical ? window.innerHeight - clientPixel : clientPixel;\n        const handleCenterPixel = this.getHandleElementCenterPixel(this.handleElement);\n        const pixelDelta = clientPixelNormalized - handleCenterPixel;\n\n        if (isNaN(pixelDelta)) {\n            return value;\n        }\n        // convert pixels to range value in increments of `stepSize`\n        return value + Math.round(pixelDelta / (tickSize * stepSize)) * stepSize;\n    }\n\n    public mouseEventClientOffset(event: MouseEvent | React.MouseEvent<HTMLElement>) {\n        return this.props.vertical ? event.clientY : event.clientX;\n    }\n\n    public touchEventClientOffset(event: TouchEvent | React.TouchEvent<HTMLElement>) {\n        const touch = event.changedTouches[0];\n        return this.props.vertical ? touch.clientY : touch.clientX;\n    }\n\n    public beginHandleMovement = (event: MouseEvent | React.MouseEvent<HTMLElement>) => {\n        document.addEventListener(\"mousemove\", this.handleHandleMovement);\n        document.addEventListener(\"mouseup\", this.endHandleMovement);\n        this.setState({ isMoving: true });\n        this.changeValue(this.clientToValue(this.mouseEventClientOffset(event)));\n    };\n\n    public beginHandleTouchMovement = (event: TouchEvent | React.TouchEvent<HTMLElement>) => {\n        document.addEventListener(\"touchmove\", this.handleHandleTouchMovement);\n        document.addEventListener(\"touchend\", this.endHandleTouchMovement);\n        document.addEventListener(\"touchcancel\", this.endHandleTouchMovement);\n        this.setState({ isMoving: true });\n        this.changeValue(this.clientToValue(this.touchEventClientOffset(event)));\n    };\n\n    protected validateProps(props: InternalHandleProps) {\n        for (const prop of NUMBER_PROPS) {\n            if (typeof (props as any)[prop] !== \"number\") {\n                throw new Error(`[Blueprint] <Handle> requires number value for ${prop} prop`);\n            }\n        }\n    }\n\n    private getStyleProperties = (): React.CSSProperties => {\n        if (this.handleElement == null) {\n            return {};\n        }\n\n        // The handle midpoint of RangeSlider is actually shifted by a margin to\n        // be on the edge of the visible handle element. Because the midpoint\n        // calculation does not take this margin into account, we instead\n        // measure the long side (which is equal to the short side plus the\n        // margin).\n\n        const { min = 0, tickSizeRatio, value, vertical } = this.props;\n        const { handleMidpoint } = this.getHandleMidpointAndOffset(this.handleElement, true);\n        const offsetRatio = (value - min) * tickSizeRatio;\n        const offsetCalc = `calc(${formatPercentage(offsetRatio)} - ${handleMidpoint}px)`;\n        return vertical ? { bottom: offsetCalc } : { left: offsetCalc };\n    };\n\n    private endHandleMovement = (event: MouseEvent) => {\n        this.handleMoveEndedAt(this.mouseEventClientOffset(event));\n    };\n\n    private endHandleTouchMovement = (event: TouchEvent) => {\n        this.handleMoveEndedAt(this.touchEventClientOffset(event));\n    };\n\n    private handleMoveEndedAt = (clientPixel: number) => {\n        this.removeDocumentEventListeners();\n        this.setState({ isMoving: false });\n        // always invoke onRelease; changeValue may call onChange if value is different\n        const finalValue = this.changeValue(this.clientToValue(clientPixel));\n        this.props.onRelease?.(finalValue);\n    };\n\n    private handleHandleMovement = (event: MouseEvent) => {\n        this.handleMovedTo(this.mouseEventClientOffset(event));\n    };\n\n    private handleHandleTouchMovement = (event: TouchEvent) => {\n        this.handleMovedTo(this.touchEventClientOffset(event));\n    };\n\n    private handleMovedTo = (clientPixel: number) => {\n        if (this.state.isMoving && !this.props.disabled) {\n            this.changeValue(this.clientToValue(clientPixel));\n        }\n    };\n\n    private handleKeyDown = (event: React.KeyboardEvent<HTMLSpanElement>) => {\n        const { stepSize, value } = this.props;\n        const direction = Utils.getArrowKeyDirection(event, [\"ArrowLeft\", \"ArrowDown\"], [\"ArrowRight\", \"ArrowUp\"]);\n        if (direction !== undefined) {\n            this.changeValue(value + stepSize * direction);\n            // this key event has been handled! prevent browser scroll on up/down\n            event.preventDefault();\n        }\n    };\n\n    private handleKeyUp = (event: React.KeyboardEvent<HTMLSpanElement>) => {\n        if (Utils.isArrowKey(event)) {\n            this.props.onRelease?.(this.props.value);\n        }\n    };\n\n    /** Clamp value and invoke callback if it differs from current value */\n    private changeValue(newValue: number, callback = this.props.onChange) {\n        newValue = this.clamp(newValue);\n        if (!isNaN(newValue) && this.props.value !== newValue) {\n            callback?.(newValue);\n        }\n        return newValue;\n    }\n\n    /** Clamp value between min and max props */\n    private clamp(value: number) {\n        return Utils.clamp(value, this.props.min, this.props.max);\n    }\n\n    private getHandleElementCenterPixel(handleElement: HTMLElement) {\n        const { handleMidpoint, handleOffset } = this.getHandleMidpointAndOffset(handleElement);\n        return handleOffset + handleMidpoint;\n    }\n\n    private getHandleMidpointAndOffset(handleElement: HTMLElement, useOppositeDimension = false) {\n        if (handleElement == null) {\n            return { handleMidpoint: 0, handleOffset: 0 };\n        }\n\n        const { vertical } = this.props;\n\n        // N.B. element.clientHeight does not include border size.\n        // Also, element.getBoundingClientRect() is useful to get the top & left position on the page, but\n        // it fails to accurately measure element width & height inside absolutely-positioned and CSS-transformed\n        // containers like Popovers, so we use element.offsetWidth & offsetHeight instead (see https://github.com/palantir/blueprint/issues/4417).\n        const handleRect: DOMRect = handleElement.getBoundingClientRect();\n        handleRect.width = handleElement.offsetWidth;\n        handleRect.height = handleElement.offsetHeight;\n\n        const sizeKey = vertical\n            ? useOppositeDimension\n                ? \"width\"\n                : \"height\"\n            : useOppositeDimension\n              ? \"height\"\n              : \"width\";\n\n        // \"bottom\" value seems to be consistently incorrect, so explicitly\n        // calculate it using the window offset instead.\n        const handleOffset = vertical ? window.innerHeight - (handleRect.top + handleRect[sizeKey]) : handleRect.left;\n\n        return { handleMidpoint: handleRect[sizeKey] / 2, handleOffset };\n    }\n\n    private removeDocumentEventListeners() {\n        document.removeEventListener(\"mousemove\", this.handleHandleMovement);\n        document.removeEventListener(\"mouseup\", this.endHandleMovement);\n        document.removeEventListener(\"touchmove\", this.handleHandleTouchMovement);\n        document.removeEventListener(\"touchend\", this.endHandleTouchMovement);\n        document.removeEventListener(\"touchcancel\", this.endHandleTouchMovement);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}