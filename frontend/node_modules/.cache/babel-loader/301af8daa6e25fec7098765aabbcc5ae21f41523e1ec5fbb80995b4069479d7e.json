{"ast":null,"code":"/*\n * Copyright 2018 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { clamp } from \"../../common/utils\";\n/** Returns the `decimal` number separator based on locale */\nfunction getDecimalSeparator(locale) {\n  const testNumber = 1.9;\n  const testText = testNumber.toLocaleString(locale);\n  const one = 1 .toLocaleString(locale);\n  const nine = 9 .toLocaleString(locale);\n  const pattern = `${one}(.+)${nine}`;\n  const result = new RegExp(pattern).exec(testText);\n  return result && result[1] || \".\";\n}\nexport function toLocaleString(num, locale = \"en-US\") {\n  // HACKHACK: roundingPriority is not supported yet in TypeScript https://github.com/microsoft/TypeScript/issues/43336\n  return sanitizeNumericInput(num.toLocaleString(locale, {\n    roundingPriority: \"morePrecision\"\n  }), locale);\n}\nexport function clampValue(value, min, max) {\n  // defaultProps won't work if the user passes in null, so just default\n  // to +/- infinity here instead, as a catch-all.\n  const adjustedMin = min != null ? min : -Infinity;\n  const adjustedMax = max != null ? max : Infinity;\n  return clamp(value, adjustedMin, adjustedMax);\n}\nexport function getValueOrEmptyValue(value = \"\") {\n  return value.toString();\n}\n/** Transform the localized character (ex. \"\") to a javascript recognizable string number (ex. \"10.99\")  */\nfunction transformLocalizedNumberToStringNumber(character, locale) {\n  const charactersMap = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(value => value.toLocaleString(locale));\n  const jsNumber = charactersMap.indexOf(character);\n  if (jsNumber !== -1) {\n    return jsNumber;\n  } else {\n    return character;\n  }\n}\n/** Transforms the localized number (ex. \"10,99\") to a javascript recognizable string number (ex. \"10.99\")  */\nexport function parseStringToStringNumber(value, locale) {\n  const valueAsString = \"\" + value;\n  if (parseFloat(valueAsString).toString() === value.toString()) {\n    return value.toString();\n  }\n  if (locale !== undefined) {\n    const decimalSeparator = getDecimalSeparator(locale);\n    const sanitizedString = sanitizeNumericInput(valueAsString, locale);\n    return sanitizedString.split(\"\").map(character => transformLocalizedNumberToStringNumber(character, locale)).join(\"\").replace(decimalSeparator, \".\");\n  }\n  return value.toString();\n}\n/** Returns `true` if the string represents a valid numeric value, like \"1e6\". */\nexport function isValueNumeric(value, locale) {\n  // checking if a string is numeric in Typescript is a big pain, because\n  // we can't simply toss a string parameter to isFinite. below is the\n  // essential approach that jQuery uses, which involves subtracting a\n  // parsed numeric value from the string representation of the value. we\n  // need to cast the value to the `any` type to allow this operation\n  // between dissimilar types.\n  const stringToStringNumber = parseStringToStringNumber(value, locale);\n  return value != null && stringToStringNumber - parseFloat(stringToStringNumber) + 1 >= 0;\n}\nexport function isValidNumericKeyboardEvent(e, locale) {\n  // unit tests may not include e.key. don't bother disabling those events.\n  if (e.key == null) {\n    return true;\n  }\n  // allow modified key strokes that may involve letters and other\n  // non-numeric/invalid characters (Cmd + A, Cmd + C, Cmd + V, Cmd + X).\n  if (e.ctrlKey || e.altKey || e.metaKey) {\n    return true;\n  }\n  // keys that print a single character when pressed have a `key` name of\n  // length 1. every other key has a longer `key` name (e.g. \"Backspace\",\n  // \"ArrowUp\", \"Shift\"). since none of those keys can print a character\n  // to the field--and since they may have important native behaviors\n  // beyond printing a character--we don't want to disable their effects.\n  const isSingleCharKey = e.key.length === 1;\n  if (!isSingleCharKey) {\n    return true;\n  }\n  // now we can simply check that the single character that wants to be printed\n  // is a floating-point number character that we're allowed to print.\n  return isFloatingPointNumericCharacter(e.key, locale);\n}\n/**\n * A regex that matches a string of length 1 (i.e. a standalone character)\n * if and only if it is a floating-point number character as defined by W3C:\n * https://www.w3.org/TR/2012/WD-html-markup-20120329/datatypes.html#common.data.float\n *\n * Floating-point number characters are the only characters that can be\n * printed within a default input[type=\"number\"]. This component should\n * behave the same way when this.props.allowNumericCharactersOnly = true.\n * See here for the input[type=\"number\"].value spec:\n * https://www.w3.org/TR/2012/WD-html-markup-20120329/input.number.html#input.number.attrs.value\n */\nfunction isFloatingPointNumericCharacter(character, locale) {\n  if (locale !== undefined) {\n    const decimalSeparator = getDecimalSeparator(locale).replace(\".\", \"\\\\.\");\n    const numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(value => value.toLocaleString(locale)).join(\"\");\n    const localeFloatingPointNumericCharacterRegex = new RegExp(\"^[Ee\" + numbers + \"\\\\+\\\\-\" + decimalSeparator + \"]$\");\n    return localeFloatingPointNumericCharacterRegex.test(character);\n  } else {\n    const floatingPointNumericCharacterRegex = /^[Ee0-9\\+\\-\\.]$/;\n    return floatingPointNumericCharacterRegex.test(character);\n  }\n}\n/**\n * Round the value to have _up to_ the specified maximum precision.\n *\n * This differs from `toFixed(5)` in that trailing zeroes are not added on\n * more precise values, resulting in shorter strings.\n */\nexport function toMaxPrecision(value, maxPrecision) {\n  // round the value to have the specified maximum precision (toFixed is the wrong choice,\n  // because it would show trailing zeros in the decimal part out to the specified precision)\n  // source: http://stackoverflow.com/a/18358056/5199574\n  const scaleFactor = Math.pow(10, maxPrecision);\n  return Math.round(value * scaleFactor) / scaleFactor;\n}\n/**\n * Convert Japanese full-width numbers, e.g. '５', to ASCII, e.g. '5'\n * This should be called before performing any other numeric string input validation.\n */\nfunction convertFullWidthNumbersToAscii(value) {\n  return value.replace(/[\\uFF10-\\uFF19]/g, m => String.fromCharCode(m.charCodeAt(0) - 0xfee0));\n}\n/**\n * Convert full-width (Japanese) numbers to ASCII, and strip all characters that are not valid floating-point numeric characters\n */\nexport function sanitizeNumericInput(value, locale) {\n  const valueChars = convertFullWidthNumbersToAscii(value).split(\"\");\n  const sanitizedValueChars = valueChars.filter(valueChar => isFloatingPointNumericCharacter(valueChar, locale));\n  return sanitizedValueChars.join(\"\");\n}","map":{"version":3,"names":["clamp","getDecimalSeparator","locale","testNumber","testText","toLocaleString","one","nine","pattern","result","RegExp","exec","num","sanitizeNumericInput","roundingPriority","clampValue","value","min","max","adjustedMin","Infinity","adjustedMax","getValueOrEmptyValue","toString","transformLocalizedNumberToStringNumber","character","charactersMap","map","jsNumber","indexOf","parseStringToStringNumber","valueAsString","parseFloat","undefined","decimalSeparator","sanitizedString","split","join","replace","isValueNumeric","stringToStringNumber","isValidNumericKeyboardEvent","e","key","ctrlKey","altKey","metaKey","isSingleCharKey","length","isFloatingPointNumericCharacter","numbers","localeFloatingPointNumericCharacterRegex","test","floatingPointNumericCharacterRegex","toMaxPrecision","maxPrecision","scaleFactor","Math","pow","round","convertFullWidthNumbersToAscii","m","String","fromCharCode","charCodeAt","valueChars","sanitizedValueChars","filter","valueChar"],"sources":["/Users/husseingalal/Desktop/Hackathon/Elrond/frontend/node_modules/@blueprintjs/core/src/components/forms/numericInputUtils.ts"],"sourcesContent":["/*\n * Copyright 2018 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { clamp } from \"../../common/utils\";\n\n/** Returns the `decimal` number separator based on locale */\nfunction getDecimalSeparator(locale: string) {\n    const testNumber = 1.9;\n    const testText = testNumber.toLocaleString(locale);\n    const one = (1).toLocaleString(locale);\n    const nine = (9).toLocaleString(locale);\n    const pattern = `${one}(.+)${nine}`;\n\n    const result = new RegExp(pattern).exec(testText);\n\n    return (result && result[1]) || \".\";\n}\n\nexport function toLocaleString(num: number, locale: string = \"en-US\") {\n    // HACKHACK: roundingPriority is not supported yet in TypeScript https://github.com/microsoft/TypeScript/issues/43336\n    return sanitizeNumericInput(num.toLocaleString(locale, { roundingPriority: \"morePrecision\" } as any), locale);\n}\n\nexport function clampValue(value: number, min?: number, max?: number) {\n    // defaultProps won't work if the user passes in null, so just default\n    // to +/- infinity here instead, as a catch-all.\n    const adjustedMin = min != null ? min : -Infinity;\n    const adjustedMax = max != null ? max : Infinity;\n    return clamp(value, adjustedMin, adjustedMax);\n}\n\nexport function getValueOrEmptyValue(value: number | string = \"\") {\n    return value.toString();\n}\n\n/** Transform the localized character (ex. \"\") to a javascript recognizable string number (ex. \"10.99\")  */\nfunction transformLocalizedNumberToStringNumber(character: string, locale: string) {\n    const charactersMap = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(value => value.toLocaleString(locale));\n    const jsNumber = charactersMap.indexOf(character);\n\n    if (jsNumber !== -1) {\n        return jsNumber;\n    } else {\n        return character;\n    }\n}\n\n/** Transforms the localized number (ex. \"10,99\") to a javascript recognizable string number (ex. \"10.99\")  */\nexport function parseStringToStringNumber(value: number | string, locale: string | undefined): string {\n    const valueAsString = \"\" + value;\n    if (parseFloat(valueAsString).toString() === value.toString()) {\n        return value.toString();\n    }\n\n    if (locale !== undefined) {\n        const decimalSeparator = getDecimalSeparator(locale);\n        const sanitizedString = sanitizeNumericInput(valueAsString, locale);\n\n        return sanitizedString\n            .split(\"\")\n            .map(character => transformLocalizedNumberToStringNumber(character, locale))\n            .join(\"\")\n            .replace(decimalSeparator, \".\");\n    }\n\n    return value.toString();\n}\n\n/** Returns `true` if the string represents a valid numeric value, like \"1e6\". */\nexport function isValueNumeric(value: string, locale: string | undefined) {\n    // checking if a string is numeric in Typescript is a big pain, because\n    // we can't simply toss a string parameter to isFinite. below is the\n    // essential approach that jQuery uses, which involves subtracting a\n    // parsed numeric value from the string representation of the value. we\n    // need to cast the value to the `any` type to allow this operation\n    // between dissimilar types.\n    const stringToStringNumber = parseStringToStringNumber(value, locale);\n    return value != null && (stringToStringNumber as any) - parseFloat(stringToStringNumber) + 1 >= 0;\n}\n\nexport function isValidNumericKeyboardEvent(e: React.KeyboardEvent, locale: string | undefined) {\n    // unit tests may not include e.key. don't bother disabling those events.\n    if (e.key == null) {\n        return true;\n    }\n\n    // allow modified key strokes that may involve letters and other\n    // non-numeric/invalid characters (Cmd + A, Cmd + C, Cmd + V, Cmd + X).\n    if (e.ctrlKey || e.altKey || e.metaKey) {\n        return true;\n    }\n\n    // keys that print a single character when pressed have a `key` name of\n    // length 1. every other key has a longer `key` name (e.g. \"Backspace\",\n    // \"ArrowUp\", \"Shift\"). since none of those keys can print a character\n    // to the field--and since they may have important native behaviors\n    // beyond printing a character--we don't want to disable their effects.\n    const isSingleCharKey = e.key.length === 1;\n    if (!isSingleCharKey) {\n        return true;\n    }\n\n    // now we can simply check that the single character that wants to be printed\n    // is a floating-point number character that we're allowed to print.\n    return isFloatingPointNumericCharacter(e.key, locale);\n}\n\n/**\n * A regex that matches a string of length 1 (i.e. a standalone character)\n * if and only if it is a floating-point number character as defined by W3C:\n * https://www.w3.org/TR/2012/WD-html-markup-20120329/datatypes.html#common.data.float\n *\n * Floating-point number characters are the only characters that can be\n * printed within a default input[type=\"number\"]. This component should\n * behave the same way when this.props.allowNumericCharactersOnly = true.\n * See here for the input[type=\"number\"].value spec:\n * https://www.w3.org/TR/2012/WD-html-markup-20120329/input.number.html#input.number.attrs.value\n */\nfunction isFloatingPointNumericCharacter(character: string, locale: string | undefined) {\n    if (locale !== undefined) {\n        const decimalSeparator = getDecimalSeparator(locale).replace(\".\", \"\\\\.\");\n        const numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(value => value.toLocaleString(locale)).join(\"\");\n        const localeFloatingPointNumericCharacterRegex = new RegExp(\n            \"^[Ee\" + numbers + \"\\\\+\\\\-\" + decimalSeparator + \"]$\",\n        );\n\n        return localeFloatingPointNumericCharacterRegex.test(character);\n    } else {\n        const floatingPointNumericCharacterRegex = /^[Ee0-9\\+\\-\\.]$/;\n\n        return floatingPointNumericCharacterRegex.test(character);\n    }\n}\n\n/**\n * Round the value to have _up to_ the specified maximum precision.\n *\n * This differs from `toFixed(5)` in that trailing zeroes are not added on\n * more precise values, resulting in shorter strings.\n */\nexport function toMaxPrecision(value: number, maxPrecision: number) {\n    // round the value to have the specified maximum precision (toFixed is the wrong choice,\n    // because it would show trailing zeros in the decimal part out to the specified precision)\n    // source: http://stackoverflow.com/a/18358056/5199574\n    const scaleFactor = Math.pow(10, maxPrecision);\n    return Math.round(value * scaleFactor) / scaleFactor;\n}\n\n/**\n * Convert Japanese full-width numbers, e.g. '５', to ASCII, e.g. '5'\n * This should be called before performing any other numeric string input validation.\n */\nfunction convertFullWidthNumbersToAscii(value: string) {\n    return value.replace(/[\\uFF10-\\uFF19]/g, m => String.fromCharCode(m.charCodeAt(0) - 0xfee0));\n}\n\n/**\n * Convert full-width (Japanese) numbers to ASCII, and strip all characters that are not valid floating-point numeric characters\n */\nexport function sanitizeNumericInput(value: string, locale: string | undefined) {\n    const valueChars = convertFullWidthNumbersToAscii(value).split(\"\");\n    const sanitizedValueChars = valueChars.filter(valueChar => isFloatingPointNumericCharacter(valueChar, locale));\n\n    return sanitizedValueChars.join(\"\");\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}