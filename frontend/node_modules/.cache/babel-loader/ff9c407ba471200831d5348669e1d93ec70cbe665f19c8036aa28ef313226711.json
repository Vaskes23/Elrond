{"ast":null,"code":"/*\n * Copyright 2021 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { useCallback, useContext, useEffect, useMemo } from \"react\";\nimport { HOTKEYS_PROVIDER_NOT_FOUND } from \"../../common/errors\";\nimport { elementIsTextInput } from \"../../common/utils/domUtils\";\nimport { comboMatches, getKeyCombo, parseKeyCombo } from \"../../components/hotkeys/hotkeyParser\";\nimport { HotkeysContext } from \"../../context\";\n/**\n * React hook to register global and local hotkeys for a component.\n *\n * @see https://blueprintjs.com/docs/#core/hooks/use-hotkeys\n * @param keys list of hotkeys to configure\n * @param options hook options\n */\nexport function useHotkeys(keys, options = {}) {\n  const {\n    document = getDefaultDocument(),\n    showDialogKeyCombo = \"?\"\n  } = options;\n  const localKeys = useMemo(() => keys.filter(k => !k.global).map(k => ({\n    combo: parseKeyCombo(k.combo),\n    config: k\n  })), [keys]);\n  const globalKeys = useMemo(() => keys.filter(k => k.global).map(k => ({\n    combo: parseKeyCombo(k.combo),\n    config: k\n  })), [keys]);\n  // register keys with global context\n  const [state, dispatch] = useContext(HotkeysContext);\n  useEffect(() => {\n    if (!state.hasProvider) {\n      console.warn(HOTKEYS_PROVIDER_NOT_FOUND);\n    }\n  }, [state.hasProvider]);\n  // we can still bind the hotkeys if there is no HotkeysProvider, they just won't show up in the dialog\n  useEffect(() => {\n    const payload = [...globalKeys.map(k => k.config), ...localKeys.map(k => k.config)];\n    dispatch({\n      payload,\n      type: \"ADD_HOTKEYS\"\n    });\n    return () => dispatch({\n      payload,\n      type: \"REMOVE_HOTKEYS\"\n    });\n  }, [dispatch, globalKeys, localKeys]);\n  const invokeNamedCallbackIfComboRecognized = useCallback((global, combo, callbackName, e) => {\n    var _a, _b;\n    const isTextInput = elementIsTextInput(e.target);\n    for (const key of global ? globalKeys : localKeys) {\n      const {\n        allowInInput = false,\n        disabled = false,\n        preventDefault = false,\n        stopPropagation = false\n      } = key.config;\n      const shouldIgnore = isTextInput && !allowInInput || disabled;\n      if (!shouldIgnore && comboMatches(key.combo, combo)) {\n        if (preventDefault) {\n          e.preventDefault();\n        }\n        if (stopPropagation) {\n          // set a flag just for unit testing. not meant to be referenced in feature work.\n          e.isPropagationStopped = true;\n          e.stopPropagation();\n        }\n        (_b = (_a = key.config)[callbackName]) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n      }\n    }\n  }, [globalKeys, localKeys]);\n  const handleGlobalKeyDown = useCallback(e => {\n    // special case for global keydown: if '?' is pressed, open the hotkeys dialog\n    const combo = getKeyCombo(e);\n    const isTextInput = elementIsTextInput(e.target);\n    if (!isTextInput && comboMatches(parseKeyCombo(showDialogKeyCombo), combo)) {\n      dispatch({\n        type: \"OPEN_DIALOG\"\n      });\n    } else {\n      invokeNamedCallbackIfComboRecognized(true, getKeyCombo(e), \"onKeyDown\", e);\n    }\n  }, [dispatch, invokeNamedCallbackIfComboRecognized, showDialogKeyCombo]);\n  const handleGlobalKeyUp = useCallback(e => invokeNamedCallbackIfComboRecognized(true, getKeyCombo(e), \"onKeyUp\", e), [invokeNamedCallbackIfComboRecognized]);\n  const handleLocalKeyDown = useCallback(e => invokeNamedCallbackIfComboRecognized(false, getKeyCombo(e.nativeEvent), \"onKeyDown\", e.nativeEvent), [invokeNamedCallbackIfComboRecognized]);\n  const handleLocalKeyUp = useCallback(e => invokeNamedCallbackIfComboRecognized(false, getKeyCombo(e.nativeEvent), \"onKeyUp\", e.nativeEvent), [invokeNamedCallbackIfComboRecognized]);\n  useEffect(() => {\n    // document is guaranteed to be defined inside effects\n    document.addEventListener(\"keydown\", handleGlobalKeyDown);\n    document.addEventListener(\"keyup\", handleGlobalKeyUp);\n    return () => {\n      document.removeEventListener(\"keydown\", handleGlobalKeyDown);\n      document.removeEventListener(\"keyup\", handleGlobalKeyUp);\n    };\n  }, [document, handleGlobalKeyDown, handleGlobalKeyUp]);\n  return {\n    handleKeyDown: handleLocalKeyDown,\n    handleKeyUp: handleLocalKeyUp\n  };\n}\nfunction getDefaultDocument() {\n  if (typeof window === \"undefined\") {\n    return undefined;\n  }\n  return window.document;\n}","map":{"version":3,"names":["useCallback","useContext","useEffect","useMemo","HOTKEYS_PROVIDER_NOT_FOUND","elementIsTextInput","comboMatches","getKeyCombo","parseKeyCombo","HotkeysContext","useHotkeys","keys","options","document","getDefaultDocument","showDialogKeyCombo","localKeys","filter","k","global","map","combo","config","globalKeys","state","dispatch","hasProvider","console","warn","payload","type","invokeNamedCallbackIfComboRecognized","callbackName","e","isTextInput","target","key","allowInInput","disabled","preventDefault","stopPropagation","shouldIgnore","isPropagationStopped","_b","_a","call","handleGlobalKeyDown","handleGlobalKeyUp","handleLocalKeyDown","nativeEvent","handleLocalKeyUp","addEventListener","removeEventListener","handleKeyDown","handleKeyUp","window","undefined"],"sources":["/Users/husseingalal/Desktop/Hackathon/Elrond/frontend/node_modules/@blueprintjs/core/src/hooks/hotkeys/useHotkeys.ts"],"sourcesContent":["/*\n * Copyright 2021 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { useCallback, useContext, useEffect, useMemo } from \"react\";\n\nimport { HOTKEYS_PROVIDER_NOT_FOUND } from \"../../common/errors\";\nimport { elementIsTextInput } from \"../../common/utils/domUtils\";\nimport { comboMatches, getKeyCombo, type KeyCombo, parseKeyCombo } from \"../../components/hotkeys/hotkeyParser\";\nimport { HotkeysContext } from \"../../context\";\n\nimport type { HotkeyConfig } from \"./hotkeyConfig\";\n\nexport interface UseHotkeysOptions {\n    /**\n     * A custom document to reference when binding global event handlers.\n     * This can be useful when using iframes in an application.\n     *\n     * @default window.document\n     */\n    document?: Document;\n\n    /**\n     * The key combo which will trigger the hotkeys dialog to open.\n     *\n     * @default \"?\"\n     */\n    showDialogKeyCombo?: string;\n}\n\nexport interface UseHotkeysReturnValue {\n    handleKeyDown: React.KeyboardEventHandler<HTMLElement>;\n    handleKeyUp: React.KeyboardEventHandler<HTMLElement>;\n}\n\n/**\n * React hook to register global and local hotkeys for a component.\n *\n * @see https://blueprintjs.com/docs/#core/hooks/use-hotkeys\n * @param keys list of hotkeys to configure\n * @param options hook options\n */\nexport function useHotkeys(keys: readonly HotkeyConfig[], options: UseHotkeysOptions = {}): UseHotkeysReturnValue {\n    const { document = getDefaultDocument(), showDialogKeyCombo = \"?\" } = options;\n    const localKeys = useMemo(\n        () =>\n            keys\n                .filter(k => !k.global)\n                .map(k => ({\n                    combo: parseKeyCombo(k.combo),\n                    config: k,\n                })),\n        [keys],\n    );\n    const globalKeys = useMemo(\n        () =>\n            keys\n                .filter(k => k.global)\n                .map(k => ({\n                    combo: parseKeyCombo(k.combo),\n                    config: k,\n                })),\n        [keys],\n    );\n\n    // register keys with global context\n    const [state, dispatch] = useContext(HotkeysContext);\n\n    useEffect(() => {\n        if (!state.hasProvider) {\n            console.warn(HOTKEYS_PROVIDER_NOT_FOUND);\n        }\n    }, [state.hasProvider]);\n\n    // we can still bind the hotkeys if there is no HotkeysProvider, they just won't show up in the dialog\n    useEffect(() => {\n        const payload = [...globalKeys.map(k => k.config), ...localKeys.map(k => k.config)];\n        dispatch({ payload, type: \"ADD_HOTKEYS\" });\n        return () => dispatch({ payload, type: \"REMOVE_HOTKEYS\" });\n    }, [dispatch, globalKeys, localKeys]);\n\n    const invokeNamedCallbackIfComboRecognized = useCallback(\n        (global: boolean, combo: KeyCombo, callbackName: \"onKeyDown\" | \"onKeyUp\", e: KeyboardEvent) => {\n            const isTextInput = elementIsTextInput(e.target as HTMLElement);\n            for (const key of global ? globalKeys : localKeys) {\n                const {\n                    allowInInput = false,\n                    disabled = false,\n                    preventDefault = false,\n                    stopPropagation = false,\n                } = key.config;\n                const shouldIgnore = (isTextInput && !allowInInput) || disabled;\n                if (!shouldIgnore && comboMatches(key.combo, combo)) {\n                    if (preventDefault) {\n                        e.preventDefault();\n                    }\n                    if (stopPropagation) {\n                        // set a flag just for unit testing. not meant to be referenced in feature work.\n                        (e as any).isPropagationStopped = true;\n                        e.stopPropagation();\n                    }\n                    key.config[callbackName]?.(e);\n                }\n            }\n        },\n        [globalKeys, localKeys],\n    );\n\n    const handleGlobalKeyDown = useCallback(\n        (e: KeyboardEvent) => {\n            // special case for global keydown: if '?' is pressed, open the hotkeys dialog\n            const combo = getKeyCombo(e);\n            const isTextInput = elementIsTextInput(e.target as HTMLElement);\n            if (!isTextInput && comboMatches(parseKeyCombo(showDialogKeyCombo), combo)) {\n                dispatch({ type: \"OPEN_DIALOG\" });\n            } else {\n                invokeNamedCallbackIfComboRecognized(true, getKeyCombo(e), \"onKeyDown\", e);\n            }\n        },\n        [dispatch, invokeNamedCallbackIfComboRecognized, showDialogKeyCombo],\n    );\n    const handleGlobalKeyUp = useCallback(\n        (e: KeyboardEvent) => invokeNamedCallbackIfComboRecognized(true, getKeyCombo(e), \"onKeyUp\", e),\n        [invokeNamedCallbackIfComboRecognized],\n    );\n\n    const handleLocalKeyDown = useCallback(\n        (e: React.KeyboardEvent<HTMLElement>) =>\n            invokeNamedCallbackIfComboRecognized(false, getKeyCombo(e.nativeEvent), \"onKeyDown\", e.nativeEvent),\n        [invokeNamedCallbackIfComboRecognized],\n    );\n    const handleLocalKeyUp = useCallback(\n        (e: React.KeyboardEvent<HTMLElement>) =>\n            invokeNamedCallbackIfComboRecognized(false, getKeyCombo(e.nativeEvent), \"onKeyUp\", e.nativeEvent),\n        [invokeNamedCallbackIfComboRecognized],\n    );\n\n    useEffect(() => {\n        // document is guaranteed to be defined inside effects\n        document!.addEventListener(\"keydown\", handleGlobalKeyDown);\n        document!.addEventListener(\"keyup\", handleGlobalKeyUp);\n        return () => {\n            document!.removeEventListener(\"keydown\", handleGlobalKeyDown);\n            document!.removeEventListener(\"keyup\", handleGlobalKeyUp);\n        };\n    }, [document, handleGlobalKeyDown, handleGlobalKeyUp]);\n\n    return { handleKeyDown: handleLocalKeyDown, handleKeyUp: handleLocalKeyUp };\n}\n\nfunction getDefaultDocument(): Document | undefined {\n    if (typeof window === \"undefined\") {\n        return undefined;\n    }\n    return window.document;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}