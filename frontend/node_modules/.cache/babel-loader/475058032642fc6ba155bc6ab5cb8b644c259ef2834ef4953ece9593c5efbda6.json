{"ast":null,"code":"import { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\n/*\n * Copyright 2021 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport classNames from \"classnames\";\nimport { createRef } from \"react\";\nimport { createRoot } from \"react-dom/client\";\nimport { AbstractPureComponent, Classes, Position } from \"../../common\";\nimport { TOASTER_CREATE_NULL, TOASTER_MAX_TOASTS_INVALID, TOASTER_WARN_INLINE } from \"../../common/errors\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\nimport { isNodeEnv } from \"../../common/utils\";\nimport { Overlay2 } from \"../overlay2/overlay2\";\nimport { Toast } from \"./toast\";\nconst defaultDomRenderer = (element, container) => {\n  createRoot(container).render(element);\n};\nexport const OVERLAY_TOASTER_DELAY_MS = 50;\n/**\n * OverlayToaster component.\n *\n * @see https://blueprintjs.com/docs/#core/components/toast\n */\nexport class OverlayToaster extends AbstractPureComponent {\n  constructor() {\n    super(...arguments);\n    this.state = {\n      toastRefs: {},\n      toasts: []\n    };\n    // Queue of toasts to be displayed. If toasts are shown too quickly back to back, it can result in cut off toasts.\n    // The queue ensures that toasts are only displayed in QUEUE_TIMEOUT_MS increments.\n    this.queue = {\n      cancel: undefined,\n      isRunning: false,\n      toasts: []\n    };\n    // auto-incrementing identifier for un-keyed toasts\n    this.toastId = 0;\n    this.toastRefs = {};\n    /** Compute a new collection of toast refs (usually after updating toasts) */\n    this.getToastRefs = toasts => {\n      return toasts.reduce((refs, toast) => {\n        refs[toast.key] = createRef();\n        return refs;\n      }, {});\n    };\n    this.handleQueueTimeout = () => {\n      const nextToast = this.queue.toasts.shift();\n      if (nextToast != null) {\n        this.immediatelyShowToast(nextToast);\n        this.startQueueTimeout();\n      } else {\n        this.queue.isRunning = false;\n      }\n    };\n    this.renderToast = toast => {\n      return _jsx(Toast, {\n        ...toast,\n        onDismiss: this.getDismissHandler(toast)\n      });\n    };\n    this.getDismissHandler = toast => timeoutExpired => {\n      this.dismiss(toast.key, timeoutExpired);\n    };\n    this.handleClose = e => {\n      // NOTE that `e` isn't always a KeyboardEvent but that's the only type we care about\n      if (e.key === \"Escape\") {\n        this.clear();\n      }\n    };\n  }\n  /**\n   * Create a new `Toaster` instance that can be shared around your application.\n   * The `Toaster` will be rendered into a new element appended to the given container.\n   */\n  static create(props, options = {}) {\n    if (props != null && props.usePortal != null && !isNodeEnv(\"production\")) {\n      console.warn(TOASTER_WARN_INLINE);\n    }\n    const {\n      container = document.body,\n      domRenderer = defaultDomRenderer\n    } = options;\n    const toasterComponentRoot = document.createElement(\"div\");\n    container.appendChild(toasterComponentRoot);\n    return new Promise((resolve, reject) => {\n      try {\n        domRenderer(_jsx(OverlayToaster, {\n          ...props,\n          ref: handleRef,\n          usePortal: false\n        }), toasterComponentRoot);\n      } catch (error) {\n        // Note that we're catching errors from the domRenderer function\n        // call, but not errors when rendering <OverlayToaster>, which\n        // happens in a separate scheduled tick. Wrapping the\n        // OverlayToaster in an error boundary would be necessary to\n        // capture rendering errors, but that's still a bit unreliable\n        // and would only catch errors rendering the initial mount.\n        reject(error);\n      }\n      // We can get a rough guarantee that the OverlayToaster has been\n      // mounted to the DOM by waiting until the ref callback here has\n      // been fired.\n      //\n      // This is the approach suggested under \"What about the render\n      // callback?\" at https://github.com/reactwg/react-18/discussions/5.\n      function handleRef(ref) {\n        if (ref == null) {\n          reject(new Error(TOASTER_CREATE_NULL));\n          return;\n        }\n        resolve(ref);\n      }\n    });\n  }\n  /**\n   * This is an alias for `OverlayToaster.create`, exposed for backwards compatibility with the 5.x API.\n   *\n   * @deprecated Use `OverlayToaster.create` instead.\n   */\n  static createAsync(props, options) {\n    return OverlayToaster.create(props, options);\n  }\n  show(props, key) {\n    const options = this.createToastOptions(props, key);\n    const wasExistingToastUpdated = this.maybeUpdateExistingToast(options, key);\n    if (wasExistingToastUpdated) {\n      return options.key;\n    }\n    if (this.queue.isRunning) {\n      // If a toast has been shown recently, push to the queued toasts to prevent toasts from being shown too\n      // quickly for the animations to keep up\n      this.queue.toasts.push(options);\n    } else {\n      // If we have not recently shown a toast, we can immediately show the given toast\n      this.immediatelyShowToast(options);\n      this.startQueueTimeout();\n    }\n    return options.key;\n  }\n  maybeUpdateExistingToast(options, key) {\n    if (key == null) {\n      return false;\n    }\n    const isExistingQueuedToast = this.queue.toasts.some(toast => toast.key === key);\n    if (isExistingQueuedToast) {\n      this.queue.toasts = this.queue.toasts.map(t => t.key === key ? options : t);\n      return true;\n    }\n    const isExistingShownToast = this.state.toasts.some(toast => toast.key === key);\n    if (isExistingShownToast) {\n      this.updateToastsInState(toasts => toasts.map(t => t.key === key ? options : t));\n      return true;\n    }\n    return false;\n  }\n  immediatelyShowToast(options) {\n    if (this.props.maxToasts) {\n      // check if active number of toasts are at the maxToasts limit\n      this.dismissIfAtLimit();\n    }\n    this.updateToastsInState(toasts => [options, ...toasts]);\n  }\n  startQueueTimeout() {\n    this.queue.isRunning = true;\n    this.queue.cancel = this.setTimeout(this.handleQueueTimeout, OVERLAY_TOASTER_DELAY_MS);\n  }\n  updateToastsInState(getNewToasts) {\n    this.setState(prevState => {\n      const toasts = getNewToasts(prevState.toasts);\n      return {\n        toastRefs: this.getToastRefs(toasts),\n        toasts\n      };\n    });\n  }\n  dismiss(key, timeoutExpired = false) {\n    this.setState(prevState => {\n      const toasts = prevState.toasts.filter(t => {\n        var _a;\n        const matchesKey = t.key === key;\n        if (matchesKey) {\n          (_a = t.onDismiss) === null || _a === void 0 ? void 0 : _a.call(t, timeoutExpired);\n        }\n        return !matchesKey;\n      });\n      return {\n        toastRefs: this.getToastRefs(toasts),\n        toasts\n      };\n    });\n  }\n  clear() {\n    var _a, _b;\n    (_b = (_a = this.queue).cancel) === null || _b === void 0 ? void 0 : _b.call(_a);\n    this.queue = {\n      cancel: undefined,\n      isRunning: false,\n      toasts: []\n    };\n    this.state.toasts.forEach(t => {\n      var _a;\n      return (_a = t.onDismiss) === null || _a === void 0 ? void 0 : _a.call(t, false);\n    });\n    this.setState({\n      toastRefs: {},\n      toasts: []\n    });\n  }\n  getToasts() {\n    return this.state.toasts;\n  }\n  render() {\n    const classes = classNames(Classes.TOAST_CONTAINER, this.getPositionClasses(), this.props.className);\n    return _jsxs(Overlay2, {\n      autoFocus: this.props.autoFocus,\n      canEscapeKeyClose: this.props.canEscapeKeyClear,\n      canOutsideClickClose: false,\n      className: classes,\n      childRefs: this.toastRefs,\n      enforceFocus: false,\n      hasBackdrop: false,\n      isOpen: this.state.toasts.length > 0 || this.props.children != null,\n      onClose: this.handleClose,\n      shouldReturnFocusOnClose: false,\n      // $pt-transition-duration * 3 + $pt-transition-duration / 2\n      transitionDuration: 350,\n      transitionName: Classes.TOAST,\n      usePortal: this.props.usePortal,\n      children: [this.state.toasts.map(this.renderToast, this), this.props.children]\n    });\n  }\n  validateProps({\n    maxToasts\n  }) {\n    // maximum number of toasts should not be a number less than 1\n    if (maxToasts !== undefined && maxToasts < 1) {\n      throw new Error(TOASTER_MAX_TOASTS_INVALID);\n    }\n  }\n  dismissIfAtLimit() {\n    if (this.state.toasts.length === this.props.maxToasts) {\n      // dismiss the oldest toast to stay within the maxToasts limit\n      this.dismiss(this.state.toasts[this.state.toasts.length - 1].key);\n    }\n  }\n  createToastOptions(props, key = `toast-${this.toastId++}`) {\n    // clone the object before adding the key prop to avoid leaking the mutation\n    return {\n      ...props,\n      key\n    };\n  }\n  getPositionClasses() {\n    const positions = this.props.position.split(\"-\");\n    // NOTE that there is no -center class because that's the default style\n    return [...positions.map(p => `${Classes.TOAST_CONTAINER}-${p.toLowerCase()}`), `${Classes.TOAST_CONTAINER}-${this.props.usePortal ? \"in-portal\" : \"inline\"}`];\n  }\n}\nOverlayToaster.displayName = `${DISPLAYNAME_PREFIX}.OverlayToaster`;\nOverlayToaster.defaultProps = {\n  autoFocus: false,\n  canEscapeKeyClear: true,\n  position: Position.TOP,\n  usePortal: true\n};","map":{"version":3,"names":["classNames","createRef","createRoot","AbstractPureComponent","Classes","Position","TOASTER_CREATE_NULL","TOASTER_MAX_TOASTS_INVALID","TOASTER_WARN_INLINE","DISPLAYNAME_PREFIX","isNodeEnv","Overlay2","Toast","defaultDomRenderer","element","container","render","OVERLAY_TOASTER_DELAY_MS","OverlayToaster","constructor","state","toastRefs","toasts","queue","cancel","undefined","isRunning","toastId","getToastRefs","reduce","refs","toast","key","handleQueueTimeout","nextToast","shift","immediatelyShowToast","startQueueTimeout","renderToast","_jsx","onDismiss","getDismissHandler","timeoutExpired","dismiss","handleClose","e","clear","create","props","options","usePortal","console","warn","document","body","domRenderer","toasterComponentRoot","createElement","appendChild","Promise","resolve","reject","ref","handleRef","error","Error","createAsync","show","createToastOptions","wasExistingToastUpdated","maybeUpdateExistingToast","push","isExistingQueuedToast","some","map","t","isExistingShownToast","updateToastsInState","maxToasts","dismissIfAtLimit","setTimeout","getNewToasts","setState","prevState","filter","matchesKey","_a","call","_b","forEach","getToasts","classes","TOAST_CONTAINER","getPositionClasses","className","_jsxs","autoFocus","canEscapeKeyClose","canEscapeKeyClear","canOutsideClickClose","childRefs","enforceFocus","hasBackdrop","isOpen","length","children","onClose","shouldReturnFocusOnClose","transitionDuration","transitionName","TOAST","validateProps","positions","position","split","p","toLowerCase","displayName","defaultProps","TOP"],"sources":["/Users/husseingalal/Desktop/Hackathon/Elrond/frontend/node_modules/@blueprintjs/core/src/components/toast/overlayToaster.tsx"],"sourcesContent":["/*\n * Copyright 2021 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport classNames from \"classnames\";\nimport { createRef } from \"react\";\nimport { createRoot } from \"react-dom/client\";\n\nimport { AbstractPureComponent, Classes, Position } from \"../../common\";\nimport { TOASTER_CREATE_NULL, TOASTER_MAX_TOASTS_INVALID, TOASTER_WARN_INLINE } from \"../../common/errors\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\nimport { isNodeEnv } from \"../../common/utils\";\nimport { Overlay2 } from \"../overlay2/overlay2\";\n\nimport type { OverlayToasterProps } from \"./overlayToasterProps\";\nimport { Toast } from \"./toast\";\nimport type { Toaster, ToastOptions } from \"./toaster\";\nimport type { ToastProps } from \"./toastProps\";\n\nexport interface OverlayToasterState {\n    toasts: ToastOptions[];\n    toastRefs: Record<string, React.RefObject<HTMLElement>>;\n}\n\nexport interface OverlayToasterCreateOptions {\n    /**\n     * A new DOM element will be created and appended to this container.\n     *\n     * @default document.body\n     */\n    container?: HTMLElement;\n\n    /**\n     * A function to render the React component onto a newly created DOM element. By default, this creates a\n     * ReactDOM client root at the passed container and renders the element into that React tree.\n     */\n    domRenderer?: OverlayToasterDOMRenderer;\n}\n\n// Exported for tests\nexport type OverlayToasterDOMRenderer = (\n    element: React.ReactElement<unknown>,\n    container: Element | DocumentFragment,\n) => void;\n\nconst defaultDomRenderer: OverlayToasterDOMRenderer = (element, container) => {\n    createRoot(container).render(element);\n};\n\ninterface OverlayToasterQueueState {\n    cancel: (() => void) | undefined;\n    isRunning: boolean;\n    toasts: ToastOptions[];\n}\n\nexport const OVERLAY_TOASTER_DELAY_MS = 50;\n\n/**\n * OverlayToaster component.\n *\n * @see https://blueprintjs.com/docs/#core/components/toast\n */\nexport class OverlayToaster extends AbstractPureComponent<OverlayToasterProps, OverlayToasterState> implements Toaster {\n    public static displayName = `${DISPLAYNAME_PREFIX}.OverlayToaster`;\n\n    public static defaultProps: OverlayToasterProps = {\n        autoFocus: false,\n        canEscapeKeyClear: true,\n        position: Position.TOP,\n        usePortal: true,\n    };\n\n    /**\n     * Create a new `Toaster` instance that can be shared around your application.\n     * The `Toaster` will be rendered into a new element appended to the given container.\n     */\n    public static create(props?: OverlayToasterProps, options: OverlayToasterCreateOptions = {}): Promise<Toaster> {\n        if (props != null && props.usePortal != null && !isNodeEnv(\"production\")) {\n            console.warn(TOASTER_WARN_INLINE);\n        }\n\n        const { container = document.body, domRenderer = defaultDomRenderer } = options;\n        const toasterComponentRoot = document.createElement(\"div\");\n        container.appendChild(toasterComponentRoot);\n\n        return new Promise<Toaster>((resolve, reject) => {\n            try {\n                domRenderer(<OverlayToaster {...props} ref={handleRef} usePortal={false} />, toasterComponentRoot);\n            } catch (error) {\n                // Note that we're catching errors from the domRenderer function\n                // call, but not errors when rendering <OverlayToaster>, which\n                // happens in a separate scheduled tick. Wrapping the\n                // OverlayToaster in an error boundary would be necessary to\n                // capture rendering errors, but that's still a bit unreliable\n                // and would only catch errors rendering the initial mount.\n                reject(error);\n            }\n\n            // We can get a rough guarantee that the OverlayToaster has been\n            // mounted to the DOM by waiting until the ref callback here has\n            // been fired.\n            //\n            // This is the approach suggested under \"What about the render\n            // callback?\" at https://github.com/reactwg/react-18/discussions/5.\n            function handleRef(ref: OverlayToaster | null) {\n                if (ref == null) {\n                    reject(new Error(TOASTER_CREATE_NULL));\n                    return;\n                }\n\n                resolve(ref);\n            }\n        });\n    }\n\n    /**\n     * This is an alias for `OverlayToaster.create`, exposed for backwards compatibility with the 5.x API.\n     *\n     * @deprecated Use `OverlayToaster.create` instead.\n     */\n    public static createAsync(props?: OverlayToasterProps, options?: OverlayToasterCreateOptions): Promise<Toaster> {\n        return OverlayToaster.create(props, options);\n    }\n\n    public state: OverlayToasterState = {\n        toastRefs: {},\n        toasts: [],\n    };\n\n    // Queue of toasts to be displayed. If toasts are shown too quickly back to back, it can result in cut off toasts.\n    // The queue ensures that toasts are only displayed in QUEUE_TIMEOUT_MS increments.\n    private queue: OverlayToasterQueueState = {\n        cancel: undefined,\n        isRunning: false,\n        toasts: [],\n    };\n\n    // auto-incrementing identifier for un-keyed toasts\n    private toastId = 0;\n\n    private toastRefs: Record<string, React.RefObject<HTMLElement>> = {};\n\n    /** Compute a new collection of toast refs (usually after updating toasts) */\n    private getToastRefs = (toasts: ToastOptions[]) => {\n        return toasts.reduce<typeof this.toastRefs>((refs, toast) => {\n            refs[toast.key!] = createRef<HTMLElement>();\n            return refs;\n        }, {});\n    };\n\n    public show(props: ToastProps, key?: string) {\n        const options = this.createToastOptions(props, key);\n        const wasExistingToastUpdated = this.maybeUpdateExistingToast(options, key);\n        if (wasExistingToastUpdated) {\n            return options.key;\n        }\n\n        if (this.queue.isRunning) {\n            // If a toast has been shown recently, push to the queued toasts to prevent toasts from being shown too\n            // quickly for the animations to keep up\n            this.queue.toasts.push(options);\n        } else {\n            // If we have not recently shown a toast, we can immediately show the given toast\n            this.immediatelyShowToast(options);\n            this.startQueueTimeout();\n        }\n\n        return options.key;\n    }\n\n    private maybeUpdateExistingToast(options: ToastOptions, key: string | undefined) {\n        if (key == null) {\n            return false;\n        }\n\n        const isExistingQueuedToast = this.queue.toasts.some(toast => toast.key === key);\n        if (isExistingQueuedToast) {\n            this.queue.toasts = this.queue.toasts.map(t => (t.key === key ? options : t));\n            return true;\n        }\n\n        const isExistingShownToast = this.state.toasts.some(toast => toast.key === key);\n        if (isExistingShownToast) {\n            this.updateToastsInState(toasts => toasts.map(t => (t.key === key ? options : t)));\n            return true;\n        }\n\n        return false;\n    }\n\n    private immediatelyShowToast(options: ToastOptions) {\n        if (this.props.maxToasts) {\n            // check if active number of toasts are at the maxToasts limit\n            this.dismissIfAtLimit();\n        }\n\n        this.updateToastsInState(toasts => [options, ...toasts]);\n    }\n\n    private startQueueTimeout() {\n        this.queue.isRunning = true;\n        this.queue.cancel = this.setTimeout(this.handleQueueTimeout, OVERLAY_TOASTER_DELAY_MS);\n    }\n\n    private handleQueueTimeout = () => {\n        const nextToast = this.queue.toasts.shift();\n        if (nextToast != null) {\n            this.immediatelyShowToast(nextToast);\n            this.startQueueTimeout();\n        } else {\n            this.queue.isRunning = false;\n        }\n    };\n\n    private updateToastsInState(getNewToasts: (toasts: ToastOptions[]) => ToastOptions[]) {\n        this.setState(prevState => {\n            const toasts = getNewToasts(prevState.toasts);\n            return { toastRefs: this.getToastRefs(toasts), toasts };\n        });\n    }\n\n    public dismiss(key: string, timeoutExpired = false) {\n        this.setState(prevState => {\n            const toasts = prevState.toasts.filter(t => {\n                const matchesKey = t.key === key;\n                if (matchesKey) {\n                    t.onDismiss?.(timeoutExpired);\n                }\n                return !matchesKey;\n            });\n            return { toastRefs: this.getToastRefs(toasts), toasts };\n        });\n    }\n\n    public clear() {\n        this.queue.cancel?.();\n        this.queue = { cancel: undefined, isRunning: false, toasts: [] };\n        this.state.toasts.forEach(t => t.onDismiss?.(false));\n        this.setState({ toastRefs: {}, toasts: [] });\n    }\n\n    public getToasts() {\n        return this.state.toasts;\n    }\n\n    public render() {\n        const classes = classNames(Classes.TOAST_CONTAINER, this.getPositionClasses(), this.props.className);\n        return (\n            <Overlay2\n                autoFocus={this.props.autoFocus}\n                canEscapeKeyClose={this.props.canEscapeKeyClear}\n                canOutsideClickClose={false}\n                className={classes}\n                childRefs={this.toastRefs}\n                enforceFocus={false}\n                hasBackdrop={false}\n                isOpen={this.state.toasts.length > 0 || this.props.children != null}\n                onClose={this.handleClose}\n                shouldReturnFocusOnClose={false}\n                // $pt-transition-duration * 3 + $pt-transition-duration / 2\n                transitionDuration={350}\n                transitionName={Classes.TOAST}\n                usePortal={this.props.usePortal}\n            >\n                {this.state.toasts.map(this.renderToast, this)}\n                {this.props.children}\n            </Overlay2>\n        );\n    }\n\n    protected validateProps({ maxToasts }: OverlayToasterProps) {\n        // maximum number of toasts should not be a number less than 1\n        if (maxToasts !== undefined && maxToasts < 1) {\n            throw new Error(TOASTER_MAX_TOASTS_INVALID);\n        }\n    }\n\n    private dismissIfAtLimit() {\n        if (this.state.toasts.length === this.props.maxToasts) {\n            // dismiss the oldest toast to stay within the maxToasts limit\n            this.dismiss(this.state.toasts[this.state.toasts.length - 1].key!);\n        }\n    }\n\n    private renderToast = (toast: ToastOptions) => {\n        return <Toast {...toast} onDismiss={this.getDismissHandler(toast)} />;\n    };\n\n    private createToastOptions(props: ToastProps, key = `toast-${this.toastId++}`) {\n        // clone the object before adding the key prop to avoid leaking the mutation\n        return { ...props, key };\n    }\n\n    private getPositionClasses() {\n        const positions = this.props.position!.split(\"-\");\n        // NOTE that there is no -center class because that's the default style\n        return [\n            ...positions.map(p => `${Classes.TOAST_CONTAINER}-${p.toLowerCase()}`),\n            `${Classes.TOAST_CONTAINER}-${this.props.usePortal ? \"in-portal\" : \"inline\"}`,\n        ];\n    }\n\n    private getDismissHandler = (toast: ToastOptions) => (timeoutExpired: boolean) => {\n        this.dismiss(toast.key, timeoutExpired);\n    };\n\n    private handleClose = (e: React.SyntheticEvent<HTMLElement>) => {\n        // NOTE that `e` isn't always a KeyboardEvent but that's the only type we care about\n        if ((e as React.KeyboardEvent<HTMLElement>).key === \"Escape\") {\n            this.clear();\n        }\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}