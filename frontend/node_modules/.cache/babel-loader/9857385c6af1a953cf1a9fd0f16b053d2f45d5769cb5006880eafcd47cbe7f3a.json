{"ast":null,"code":"import { jsx as _jsx } from \"react/jsx-runtime\";\n/*\n * Copyright 2018 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport classNames from \"classnames\";\nimport { Component, createElement } from \"react\";\nimport { Boundary, Classes, DISPLAYNAME_PREFIX } from \"../../common\";\nimport { OVERFLOW_LIST_OBSERVE_PARENTS_CHANGED } from \"../../common/errors\";\nimport { shallowCompareKeys } from \"../../common/utils\";\nimport { ResizeSensor } from \"../resize-sensor/resizeSensor\";\n/**\n * Overflow list component.\n *\n * @see https://blueprintjs.com/docs/#core/components/overflow-list\n */\nexport class OverflowList extends Component {\n  constructor() {\n    super(...arguments);\n    this.state = {\n      chopSize: this.defaultChopSize(),\n      lastChopSize: null,\n      lastOverflowCount: 0,\n      overflow: [],\n      repartitioning: false,\n      visible: this.props.items\n    };\n    this.spacer = null;\n    this.resize = () => {\n      this.repartition();\n    };\n  }\n  static ofType() {\n    return OverflowList;\n  }\n  componentDidMount() {\n    this.repartition();\n  }\n  shouldComponentUpdate(nextProps, nextState) {\n    // We want this component to always re-render, even when props haven't changed, so that\n    // changes in the renderers' behavior can be reflected.\n    // The following statement prevents re-rendering only in the case where the state changes\n    // identity (i.e. setState was called), but the state is still the same when\n    // shallow-compared to the previous state. Original context: https://github.com/palantir/blueprint/pull/3278.\n    // We also ensure that we re-render if the props DO change (which isn't necessarily accounted for by other logic).\n    return this.props !== nextProps || !(this.state !== nextState && shallowCompareKeys(this.state, nextState));\n  }\n  componentDidUpdate(prevProps, prevState) {\n    var _a, _b;\n    if (prevProps.observeParents !== this.props.observeParents) {\n      console.warn(OVERFLOW_LIST_OBSERVE_PARENTS_CHANGED);\n    }\n    if (prevProps.collapseFrom !== this.props.collapseFrom || prevProps.items !== this.props.items || prevProps.minVisibleItems !== this.props.minVisibleItems || prevProps.overflowRenderer !== this.props.overflowRenderer || prevProps.alwaysRenderOverflow !== this.props.alwaysRenderOverflow || prevProps.visibleItemRenderer !== this.props.visibleItemRenderer) {\n      // reset visible state if the above props change.\n      this.setState({\n        chopSize: this.defaultChopSize(),\n        lastChopSize: null,\n        lastOverflowCount: 0,\n        overflow: [],\n        repartitioning: true,\n        visible: this.props.items\n      });\n    }\n    const {\n      repartitioning,\n      overflow,\n      lastOverflowCount\n    } = this.state;\n    if (\n    // if a resize operation has just completed\n    repartitioning === false && prevState.repartitioning === true) {\n      // only invoke the callback if the UI has actually changed\n      if (overflow.length !== lastOverflowCount) {\n        (_b = (_a = this.props).onOverflow) === null || _b === void 0 ? void 0 : _b.call(_a, overflow.slice());\n      }\n    } else if (!shallowCompareKeys(prevState, this.state)) {\n      this.repartition();\n    }\n  }\n  render() {\n    const {\n      className,\n      collapseFrom,\n      observeParents,\n      style,\n      tagName = \"div\",\n      visibleItemRenderer\n    } = this.props;\n    const overflow = this.maybeRenderOverflow();\n    const list = createElement(tagName, {\n      className: classNames(Classes.OVERFLOW_LIST, className),\n      style\n    }, collapseFrom === Boundary.START ? overflow : null, this.state.visible.map(visibleItemRenderer), collapseFrom === Boundary.END ? overflow : null, _jsx(\"div\", {\n      className: Classes.OVERFLOW_LIST_SPACER,\n      ref: ref => this.spacer = ref\n    }));\n    return _jsx(ResizeSensor, {\n      onResize: this.resize,\n      observeParents: observeParents,\n      children: list\n    });\n  }\n  maybeRenderOverflow() {\n    const {\n      overflow\n    } = this.state;\n    if (overflow.length === 0 && !this.props.alwaysRenderOverflow) {\n      return null;\n    }\n    return this.props.overflowRenderer(overflow.slice());\n  }\n  repartition() {\n    var _a;\n    if (this.spacer == null) {\n      return;\n    }\n    // if lastChopSize was 1, then our binary search has exhausted.\n    const partitionExhausted = this.state.lastChopSize === 1;\n    const minVisible = (_a = this.props.minVisibleItems) !== null && _a !== void 0 ? _a : 0;\n    // spacer has flex-shrink and width 1px so if it's much smaller then we know to shrink\n    const shouldShrink = this.spacer.offsetWidth < 0.9 && this.state.visible.length > minVisible;\n    // we only check partitionExhausted for shouldGrow to ensure shrinking is the final operation.\n    const shouldGrow = (this.spacer.offsetWidth >= 1 || this.state.visible.length < minVisible) && this.state.overflow.length > 0 && !partitionExhausted;\n    if (shouldShrink || shouldGrow) {\n      this.setState(state => {\n        let visible;\n        let overflow;\n        if (this.props.collapseFrom === Boundary.END) {\n          const result = shiftElements(state.visible, state.overflow, this.state.chopSize * (shouldShrink ? 1 : -1));\n          visible = result[0];\n          overflow = result[1];\n        } else {\n          const result = shiftElements(state.overflow, state.visible, this.state.chopSize * (shouldShrink ? -1 : 1));\n          overflow = result[0];\n          visible = result[1];\n        }\n        return {\n          chopSize: halve(state.chopSize),\n          lastChopSize: state.chopSize,\n          // if we're starting a new partition cycle, record the last overflow count so we can track whether the UI changes after the new overflow is calculated\n          lastOverflowCount: this.isFirstPartitionCycle(state.chopSize) ? state.overflow.length : state.lastOverflowCount,\n          overflow,\n          repartitioning: true,\n          visible\n        };\n      });\n    } else {\n      // repartition complete!\n      this.setState({\n        chopSize: this.defaultChopSize(),\n        lastChopSize: null,\n        repartitioning: false\n      });\n    }\n  }\n  defaultChopSize() {\n    return halve(this.props.items.length);\n  }\n  isFirstPartitionCycle(currentChopSize) {\n    return currentChopSize === this.defaultChopSize();\n  }\n}\nOverflowList.displayName = `${DISPLAYNAME_PREFIX}.OverflowList`;\nOverflowList.defaultProps = {\n  alwaysRenderOverflow: false,\n  collapseFrom: Boundary.START,\n  minVisibleItems: 0\n};\nfunction halve(num) {\n  return Math.ceil(num / 2);\n}\nfunction shiftElements(leftArray, rightArray, num) {\n  // if num is positive then elements are shifted from left-to-right, if negative then right-to-left\n  const allElements = leftArray.concat(rightArray);\n  const newLeftLength = leftArray.length - num;\n  if (newLeftLength <= 0) {\n    return [[], allElements];\n  } else if (newLeftLength >= allElements.length) {\n    return [allElements, []];\n  }\n  const sliceIndex = allElements.length - newLeftLength;\n  return [allElements.slice(0, -sliceIndex), allElements.slice(-sliceIndex)];\n}","map":{"version":3,"names":["classNames","Component","createElement","Boundary","Classes","DISPLAYNAME_PREFIX","OVERFLOW_LIST_OBSERVE_PARENTS_CHANGED","shallowCompareKeys","ResizeSensor","OverflowList","constructor","state","chopSize","defaultChopSize","lastChopSize","lastOverflowCount","overflow","repartitioning","visible","props","items","spacer","resize","repartition","ofType","componentDidMount","shouldComponentUpdate","nextProps","nextState","componentDidUpdate","prevProps","prevState","observeParents","console","warn","collapseFrom","minVisibleItems","overflowRenderer","alwaysRenderOverflow","visibleItemRenderer","setState","length","_b","_a","onOverflow","call","slice","render","className","style","tagName","maybeRenderOverflow","list","OVERFLOW_LIST","START","map","END","_jsx","OVERFLOW_LIST_SPACER","ref","onResize","children","partitionExhausted","minVisible","shouldShrink","offsetWidth","shouldGrow","result","shiftElements","halve","isFirstPartitionCycle","currentChopSize","displayName","defaultProps","num","Math","ceil","leftArray","rightArray","allElements","concat","newLeftLength","sliceIndex"],"sources":["/Users/husseingalal/Desktop/Hackathon/Elrond/frontend/node_modules/@blueprintjs/core/src/components/overflow-list/overflowList.tsx"],"sourcesContent":["/*\n * Copyright 2018 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport classNames from \"classnames\";\nimport { Component, createElement } from \"react\";\n\nimport { Boundary, Classes, DISPLAYNAME_PREFIX, type Props } from \"../../common\";\nimport { OVERFLOW_LIST_OBSERVE_PARENTS_CHANGED } from \"../../common/errors\";\nimport { shallowCompareKeys } from \"../../common/utils\";\nimport { ResizeSensor } from \"../resize-sensor/resizeSensor\";\n\nexport interface OverflowListProps<T> extends Props {\n    /**\n     * Whether to force the overflowRenderer to always be called, even if there are zero items\n     * overflowing. This may be useful, for example, if your overflow renderer contains a Popover\n     * which you do not want to close as the list is resized.\n     *\n     * @default false\n     */\n    alwaysRenderOverflow?: boolean;\n\n    /**\n     * Which direction the items should collapse from: start or end of the\n     * children. This also determines whether `overflowRenderer` appears before\n     * (`START`) or after (`END`) the visible items.\n     *\n     * @default Boundary.START\n     */\n    collapseFrom?: Boundary;\n\n    /**\n     * All items to display in the list. Items that do not fit in the container\n     * will be rendered in the overflow instead.\n     */\n    items: readonly T[];\n\n    /**\n     * The minimum number of visible items that should never collapse into the\n     * overflow menu, regardless of DOM dimensions.\n     *\n     * @default 0\n     */\n    minVisibleItems?: number;\n\n    /**\n     * If `true`, all parent DOM elements of the container will also be\n     * observed. If changes to a parent's size is detected, the overflow will be\n     * recalculated.\n     *\n     * Only enable this prop if the overflow should be recalculated when a\n     * parent element resizes in a way that does not also cause the\n     * `OverflowList` to resize.\n     *\n     * @default false\n     */\n    observeParents?: boolean;\n\n    /**\n     * Callback invoked when the overflowed items change. This is called once\n     * after the DOM has settled, rather that on every intermediate change. It\n     * is not invoked if resizing produces an unchanged overflow state.\n     */\n    onOverflow?: (overflowItems: T[]) => void;\n\n    /**\n     * Callback invoked to render the overflowed items. Unlike\n     * `visibleItemRenderer`, this prop is invoked once with all items that do\n     * not fit in the container.\n     *\n     * Typical use cases for this prop will put overflowed items in a dropdown\n     * menu or display a \"+X items\" label.\n     */\n    overflowRenderer: (overflowItems: T[]) => React.ReactNode;\n\n    /** CSS properties to apply to the root element. */\n    style?: React.CSSProperties;\n\n    /**\n     * HTML tag name for the container element.\n     *\n     * @default \"div\"\n     */\n    tagName?: keyof React.JSX.IntrinsicElements;\n\n    /**\n     * Callback invoked to render each visible item.\n     * Remember to set a `key` on the rendered element!\n     */\n    visibleItemRenderer: (item: T, index: number) => React.ReactNode;\n}\n\nexport interface OverflowListState<T> {\n    /** Whether repartitioning is still active. An overflow can take several frames to settle. */\n    repartitioning: boolean;\n    /** Length of last overflow to dedupe `onOverflow` calls during smooth resizing. */\n    lastOverflowCount: number;\n    overflow: readonly T[];\n    visible: readonly T[];\n    /** Pointer for the binary search algorithm used to find the finished non-overflowing state */\n    chopSize: number;\n    lastChopSize: number | null;\n}\n\n/**\n * Overflow list component.\n *\n * @see https://blueprintjs.com/docs/#core/components/overflow-list\n */\nexport class OverflowList<T> extends Component<OverflowListProps<T>, OverflowListState<T>> {\n    public static displayName = `${DISPLAYNAME_PREFIX}.OverflowList`;\n\n    public static defaultProps: Partial<OverflowListProps<any>> = {\n        alwaysRenderOverflow: false,\n        collapseFrom: Boundary.START,\n        minVisibleItems: 0,\n    };\n\n    public static ofType<U>() {\n        return OverflowList as new (props: OverflowListProps<U>) => OverflowList<U>;\n    }\n\n    public state: OverflowListState<T> = {\n        chopSize: this.defaultChopSize(),\n        lastChopSize: null,\n        lastOverflowCount: 0,\n        overflow: [],\n        repartitioning: false,\n        visible: this.props.items,\n    };\n\n    private spacer: HTMLElement | null = null;\n\n    public componentDidMount() {\n        this.repartition();\n    }\n\n    public shouldComponentUpdate(nextProps: OverflowListProps<T>, nextState: OverflowListState<T>) {\n        // We want this component to always re-render, even when props haven't changed, so that\n        // changes in the renderers' behavior can be reflected.\n        // The following statement prevents re-rendering only in the case where the state changes\n        // identity (i.e. setState was called), but the state is still the same when\n        // shallow-compared to the previous state. Original context: https://github.com/palantir/blueprint/pull/3278.\n        // We also ensure that we re-render if the props DO change (which isn't necessarily accounted for by other logic).\n        return this.props !== nextProps || !(this.state !== nextState && shallowCompareKeys(this.state, nextState));\n    }\n\n    public componentDidUpdate(prevProps: OverflowListProps<T>, prevState: OverflowListState<T>) {\n        if (prevProps.observeParents !== this.props.observeParents) {\n            console.warn(OVERFLOW_LIST_OBSERVE_PARENTS_CHANGED);\n        }\n\n        if (\n            prevProps.collapseFrom !== this.props.collapseFrom ||\n            prevProps.items !== this.props.items ||\n            prevProps.minVisibleItems !== this.props.minVisibleItems ||\n            prevProps.overflowRenderer !== this.props.overflowRenderer ||\n            prevProps.alwaysRenderOverflow !== this.props.alwaysRenderOverflow ||\n            prevProps.visibleItemRenderer !== this.props.visibleItemRenderer\n        ) {\n            // reset visible state if the above props change.\n            this.setState({\n                chopSize: this.defaultChopSize(),\n                lastChopSize: null,\n                lastOverflowCount: 0,\n                overflow: [],\n                repartitioning: true,\n                visible: this.props.items,\n            });\n        }\n\n        const { repartitioning, overflow, lastOverflowCount } = this.state;\n\n        if (\n            // if a resize operation has just completed\n            repartitioning === false &&\n            prevState.repartitioning === true\n        ) {\n            // only invoke the callback if the UI has actually changed\n            if (overflow.length !== lastOverflowCount) {\n                this.props.onOverflow?.(overflow.slice());\n            }\n        } else if (!shallowCompareKeys(prevState, this.state)) {\n            this.repartition();\n        }\n    }\n\n    public render() {\n        const { className, collapseFrom, observeParents, style, tagName = \"div\", visibleItemRenderer } = this.props;\n        const overflow = this.maybeRenderOverflow();\n        const list = createElement(\n            tagName,\n            {\n                className: classNames(Classes.OVERFLOW_LIST, className),\n                style,\n            },\n            collapseFrom === Boundary.START ? overflow : null,\n            this.state.visible.map(visibleItemRenderer),\n            collapseFrom === Boundary.END ? overflow : null,\n            <div className={Classes.OVERFLOW_LIST_SPACER} ref={ref => (this.spacer = ref)} />,\n        );\n\n        return (\n            <ResizeSensor onResize={this.resize} observeParents={observeParents}>\n                {list}\n            </ResizeSensor>\n        );\n    }\n\n    private maybeRenderOverflow() {\n        const { overflow } = this.state;\n        if (overflow.length === 0 && !this.props.alwaysRenderOverflow) {\n            return null;\n        }\n        return this.props.overflowRenderer(overflow.slice());\n    }\n\n    private resize = () => {\n        this.repartition();\n    };\n\n    private repartition() {\n        if (this.spacer == null) {\n            return;\n        }\n\n        // if lastChopSize was 1, then our binary search has exhausted.\n        const partitionExhausted = this.state.lastChopSize === 1;\n        const minVisible = this.props.minVisibleItems ?? 0;\n\n        // spacer has flex-shrink and width 1px so if it's much smaller then we know to shrink\n        const shouldShrink = this.spacer.offsetWidth < 0.9 && this.state.visible.length > minVisible;\n\n        // we only check partitionExhausted for shouldGrow to ensure shrinking is the final operation.\n        const shouldGrow =\n            (this.spacer.offsetWidth >= 1 || this.state.visible.length < minVisible) &&\n            this.state.overflow.length > 0 &&\n            !partitionExhausted;\n\n        if (shouldShrink || shouldGrow) {\n            this.setState(state => {\n                let visible;\n                let overflow;\n                if (this.props.collapseFrom === Boundary.END) {\n                    const result = shiftElements(\n                        state.visible,\n                        state.overflow,\n                        this.state.chopSize * (shouldShrink ? 1 : -1),\n                    );\n                    visible = result[0];\n                    overflow = result[1];\n                } else {\n                    const result = shiftElements(\n                        state.overflow,\n                        state.visible,\n                        this.state.chopSize * (shouldShrink ? -1 : 1),\n                    );\n                    overflow = result[0];\n                    visible = result[1];\n                }\n\n                return {\n                    chopSize: halve(state.chopSize),\n                    lastChopSize: state.chopSize,\n                    // if we're starting a new partition cycle, record the last overflow count so we can track whether the UI changes after the new overflow is calculated\n                    lastOverflowCount: this.isFirstPartitionCycle(state.chopSize)\n                        ? state.overflow.length\n                        : state.lastOverflowCount,\n                    overflow,\n                    repartitioning: true,\n                    visible,\n                };\n            });\n        } else {\n            // repartition complete!\n            this.setState({\n                chopSize: this.defaultChopSize(),\n                lastChopSize: null,\n                repartitioning: false,\n            });\n        }\n    }\n\n    private defaultChopSize(): number {\n        return halve(this.props.items.length);\n    }\n\n    private isFirstPartitionCycle(currentChopSize: number): boolean {\n        return currentChopSize === this.defaultChopSize();\n    }\n}\n\nfunction halve(num: number): number {\n    return Math.ceil(num / 2);\n}\n\nfunction shiftElements<T>(leftArray: readonly T[], rightArray: readonly T[], num: number): [newFrom: T[], newTo: T[]] {\n    // if num is positive then elements are shifted from left-to-right, if negative then right-to-left\n    const allElements = leftArray.concat(rightArray);\n    const newLeftLength = leftArray.length - num;\n\n    if (newLeftLength <= 0) {\n        return [[], allElements];\n    } else if (newLeftLength >= allElements.length) {\n        return [allElements, []];\n    }\n\n    const sliceIndex = allElements.length - newLeftLength;\n\n    return [allElements.slice(0, -sliceIndex), allElements.slice(-sliceIndex)];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}