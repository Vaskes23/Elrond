{"ast":null,"code":"import { jsx as _jsx } from \"react/jsx-runtime\";\n/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport classNames from \"classnames\";\nimport { Children, forwardRef, useCallback, useEffect, useId, useImperativeHandle, useMemo, useRef, useState } from \"react\";\nimport { CSSTransition, TransitionGroup } from \"react-transition-group\";\nimport { Classes, mergeRefs } from \"../../common\";\nimport { OVERLAY_CHILD_REF_AND_REFS_MUTEX, OVERLAY_CHILD_REQUIRES_KEY, OVERLAY_WITH_MULTIPLE_CHILDREN_REQUIRES_CHILD_REFS } from \"../../common/errors\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\nimport { ensureElement, getActiveElement, getRef, isEmptyString, isNodeEnv, isReactElement, setRef } from \"../../common/utils\";\nimport { hasDOMEnvironment } from \"../../common/utils/domUtils\";\nimport { useOverlayStack } from \"../../hooks/overlays/useOverlayStack\";\nimport { usePrevious } from \"../../hooks/usePrevious\";\nimport { getKeyboardFocusableElements } from \"../overlay/overlayUtils\";\nimport { Portal } from \"../portal/portal\";\nexport const OVERLAY2_DEFAULT_PROPS = {\n  autoFocus: true,\n  backdropProps: {},\n  canEscapeKeyClose: true,\n  canOutsideClickClose: true,\n  enforceFocus: true,\n  hasBackdrop: true,\n  isOpen: false,\n  lazy: hasDOMEnvironment(),\n  shouldReturnFocusOnClose: true,\n  transitionDuration: 300,\n  transitionName: Classes.OVERLAY,\n  usePortal: true\n};\n/**\n * Overlay2 component.\n *\n * @see https://blueprintjs.com/docs/#core/components/overlay2\n */\nexport const Overlay2 = forwardRef((props, forwardedRef) => {\n  var _a, _b;\n  const {\n    autoFocus,\n    backdropClassName,\n    backdropProps,\n    canEscapeKeyClose,\n    canOutsideClickClose,\n    childRef,\n    childRefs,\n    children,\n    className,\n    enforceFocus,\n    hasBackdrop,\n    isOpen,\n    lazy,\n    onClose,\n    onClosed,\n    onClosing,\n    onOpened,\n    onOpening,\n    portalClassName,\n    portalContainer,\n    shouldReturnFocusOnClose,\n    transitionDuration,\n    transitionName,\n    usePortal\n  } = props;\n  useOverlay2Validation(props);\n  const {\n    closeOverlay,\n    getLastOpened,\n    getThisOverlayAndDescendants,\n    openOverlay\n  } = useOverlayStack();\n  const [isAutoFocusing, setIsAutoFocusing] = useState(false);\n  const [hasEverOpened, setHasEverOpened] = useState(false);\n  const lastActiveElementBeforeOpened = useRef(null);\n  /** Ref for container element, containing all children and the backdrop */\n  const containerElement = useRef(null);\n  /** Ref for backdrop element */\n  const backdropElement = useRef(null);\n  /* An empty, keyboard-focusable div at the beginning of the Overlay content */\n  const startFocusTrapElement = useRef(null);\n  /* An empty, keyboard-focusable div at the end of the Overlay content */\n  const endFocusTrapElement = useRef(null);\n  /**\n   * Locally-generated DOM ref for a singleton child element.\n   * This is only used iff the user does not specify the `childRef` or `childRefs` props.\n   */\n  const localChildRef = useRef(null);\n  const bringFocusInsideOverlay = useCallback(() => {\n    // always delay focus manipulation to just before repaint to prevent scroll jumping\n    return requestAnimationFrame(() => {\n      var _a;\n      // container element may be undefined between component mounting and Portal rendering\n      // activeElement may be undefined in some rare cases in IE\n      const container = getRef(containerElement);\n      const activeElement = getActiveElement(container);\n      if (container == null || activeElement == null) {\n        return;\n      }\n      // Overlay2 is guaranteed to be mounted here\n      const isFocusOutsideModal = !container.contains(activeElement);\n      if (isFocusOutsideModal) {\n        (_a = getRef(startFocusTrapElement)) === null || _a === void 0 ? void 0 : _a.focus({\n          preventScroll: true\n        });\n        setIsAutoFocusing(false);\n      }\n    });\n  }, []);\n  /** Unique ID for this overlay in the global stack */\n  const id = useOverlay2ID();\n  // N.B. use `null` here and not simply `undefined` because `useImperativeHandle` will set `null` on unmount,\n  // and we need the following code to be resilient to that value.\n  const instance = useRef(null);\n  /**\n   * When multiple `enforceFocus` Overlays are open, this event handler is only active for the most\n   * recently opened one to avoid Overlays competing with each other for focus.\n   */\n  const handleDocumentFocus = useCallback(e => {\n    // get the actual target even in the Shadow DOM\n    // see https://github.com/palantir/blueprint/issues/4220\n    const eventTarget = e.composed ? e.composedPath()[0] : e.target;\n    const container = getRef(containerElement);\n    if (container != null && eventTarget instanceof Node && !container.contains(eventTarget)) {\n      // prevent default focus behavior (sometimes auto-scrolls the page)\n      e.preventDefault();\n      e.stopImmediatePropagation();\n      bringFocusInsideOverlay();\n    }\n  }, [bringFocusInsideOverlay]);\n  // N.B. this listener is only kept attached when `isOpen={true}` and `canOutsideClickClose={true}`\n  const handleDocumentMousedown = useCallback(e => {\n    // get the actual target even in the Shadow DOM\n    // see https://github.com/palantir/blueprint/issues/4220\n    const eventTarget = e.composed ? e.composedPath()[0] : e.target;\n    const thisOverlayAndDescendants = getThisOverlayAndDescendants(id);\n    const isClickInThisOverlayOrDescendant = thisOverlayAndDescendants.some(({\n      containerElement: containerRef\n    }) => {\n      // `elem` is the container of backdrop & content, so clicking directly on that container\n      // should not count as being \"inside\" the overlay.\n      const elem = getRef(containerRef);\n      return (elem === null || elem === void 0 ? void 0 : elem.contains(eventTarget)) && !elem.isSameNode(eventTarget);\n    });\n    if (!isClickInThisOverlayOrDescendant) {\n      // casting to any because this is a native event\n      onClose === null || onClose === void 0 ? void 0 : onClose(e);\n    }\n  }, [getThisOverlayAndDescendants, id, onClose]);\n  // send this instance's imperative handle to the the forwarded ref as well as our local ref\n  const ref = useMemo(() => mergeRefs(forwardedRef, instance), [forwardedRef]);\n  useImperativeHandle(ref, () => ({\n    bringFocusInsideOverlay,\n    containerElement,\n    handleDocumentFocus,\n    handleDocumentMousedown,\n    id,\n    props: {\n      autoFocus,\n      enforceFocus,\n      hasBackdrop,\n      usePortal\n    }\n  }), [autoFocus, bringFocusInsideOverlay, enforceFocus, handleDocumentFocus, handleDocumentMousedown, hasBackdrop, id, usePortal]);\n  const handleContainerKeyDown = useCallback(e => {\n    if (e.key === \"Escape\" && canEscapeKeyClose) {\n      onClose === null || onClose === void 0 ? void 0 : onClose(e);\n      // prevent other overlays from closing\n      e.stopPropagation();\n      // prevent browser-specific escape key behavior (Safari exits fullscreen)\n      e.preventDefault();\n    }\n  }, [canEscapeKeyClose, onClose]);\n  const overlayWillOpen = useCallback(() => {\n    if (instance.current == null) {\n      return;\n    }\n    const lastOpenedOverlay = getLastOpened();\n    if ((lastOpenedOverlay === null || lastOpenedOverlay === void 0 ? void 0 : lastOpenedOverlay.handleDocumentFocus) !== undefined) {\n      document.removeEventListener(\"focus\", lastOpenedOverlay.handleDocumentFocus, /* useCapture */true);\n    }\n    openOverlay(instance.current);\n    if (autoFocus) {\n      setIsAutoFocusing(true);\n      bringFocusInsideOverlay();\n    }\n    setRef(lastActiveElementBeforeOpened, getActiveElement(getRef(containerElement)));\n  }, [autoFocus, bringFocusInsideOverlay, getLastOpened, openOverlay]);\n  const overlayWillClose = useCallback(() => {\n    var _a;\n    document.removeEventListener(\"focus\", handleDocumentFocus, /* useCapture */true);\n    document.removeEventListener(\"mousedown\", handleDocumentMousedown);\n    // N.B. `instance.current` may be null at this point if we are cleaning up an open overlay during the unmount phase\n    // (this is common, for example, with context menu's singleton `showContextMenu` / `hideContextMenu` imperative APIs).\n    closeOverlay(id);\n    const lastOpenedOverlay = getLastOpened();\n    if (lastOpenedOverlay !== undefined) {\n      // Only bring focus back to last overlay if it had autoFocus _and_ enforceFocus enabled.\n      // If `autoFocus={false}`, it's likely that the overlay never received focus in the first place,\n      // so it would be surprising for us to send it there. See https://github.com/palantir/blueprint/issues/4921\n      if (lastOpenedOverlay.props.autoFocus && lastOpenedOverlay.props.enforceFocus) {\n        (_a = lastOpenedOverlay.bringFocusInsideOverlay) === null || _a === void 0 ? void 0 : _a.call(lastOpenedOverlay);\n        if (lastOpenedOverlay.handleDocumentFocus !== undefined) {\n          document.addEventListener(\"focus\", lastOpenedOverlay.handleDocumentFocus, /* useCapture */true);\n        }\n      }\n    }\n  }, [closeOverlay, getLastOpened, handleDocumentFocus, handleDocumentMousedown, id]);\n  const prevIsOpen = (_a = usePrevious(isOpen)) !== null && _a !== void 0 ? _a : false;\n  useEffect(() => {\n    if (isOpen) {\n      setHasEverOpened(true);\n    }\n    if (!prevIsOpen && isOpen) {\n      // just opened\n      overlayWillOpen();\n    }\n    if (prevIsOpen && !isOpen) {\n      // just closed\n      overlayWillClose();\n    }\n  }, [isOpen, overlayWillOpen, overlayWillClose, prevIsOpen]);\n  // Important: clean up old document-level event listeners if their memoized values change (this is rare, but\n  // may happen, for example, if a user forgets to use `useCallback` in the `props.onClose` value).\n  // Otherwise, we will lose the reference to those values and create a memory leak since we won't be able\n  // to successfully detach them inside overlayWillClose.\n  useEffect(() => {\n    if (!isOpen || !(canOutsideClickClose && !hasBackdrop)) {\n      return;\n    }\n    document.addEventListener(\"mousedown\", handleDocumentMousedown);\n    return () => {\n      document.removeEventListener(\"mousedown\", handleDocumentMousedown);\n    };\n  }, [handleDocumentMousedown, isOpen, canOutsideClickClose, hasBackdrop]);\n  useEffect(() => {\n    if (!isOpen || !enforceFocus) {\n      return;\n    }\n    // Only add listener if this overlay is the most recent one\n    const lastOpened = getLastOpened();\n    const isTopOverlay = (lastOpened === null || lastOpened === void 0 ? void 0 : lastOpened.id) === id;\n    if (!isTopOverlay) {\n      return;\n    }\n    // Focus events do not bubble, but setting useCapture allows us to listen in and execute\n    // our handler before all others\n    document.addEventListener(\"focus\", handleDocumentFocus, /* useCapture */true);\n    return () => {\n      document.removeEventListener(\"focus\", handleDocumentFocus, /* useCapture */true);\n    };\n  }, [handleDocumentFocus, enforceFocus, isOpen, getLastOpened, id]);\n  const overlayWillCloseRef = useRef(overlayWillClose);\n  overlayWillCloseRef.current = overlayWillClose;\n  useEffect(() => {\n    // run cleanup code once on unmount, ensuring we call the most recent overlayWillClose callback\n    // by storing in a ref and keeping up to date\n    return () => {\n      overlayWillCloseRef.current();\n    };\n  }, []);\n  const handleTransitionExited = useCallback(node => {\n    const lastActiveElement = getRef(lastActiveElementBeforeOpened);\n    if (shouldReturnFocusOnClose && lastActiveElement instanceof HTMLElement) {\n      lastActiveElement.focus();\n    }\n    onClosed === null || onClosed === void 0 ? void 0 : onClosed(node);\n  }, [onClosed, shouldReturnFocusOnClose]);\n  // N.B. CSSTransition requires this callback to be defined, even if it's unused.\n  const handleTransitionAddEnd = useCallback(() => {\n    // no-op\n  }, []);\n  /**\n   * Gets the relevant DOM ref for a child element using the `childRef` or `childRefs` props (if possible).\n   * This ref is necessary for `CSSTransition` to work in React 18 without relying on `ReactDOM.findDOMNode`.\n   *\n   * Returns `undefined` if the user did not specify either of those props. In those cases, we use the ref we\n   * have locally generated and expect that the user _did not_ specify their own `ref` on the child element\n   * (it will get clobbered / overriden).\n   *\n   * @see https://reactcommunity.org/react-transition-group/css-transition\n   */\n  const getUserChildRef = useCallback(child => {\n    if (childRef != null) {\n      return childRef;\n    } else if (childRefs != null) {\n      const key = child.key;\n      if (key == null) {\n        if (!isNodeEnv(\"production\")) {\n          console.error(OVERLAY_CHILD_REQUIRES_KEY);\n        }\n        return undefined;\n      }\n      return childRefs[key];\n    }\n    return undefined;\n  }, [childRef, childRefs]);\n  const maybeRenderChild = useCallback(child => {\n    if (child == null || isEmptyString(child)) {\n      return null;\n    }\n    // decorate the child with a few injected props\n    const userChildRef = getUserChildRef(child);\n    const childProps = isReactElement(child) ? child.props : {};\n    // if the child is a string, number, or fragment, it will be wrapped in a <span> element\n    const decoratedChild = ensureElement(child, \"span\", {\n      className: classNames(childProps.className, Classes.OVERLAY_CONTENT),\n      // IMPORTANT: only inject our ref if the user didn't specify childRef or childRefs already. Otherwise,\n      // we risk clobbering the user's ref (which we cannot inspect here while cloning/decorating the child).\n      ref: userChildRef === undefined ? localChildRef : undefined,\n      tabIndex: enforceFocus || autoFocus ? 0 : undefined\n    });\n    const resolvedChildRef = userChildRef !== null && userChildRef !== void 0 ? userChildRef : localChildRef;\n    return _jsx(CSSTransition, {\n      addEndListener: handleTransitionAddEnd,\n      classNames: transitionName,\n      // HACKHACK: CSSTransition types are slightly incompatible with React types here.\n      // React prefers `| null` but not `| undefined` for the ref value, while\n      // CSSTransition _demands_ that `| undefined` be part of the element type.\n      nodeRef: resolvedChildRef,\n      onEntered: getLifecycleCallbackWithChildRef(onOpened, resolvedChildRef),\n      onEntering: getLifecycleCallbackWithChildRef(onOpening, resolvedChildRef),\n      onExited: getLifecycleCallbackWithChildRef(handleTransitionExited, resolvedChildRef),\n      onExiting: getLifecycleCallbackWithChildRef(onClosing, resolvedChildRef),\n      timeout: transitionDuration,\n      children: decoratedChild\n    });\n  }, [autoFocus, enforceFocus, getUserChildRef, handleTransitionAddEnd, handleTransitionExited, onClosing, onOpened, onOpening, transitionDuration, transitionName]);\n  const handleBackdropMouseDown = useCallback(e => {\n    var _a;\n    if (canOutsideClickClose) {\n      onClose === null || onClose === void 0 ? void 0 : onClose(e);\n    }\n    if (enforceFocus) {\n      bringFocusInsideOverlay();\n    }\n    (_a = backdropProps === null || backdropProps === void 0 ? void 0 : backdropProps.onMouseDown) === null || _a === void 0 ? void 0 : _a.call(backdropProps, e);\n  }, [backdropProps, bringFocusInsideOverlay, canOutsideClickClose, enforceFocus, onClose]);\n  const renderDummyElement = useCallback((key, dummyElementProps) => _jsx(CSSTransition, {\n    addEndListener: handleTransitionAddEnd,\n    classNames: transitionName,\n    nodeRef: dummyElementProps.ref,\n    timeout: transitionDuration,\n    unmountOnExit: true,\n    children: _jsx(\"div\", {\n      tabIndex: 0,\n      ...dummyElementProps\n    })\n  }, key), [handleTransitionAddEnd, transitionDuration, transitionName]);\n  /**\n   * Ensures repeatedly pressing shift+tab keeps focus inside the Overlay. Moves focus to\n   * the `endFocusTrapElement` or the first keyboard-focusable element in the Overlay (excluding\n   * the `startFocusTrapElement`), depending on whether the element losing focus is inside the\n   * Overlay.\n   */\n  const handleStartFocusTrapElementFocus = useCallback(e => {\n    if (!enforceFocus || isAutoFocusing) {\n      return;\n    }\n    // e.relatedTarget will not be defined if this was a programmatic focus event, as is the\n    // case when we call this.bringFocusInsideOverlay() after a user clicked on the backdrop.\n    // Otherwise, we're handling a user interaction, and we should wrap around to the last\n    // element in this transition group.\n    const container = getRef(containerElement);\n    const endFocusTrap = getRef(endFocusTrapElement);\n    if (e.relatedTarget != null && (container === null || container === void 0 ? void 0 : container.contains(e.relatedTarget)) && e.relatedTarget !== endFocusTrap) {\n      endFocusTrap === null || endFocusTrap === void 0 ? void 0 : endFocusTrap.focus({\n        preventScroll: true\n      });\n    }\n  }, [enforceFocus, isAutoFocusing]);\n  /**\n   * Wrap around to the end of the dialog if `enforceFocus` is enabled.\n   */\n  const handleStartFocusTrapElementKeyDown = useCallback(e => {\n    var _a;\n    if (!enforceFocus) {\n      return;\n    }\n    if (e.shiftKey && e.key === \"Tab\") {\n      const lastFocusableElement = getKeyboardFocusableElements(containerElement).pop();\n      if (lastFocusableElement != null) {\n        lastFocusableElement.focus();\n      } else {\n        (_a = getRef(endFocusTrapElement)) === null || _a === void 0 ? void 0 : _a.focus({\n          preventScroll: true\n        });\n      }\n    }\n  }, [enforceFocus]);\n  /**\n   * Ensures repeatedly pressing tab keeps focus inside the Overlay. Moves focus to the\n   * `startFocusTrapElement` or the last keyboard-focusable element in the Overlay (excluding the\n   * `startFocusTrapElement`), depending on whether the element losing focus is inside the\n   * Overlay.\n   */\n  const handleEndFocusTrapElementFocus = useCallback(e => {\n    var _a;\n    // No need for this.props.enforceFocus check here because this element is only rendered\n    // when that prop is true.\n    // During user interactions, e.relatedTarget will be defined, and we should wrap around to the\n    // \"start focus trap\" element.\n    // Otherwise, we're handling a programmatic focus event, which can only happen after a user\n    // presses shift+tab from the first focusable element in the overlay.\n    const startFocusTrap = getRef(startFocusTrapElement);\n    if (e.relatedTarget != null && ((_a = getRef(containerElement)) === null || _a === void 0 ? void 0 : _a.contains(e.relatedTarget)) && e.relatedTarget !== startFocusTrap) {\n      const firstFocusableElement = getKeyboardFocusableElements(containerElement).shift();\n      // ensure we don't re-focus an already active element by comparing against e.relatedTarget\n      if (!isAutoFocusing && firstFocusableElement != null && firstFocusableElement !== e.relatedTarget) {\n        firstFocusableElement.focus();\n      } else {\n        startFocusTrap === null || startFocusTrap === void 0 ? void 0 : startFocusTrap.focus({\n          preventScroll: true\n        });\n      }\n    } else {\n      const lastFocusableElement = getKeyboardFocusableElements(containerElement).pop();\n      if (lastFocusableElement != null) {\n        lastFocusableElement.focus();\n      } else {\n        // Keeps focus within Overlay even if there are no keyboard-focusable children\n        startFocusTrap === null || startFocusTrap === void 0 ? void 0 : startFocusTrap.focus({\n          preventScroll: true\n        });\n      }\n    }\n  }, [isAutoFocusing]);\n  const maybeBackdrop = useMemo(() => hasBackdrop && isOpen ? _jsx(CSSTransition, {\n    classNames: transitionName,\n    nodeRef: backdropElement,\n    timeout: transitionDuration,\n    addEndListener: handleTransitionAddEnd,\n    children: _jsx(\"div\", {\n      ...backdropProps,\n      className: classNames(Classes.OVERLAY_BACKDROP, backdropClassName, backdropProps === null || backdropProps === void 0 ? void 0 : backdropProps.className),\n      onMouseDown: handleBackdropMouseDown,\n      ref: backdropElement\n    })\n  }, \"__backdrop\") : null, [backdropClassName, backdropProps, handleBackdropMouseDown, handleTransitionAddEnd, hasBackdrop, isOpen, transitionDuration, transitionName]);\n  // no reason to render anything at all if we're being truly lazy\n  if (lazy && !hasEverOpened) {\n    return null;\n  }\n  // TransitionGroup types require single array of children; does not support nested arrays.\n  // So we must collapse backdrop and children into one array, and every item must be wrapped in a\n  // Transition element (no ReactText allowed).\n  const childrenWithTransitions = isOpen ? (_b = Children.map(children, maybeRenderChild)) !== null && _b !== void 0 ? _b : [] : [];\n  // const maybeBackdrop = maybeRenderBackdrop();\n  if (maybeBackdrop !== null) {\n    childrenWithTransitions.unshift(maybeBackdrop);\n  }\n  if (isOpen && (autoFocus || enforceFocus) && childrenWithTransitions.length > 0) {\n    childrenWithTransitions.unshift(renderDummyElement(\"__start\", {\n      className: Classes.OVERLAY_START_FOCUS_TRAP,\n      onFocus: handleStartFocusTrapElementFocus,\n      onKeyDown: handleStartFocusTrapElementKeyDown,\n      ref: startFocusTrapElement\n    }));\n    if (enforceFocus) {\n      childrenWithTransitions.push(renderDummyElement(\"__end\", {\n        className: Classes.OVERLAY_END_FOCUS_TRAP,\n        onFocus: handleEndFocusTrapElementFocus,\n        ref: endFocusTrapElement\n      }));\n    }\n  }\n  const transitionGroup = _jsx(\"div\", {\n    \"aria-live\": \"polite\",\n    className: classNames(Classes.OVERLAY, {\n      [Classes.OVERLAY_OPEN]: isOpen,\n      [Classes.OVERLAY_INLINE]: !usePortal\n    }, className),\n    onKeyDown: handleContainerKeyDown,\n    ref: containerElement,\n    children: _jsx(TransitionGroup, {\n      appear: true,\n      component: null,\n      children: childrenWithTransitions\n    })\n  });\n  if (usePortal) {\n    return _jsx(Portal, {\n      className: portalClassName,\n      container: portalContainer,\n      children: transitionGroup\n    });\n  } else {\n    return transitionGroup;\n  }\n});\n// eslint-disable-next-line @typescript-eslint/no-deprecated\nOverlay2.defaultProps = OVERLAY2_DEFAULT_PROPS;\nOverlay2.displayName = `${DISPLAYNAME_PREFIX}.Overlay2`;\nfunction useOverlay2Validation({\n  childRef,\n  childRefs,\n  children\n}) {\n  const numChildren = Children.count(children);\n  useEffect(() => {\n    if (isNodeEnv(\"production\")) {\n      return;\n    }\n    if (childRef != null && childRefs != null) {\n      console.error(OVERLAY_CHILD_REF_AND_REFS_MUTEX);\n    }\n    if (numChildren > 1 && childRefs == null) {\n      console.error(OVERLAY_WITH_MULTIPLE_CHILDREN_REQUIRES_CHILD_REFS);\n    }\n  }, [childRef, childRefs, numChildren]);\n}\n/**\n * Generates a unique ID for a given Overlay which persists across the component's lifecycle.\n */\nfunction useOverlay2ID() {\n  const id = useId();\n  return `${Overlay2.displayName}-${id}`;\n}\n// N.B. the `onExiting` callback is not provided with the `node` argument as suggested in CSSTransition types since\n// we are using the `nodeRef` prop, so we must inject it dynamically.\nfunction getLifecycleCallbackWithChildRef(callback, childRef) {\n  return () => {\n    if ((childRef === null || childRef === void 0 ? void 0 : childRef.current) != null) {\n      callback === null || callback === void 0 ? void 0 : callback(childRef.current);\n    }\n  };\n}","map":{"version":3,"names":["classNames","Children","forwardRef","useCallback","useEffect","useId","useImperativeHandle","useMemo","useRef","useState","CSSTransition","TransitionGroup","Classes","mergeRefs","OVERLAY_CHILD_REF_AND_REFS_MUTEX","OVERLAY_CHILD_REQUIRES_KEY","OVERLAY_WITH_MULTIPLE_CHILDREN_REQUIRES_CHILD_REFS","DISPLAYNAME_PREFIX","ensureElement","getActiveElement","getRef","isEmptyString","isNodeEnv","isReactElement","setRef","hasDOMEnvironment","useOverlayStack","usePrevious","getKeyboardFocusableElements","Portal","OVERLAY2_DEFAULT_PROPS","autoFocus","backdropProps","canEscapeKeyClose","canOutsideClickClose","enforceFocus","hasBackdrop","isOpen","lazy","shouldReturnFocusOnClose","transitionDuration","transitionName","OVERLAY","usePortal","Overlay2","props","forwardedRef","backdropClassName","childRef","childRefs","children","className","onClose","onClosed","onClosing","onOpened","onOpening","portalClassName","portalContainer","useOverlay2Validation","closeOverlay","getLastOpened","getThisOverlayAndDescendants","openOverlay","isAutoFocusing","setIsAutoFocusing","hasEverOpened","setHasEverOpened","lastActiveElementBeforeOpened","containerElement","backdropElement","startFocusTrapElement","endFocusTrapElement","localChildRef","bringFocusInsideOverlay","requestAnimationFrame","container","activeElement","isFocusOutsideModal","contains","_a","focus","preventScroll","id","useOverlay2ID","instance","handleDocumentFocus","e","eventTarget","composed","composedPath","target","Node","preventDefault","stopImmediatePropagation","handleDocumentMousedown","thisOverlayAndDescendants","isClickInThisOverlayOrDescendant","some","containerRef","elem","isSameNode","ref","handleContainerKeyDown","key","stopPropagation","overlayWillOpen","current","lastOpenedOverlay","undefined","document","removeEventListener","overlayWillClose","call","addEventListener","prevIsOpen","lastOpened","isTopOverlay","overlayWillCloseRef","handleTransitionExited","node","lastActiveElement","HTMLElement","handleTransitionAddEnd","getUserChildRef","child","console","error","maybeRenderChild","userChildRef","childProps","decoratedChild","OVERLAY_CONTENT","tabIndex","resolvedChildRef","_jsx","addEndListener","nodeRef","onEntered","getLifecycleCallbackWithChildRef","onEntering","onExited","onExiting","timeout","handleBackdropMouseDown","onMouseDown","renderDummyElement","dummyElementProps","unmountOnExit","handleStartFocusTrapElementFocus","endFocusTrap","relatedTarget","handleStartFocusTrapElementKeyDown","shiftKey","lastFocusableElement","pop","handleEndFocusTrapElementFocus","startFocusTrap","firstFocusableElement","shift","maybeBackdrop","OVERLAY_BACKDROP","childrenWithTransitions","_b","map","unshift","length","OVERLAY_START_FOCUS_TRAP","onFocus","onKeyDown","push","OVERLAY_END_FOCUS_TRAP","transitionGroup","OVERLAY_OPEN","OVERLAY_INLINE","appear","component","defaultProps","displayName","numChildren","count","callback"],"sources":["/Users/husseingalal/Desktop/Hackathon/Elrond/frontend/node_modules/@blueprintjs/core/src/components/overlay2/overlay2.tsx"],"sourcesContent":["/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport classNames from \"classnames\";\nimport {\n    Children,\n    forwardRef,\n    useCallback,\n    useEffect,\n    useId,\n    useImperativeHandle,\n    useMemo,\n    useRef,\n    useState,\n} from \"react\";\nimport { CSSTransition, TransitionGroup } from \"react-transition-group\";\n\nimport { Classes, mergeRefs } from \"../../common\";\nimport {\n    OVERLAY_CHILD_REF_AND_REFS_MUTEX,\n    OVERLAY_CHILD_REQUIRES_KEY,\n    OVERLAY_WITH_MULTIPLE_CHILDREN_REQUIRES_CHILD_REFS,\n} from \"../../common/errors\";\nimport { DISPLAYNAME_PREFIX, type HTMLDivProps } from \"../../common/props\";\nimport {\n    ensureElement,\n    getActiveElement,\n    getRef,\n    isEmptyString,\n    isNodeEnv,\n    isReactElement,\n    setRef,\n} from \"../../common/utils\";\nimport { hasDOMEnvironment } from \"../../common/utils/domUtils\";\nimport { useOverlayStack } from \"../../hooks/overlays/useOverlayStack\";\nimport { usePrevious } from \"../../hooks/usePrevious\";\nimport type { OverlayProps } from \"../overlay/overlayProps\";\nimport { getKeyboardFocusableElements } from \"../overlay/overlayUtils\";\nimport { Portal } from \"../portal/portal\";\n\nimport type { OverlayInstance } from \"./overlayInstance\";\n\nexport interface Overlay2Props extends OverlayProps, React.RefAttributes<OverlayInstance> {\n    /**\n     * If you provide a single child element to Overlay2 and attach your own `ref` to the node, you must pass the\n     * same value here (otherwise, Overlay2 won't be able to render CSSTransition correctly).\n     *\n     * Mutually exclusive with the `childRefs` prop. This prop is a shorthand for `childRefs={{ [key: string]: ref }}`.\n     */\n    childRef?: React.RefObject<HTMLElement>;\n\n    /**\n     * If you provide a _multiple child elements_ to Overlay2, you must enumerate and generate a\n     * collection of DOM refs to those elements and provide it here. The object's keys must correspond to the child\n     * React element `key` values.\n     *\n     * Mutually exclusive with the `childRef` prop. If you only provide a single child element, consider using\n     * `childRef` instead.\n     */\n    childRefs?: Record<string, React.RefObject<HTMLElement>>;\n}\n\nexport const OVERLAY2_DEFAULT_PROPS = {\n    autoFocus: true,\n    backdropProps: {},\n    canEscapeKeyClose: true,\n    canOutsideClickClose: true,\n    enforceFocus: true,\n    hasBackdrop: true,\n    isOpen: false,\n    lazy: hasDOMEnvironment(),\n    shouldReturnFocusOnClose: true,\n    transitionDuration: 300,\n    transitionName: Classes.OVERLAY,\n    usePortal: true,\n};\n\n/**\n * Overlay2 component.\n *\n * @see https://blueprintjs.com/docs/#core/components/overlay2\n */\nexport const Overlay2 = forwardRef<OverlayInstance, Overlay2Props>((props, forwardedRef) => {\n    const {\n        autoFocus,\n        backdropClassName,\n        backdropProps,\n        canEscapeKeyClose,\n        canOutsideClickClose,\n        childRef,\n        childRefs,\n        children,\n        className,\n        enforceFocus,\n        hasBackdrop,\n        isOpen,\n        lazy,\n        onClose,\n        onClosed,\n        onClosing,\n        onOpened,\n        onOpening,\n        portalClassName,\n        portalContainer,\n        shouldReturnFocusOnClose,\n        transitionDuration,\n        transitionName,\n        usePortal,\n    } = props;\n\n    useOverlay2Validation(props);\n    const { closeOverlay, getLastOpened, getThisOverlayAndDescendants, openOverlay } = useOverlayStack();\n\n    const [isAutoFocusing, setIsAutoFocusing] = useState(false);\n    const [hasEverOpened, setHasEverOpened] = useState(false);\n    const lastActiveElementBeforeOpened = useRef<Element>(null);\n\n    /** Ref for container element, containing all children and the backdrop */\n    const containerElement = useRef<HTMLDivElement>(null);\n\n    /** Ref for backdrop element */\n    const backdropElement = useRef<HTMLDivElement>(null);\n\n    /* An empty, keyboard-focusable div at the beginning of the Overlay content */\n    const startFocusTrapElement = useRef<HTMLDivElement>(null);\n\n    /* An empty, keyboard-focusable div at the end of the Overlay content */\n    const endFocusTrapElement = useRef<HTMLDivElement>(null);\n\n    /**\n     * Locally-generated DOM ref for a singleton child element.\n     * This is only used iff the user does not specify the `childRef` or `childRefs` props.\n     */\n    const localChildRef = useRef<HTMLElement>(null);\n\n    const bringFocusInsideOverlay = useCallback(() => {\n        // always delay focus manipulation to just before repaint to prevent scroll jumping\n        return requestAnimationFrame(() => {\n            // container element may be undefined between component mounting and Portal rendering\n            // activeElement may be undefined in some rare cases in IE\n            const container = getRef(containerElement);\n            const activeElement = getActiveElement(container);\n\n            if (container == null || activeElement == null) {\n                return;\n            }\n\n            // Overlay2 is guaranteed to be mounted here\n            const isFocusOutsideModal = !container.contains(activeElement);\n            if (isFocusOutsideModal) {\n                getRef(startFocusTrapElement)?.focus({ preventScroll: true });\n                setIsAutoFocusing(false);\n            }\n        });\n    }, []);\n\n    /** Unique ID for this overlay in the global stack */\n    const id = useOverlay2ID();\n\n    // N.B. use `null` here and not simply `undefined` because `useImperativeHandle` will set `null` on unmount,\n    // and we need the following code to be resilient to that value.\n    const instance = useRef<OverlayInstance>(null);\n\n    /**\n     * When multiple `enforceFocus` Overlays are open, this event handler is only active for the most\n     * recently opened one to avoid Overlays competing with each other for focus.\n     */\n    const handleDocumentFocus = useCallback(\n        (e: FocusEvent) => {\n            // get the actual target even in the Shadow DOM\n            // see https://github.com/palantir/blueprint/issues/4220\n            const eventTarget = e.composed ? e.composedPath()[0] : e.target;\n            const container = getRef(containerElement);\n            if (container != null && eventTarget instanceof Node && !container.contains(eventTarget as HTMLElement)) {\n                // prevent default focus behavior (sometimes auto-scrolls the page)\n                e.preventDefault();\n                e.stopImmediatePropagation();\n                bringFocusInsideOverlay();\n            }\n        },\n        [bringFocusInsideOverlay],\n    );\n\n    // N.B. this listener is only kept attached when `isOpen={true}` and `canOutsideClickClose={true}`\n    const handleDocumentMousedown = useCallback(\n        (e: MouseEvent) => {\n            // get the actual target even in the Shadow DOM\n            // see https://github.com/palantir/blueprint/issues/4220\n            const eventTarget = (e.composed ? e.composedPath()[0] : e.target) as HTMLElement;\n\n            const thisOverlayAndDescendants = getThisOverlayAndDescendants(id);\n            const isClickInThisOverlayOrDescendant = thisOverlayAndDescendants.some(\n                ({ containerElement: containerRef }) => {\n                    // `elem` is the container of backdrop & content, so clicking directly on that container\n                    // should not count as being \"inside\" the overlay.\n                    const elem = getRef(containerRef);\n                    return elem?.contains(eventTarget) && !elem.isSameNode(eventTarget);\n                },\n            );\n\n            if (!isClickInThisOverlayOrDescendant) {\n                // casting to any because this is a native event\n                onClose?.(e as any);\n            }\n        },\n        [getThisOverlayAndDescendants, id, onClose],\n    );\n\n    // send this instance's imperative handle to the the forwarded ref as well as our local ref\n    const ref = useMemo(() => mergeRefs(forwardedRef, instance), [forwardedRef]);\n    useImperativeHandle(\n        ref,\n        () => ({\n            bringFocusInsideOverlay,\n            containerElement,\n            handleDocumentFocus,\n            handleDocumentMousedown,\n            id,\n            props: {\n                autoFocus,\n                enforceFocus,\n                hasBackdrop,\n                usePortal,\n            },\n        }),\n        [\n            autoFocus,\n            bringFocusInsideOverlay,\n            enforceFocus,\n            handleDocumentFocus,\n            handleDocumentMousedown,\n            hasBackdrop,\n            id,\n            usePortal,\n        ],\n    );\n\n    const handleContainerKeyDown = useCallback(\n        (e: React.KeyboardEvent<HTMLElement>) => {\n            if (e.key === \"Escape\" && canEscapeKeyClose) {\n                onClose?.(e);\n                // prevent other overlays from closing\n                e.stopPropagation();\n                // prevent browser-specific escape key behavior (Safari exits fullscreen)\n                e.preventDefault();\n            }\n        },\n        [canEscapeKeyClose, onClose],\n    );\n\n    const overlayWillOpen = useCallback(() => {\n        if (instance.current == null) {\n            return;\n        }\n\n        const lastOpenedOverlay = getLastOpened();\n        if (lastOpenedOverlay?.handleDocumentFocus !== undefined) {\n            document.removeEventListener(\"focus\", lastOpenedOverlay.handleDocumentFocus, /* useCapture */ true);\n        }\n        openOverlay(instance.current);\n\n        if (autoFocus) {\n            setIsAutoFocusing(true);\n            bringFocusInsideOverlay();\n        }\n\n        setRef(lastActiveElementBeforeOpened, getActiveElement(getRef(containerElement)));\n    }, [autoFocus, bringFocusInsideOverlay, getLastOpened, openOverlay]);\n\n    const overlayWillClose = useCallback(() => {\n        document.removeEventListener(\"focus\", handleDocumentFocus, /* useCapture */ true);\n        document.removeEventListener(\"mousedown\", handleDocumentMousedown);\n\n        // N.B. `instance.current` may be null at this point if we are cleaning up an open overlay during the unmount phase\n        // (this is common, for example, with context menu's singleton `showContextMenu` / `hideContextMenu` imperative APIs).\n        closeOverlay(id);\n        const lastOpenedOverlay = getLastOpened();\n        if (lastOpenedOverlay !== undefined) {\n            // Only bring focus back to last overlay if it had autoFocus _and_ enforceFocus enabled.\n            // If `autoFocus={false}`, it's likely that the overlay never received focus in the first place,\n            // so it would be surprising for us to send it there. See https://github.com/palantir/blueprint/issues/4921\n            if (lastOpenedOverlay.props.autoFocus && lastOpenedOverlay.props.enforceFocus) {\n                lastOpenedOverlay.bringFocusInsideOverlay?.();\n                if (lastOpenedOverlay.handleDocumentFocus !== undefined) {\n                    document.addEventListener(\"focus\", lastOpenedOverlay.handleDocumentFocus, /* useCapture */ true);\n                }\n            }\n        }\n    }, [closeOverlay, getLastOpened, handleDocumentFocus, handleDocumentMousedown, id]);\n\n    const prevIsOpen = usePrevious(isOpen) ?? false;\n    useEffect(() => {\n        if (isOpen) {\n            setHasEverOpened(true);\n        }\n\n        if (!prevIsOpen && isOpen) {\n            // just opened\n            overlayWillOpen();\n        }\n\n        if (prevIsOpen && !isOpen) {\n            // just closed\n            overlayWillClose();\n        }\n    }, [isOpen, overlayWillOpen, overlayWillClose, prevIsOpen]);\n\n    // Important: clean up old document-level event listeners if their memoized values change (this is rare, but\n    // may happen, for example, if a user forgets to use `useCallback` in the `props.onClose` value).\n    // Otherwise, we will lose the reference to those values and create a memory leak since we won't be able\n    // to successfully detach them inside overlayWillClose.\n    useEffect(() => {\n        if (!isOpen || !(canOutsideClickClose && !hasBackdrop)) {\n            return;\n        }\n\n        document.addEventListener(\"mousedown\", handleDocumentMousedown);\n\n        return () => {\n            document.removeEventListener(\"mousedown\", handleDocumentMousedown);\n        };\n    }, [handleDocumentMousedown, isOpen, canOutsideClickClose, hasBackdrop]);\n    useEffect(() => {\n        if (!isOpen || !enforceFocus) {\n            return;\n        }\n\n        // Only add listener if this overlay is the most recent one\n        const lastOpened = getLastOpened();\n        const isTopOverlay = lastOpened?.id === id;\n\n        if (!isTopOverlay) {\n            return;\n        }\n\n        // Focus events do not bubble, but setting useCapture allows us to listen in and execute\n        // our handler before all others\n        document.addEventListener(\"focus\", handleDocumentFocus, /* useCapture */ true);\n\n        return () => {\n            document.removeEventListener(\"focus\", handleDocumentFocus, /* useCapture */ true);\n        };\n    }, [handleDocumentFocus, enforceFocus, isOpen, getLastOpened, id]);\n\n    const overlayWillCloseRef = useRef(overlayWillClose);\n    overlayWillCloseRef.current = overlayWillClose;\n    useEffect(() => {\n        // run cleanup code once on unmount, ensuring we call the most recent overlayWillClose callback\n        // by storing in a ref and keeping up to date\n        return () => {\n            overlayWillCloseRef.current();\n        };\n    }, []);\n\n    const handleTransitionExited = useCallback(\n        (node: HTMLElement) => {\n            const lastActiveElement = getRef(lastActiveElementBeforeOpened);\n            if (shouldReturnFocusOnClose && lastActiveElement instanceof HTMLElement) {\n                lastActiveElement.focus();\n            }\n            onClosed?.(node);\n        },\n        [onClosed, shouldReturnFocusOnClose],\n    );\n\n    // N.B. CSSTransition requires this callback to be defined, even if it's unused.\n    const handleTransitionAddEnd = useCallback(() => {\n        // no-op\n    }, []);\n\n    /**\n     * Gets the relevant DOM ref for a child element using the `childRef` or `childRefs` props (if possible).\n     * This ref is necessary for `CSSTransition` to work in React 18 without relying on `ReactDOM.findDOMNode`.\n     *\n     * Returns `undefined` if the user did not specify either of those props. In those cases, we use the ref we\n     * have locally generated and expect that the user _did not_ specify their own `ref` on the child element\n     * (it will get clobbered / overriden).\n     *\n     * @see https://reactcommunity.org/react-transition-group/css-transition\n     */\n    const getUserChildRef = useCallback(\n        (child: React.ReactNode) => {\n            if (childRef != null) {\n                return childRef;\n            } else if (childRefs != null) {\n                const key = (child as React.ReactElement).key;\n                if (key == null) {\n                    if (!isNodeEnv(\"production\")) {\n                        console.error(OVERLAY_CHILD_REQUIRES_KEY);\n                    }\n                    return undefined;\n                }\n                return childRefs[key];\n            }\n            return undefined;\n        },\n        [childRef, childRefs],\n    );\n\n    const maybeRenderChild = useCallback(\n        (child: React.ReactNode | undefined) => {\n            if (child == null || isEmptyString(child)) {\n                return null;\n            }\n\n            // decorate the child with a few injected props\n            const userChildRef = getUserChildRef(child);\n            const childProps = isReactElement(child) ? child.props : {};\n            // if the child is a string, number, or fragment, it will be wrapped in a <span> element\n            const decoratedChild = ensureElement(child, \"span\", {\n                className: classNames(childProps.className, Classes.OVERLAY_CONTENT),\n                // IMPORTANT: only inject our ref if the user didn't specify childRef or childRefs already. Otherwise,\n                // we risk clobbering the user's ref (which we cannot inspect here while cloning/decorating the child).\n                ref: userChildRef === undefined ? localChildRef : undefined,\n                tabIndex: enforceFocus || autoFocus ? 0 : undefined,\n            });\n            const resolvedChildRef = userChildRef ?? localChildRef;\n\n            return (\n                <CSSTransition\n                    addEndListener={handleTransitionAddEnd}\n                    classNames={transitionName}\n                    // HACKHACK: CSSTransition types are slightly incompatible with React types here.\n                    // React prefers `| null` but not `| undefined` for the ref value, while\n                    // CSSTransition _demands_ that `| undefined` be part of the element type.\n                    nodeRef={resolvedChildRef as React.RefObject<HTMLElement | undefined>}\n                    onEntered={getLifecycleCallbackWithChildRef(onOpened, resolvedChildRef)}\n                    onEntering={getLifecycleCallbackWithChildRef(onOpening, resolvedChildRef)}\n                    onExited={getLifecycleCallbackWithChildRef(handleTransitionExited, resolvedChildRef)}\n                    onExiting={getLifecycleCallbackWithChildRef(onClosing, resolvedChildRef)}\n                    timeout={transitionDuration}\n                >\n                    {decoratedChild}\n                </CSSTransition>\n            );\n        },\n        [\n            autoFocus,\n            enforceFocus,\n            getUserChildRef,\n            handleTransitionAddEnd,\n            handleTransitionExited,\n            onClosing,\n            onOpened,\n            onOpening,\n            transitionDuration,\n            transitionName,\n        ],\n    );\n\n    const handleBackdropMouseDown = useCallback(\n        (e: React.MouseEvent<HTMLDivElement>) => {\n            if (canOutsideClickClose) {\n                onClose?.(e);\n            }\n            if (enforceFocus) {\n                bringFocusInsideOverlay();\n            }\n            backdropProps?.onMouseDown?.(e);\n        },\n        [backdropProps, bringFocusInsideOverlay, canOutsideClickClose, enforceFocus, onClose],\n    );\n\n    const renderDummyElement = useCallback(\n        (key: string, dummyElementProps: HTMLDivProps & { ref?: React.Ref<HTMLDivElement> }) => (\n            <CSSTransition\n                addEndListener={handleTransitionAddEnd}\n                classNames={transitionName}\n                key={key}\n                nodeRef={dummyElementProps.ref}\n                timeout={transitionDuration}\n                unmountOnExit={true}\n            >\n                <div tabIndex={0} {...dummyElementProps} />\n            </CSSTransition>\n        ),\n        [handleTransitionAddEnd, transitionDuration, transitionName],\n    );\n\n    /**\n     * Ensures repeatedly pressing shift+tab keeps focus inside the Overlay. Moves focus to\n     * the `endFocusTrapElement` or the first keyboard-focusable element in the Overlay (excluding\n     * the `startFocusTrapElement`), depending on whether the element losing focus is inside the\n     * Overlay.\n     */\n    const handleStartFocusTrapElementFocus = useCallback(\n        (e: React.FocusEvent<HTMLDivElement>) => {\n            if (!enforceFocus || isAutoFocusing) {\n                return;\n            }\n            // e.relatedTarget will not be defined if this was a programmatic focus event, as is the\n            // case when we call this.bringFocusInsideOverlay() after a user clicked on the backdrop.\n            // Otherwise, we're handling a user interaction, and we should wrap around to the last\n            // element in this transition group.\n            const container = getRef(containerElement);\n            const endFocusTrap = getRef(endFocusTrapElement);\n            if (\n                e.relatedTarget != null &&\n                container?.contains(e.relatedTarget as Element) &&\n                e.relatedTarget !== endFocusTrap\n            ) {\n                endFocusTrap?.focus({ preventScroll: true });\n            }\n        },\n        [enforceFocus, isAutoFocusing],\n    );\n\n    /**\n     * Wrap around to the end of the dialog if `enforceFocus` is enabled.\n     */\n    const handleStartFocusTrapElementKeyDown = useCallback(\n        (e: React.KeyboardEvent<HTMLDivElement>) => {\n            if (!enforceFocus) {\n                return;\n            }\n            if (e.shiftKey && e.key === \"Tab\") {\n                const lastFocusableElement = getKeyboardFocusableElements(containerElement).pop();\n                if (lastFocusableElement != null) {\n                    lastFocusableElement.focus();\n                } else {\n                    getRef(endFocusTrapElement)?.focus({ preventScroll: true });\n                }\n            }\n        },\n        [enforceFocus],\n    );\n\n    /**\n     * Ensures repeatedly pressing tab keeps focus inside the Overlay. Moves focus to the\n     * `startFocusTrapElement` or the last keyboard-focusable element in the Overlay (excluding the\n     * `startFocusTrapElement`), depending on whether the element losing focus is inside the\n     * Overlay.\n     */\n    const handleEndFocusTrapElementFocus = useCallback(\n        (e: React.FocusEvent<HTMLDivElement>) => {\n            // No need for this.props.enforceFocus check here because this element is only rendered\n            // when that prop is true.\n            // During user interactions, e.relatedTarget will be defined, and we should wrap around to the\n            // \"start focus trap\" element.\n            // Otherwise, we're handling a programmatic focus event, which can only happen after a user\n            // presses shift+tab from the first focusable element in the overlay.\n            const startFocusTrap = getRef(startFocusTrapElement);\n            if (\n                e.relatedTarget != null &&\n                getRef(containerElement)?.contains(e.relatedTarget as Element) &&\n                e.relatedTarget !== startFocusTrap\n            ) {\n                const firstFocusableElement = getKeyboardFocusableElements(containerElement).shift();\n                // ensure we don't re-focus an already active element by comparing against e.relatedTarget\n                if (!isAutoFocusing && firstFocusableElement != null && firstFocusableElement !== e.relatedTarget) {\n                    firstFocusableElement.focus();\n                } else {\n                    startFocusTrap?.focus({ preventScroll: true });\n                }\n            } else {\n                const lastFocusableElement = getKeyboardFocusableElements(containerElement).pop();\n                if (lastFocusableElement != null) {\n                    lastFocusableElement.focus();\n                } else {\n                    // Keeps focus within Overlay even if there are no keyboard-focusable children\n                    startFocusTrap?.focus({ preventScroll: true });\n                }\n            }\n        },\n        [isAutoFocusing],\n    );\n\n    const maybeBackdrop = useMemo(\n        () =>\n            hasBackdrop && isOpen ? (\n                <CSSTransition\n                    classNames={transitionName}\n                    key=\"__backdrop\"\n                    nodeRef={backdropElement}\n                    timeout={transitionDuration}\n                    addEndListener={handleTransitionAddEnd}\n                >\n                    <div\n                        {...backdropProps}\n                        className={classNames(Classes.OVERLAY_BACKDROP, backdropClassName, backdropProps?.className)}\n                        onMouseDown={handleBackdropMouseDown}\n                        ref={backdropElement}\n                    />\n                </CSSTransition>\n            ) : null,\n        [\n            backdropClassName,\n            backdropProps,\n            handleBackdropMouseDown,\n            handleTransitionAddEnd,\n            hasBackdrop,\n            isOpen,\n            transitionDuration,\n            transitionName,\n        ],\n    );\n\n    // no reason to render anything at all if we're being truly lazy\n    if (lazy && !hasEverOpened) {\n        return null;\n    }\n\n    // TransitionGroup types require single array of children; does not support nested arrays.\n    // So we must collapse backdrop and children into one array, and every item must be wrapped in a\n    // Transition element (no ReactText allowed).\n    const childrenWithTransitions = isOpen ? Children.map(children, maybeRenderChild) ?? [] : [];\n\n    // const maybeBackdrop = maybeRenderBackdrop();\n    if (maybeBackdrop !== null) {\n        childrenWithTransitions.unshift(maybeBackdrop);\n    }\n    if (isOpen && (autoFocus || enforceFocus) && childrenWithTransitions.length > 0) {\n        childrenWithTransitions.unshift(\n            renderDummyElement(\"__start\", {\n                className: Classes.OVERLAY_START_FOCUS_TRAP,\n                onFocus: handleStartFocusTrapElementFocus,\n                onKeyDown: handleStartFocusTrapElementKeyDown,\n                ref: startFocusTrapElement,\n            }),\n        );\n        if (enforceFocus) {\n            childrenWithTransitions.push(\n                renderDummyElement(\"__end\", {\n                    className: Classes.OVERLAY_END_FOCUS_TRAP,\n                    onFocus: handleEndFocusTrapElementFocus,\n                    ref: endFocusTrapElement,\n                }),\n            );\n        }\n    }\n\n    const transitionGroup = (\n        <div\n            aria-live=\"polite\"\n            className={classNames(\n                Classes.OVERLAY,\n                {\n                    [Classes.OVERLAY_OPEN]: isOpen,\n                    [Classes.OVERLAY_INLINE]: !usePortal,\n                },\n                className,\n            )}\n            onKeyDown={handleContainerKeyDown}\n            ref={containerElement}\n        >\n            <TransitionGroup appear={true} component={null}>\n                {childrenWithTransitions}\n            </TransitionGroup>\n        </div>\n    );\n\n    if (usePortal) {\n        return (\n            <Portal className={portalClassName} container={portalContainer}>\n                {transitionGroup}\n            </Portal>\n        );\n    } else {\n        return transitionGroup;\n    }\n});\n// eslint-disable-next-line @typescript-eslint/no-deprecated\nOverlay2.defaultProps = OVERLAY2_DEFAULT_PROPS;\nOverlay2.displayName = `${DISPLAYNAME_PREFIX}.Overlay2`;\n\nfunction useOverlay2Validation({ childRef, childRefs, children }: Overlay2Props) {\n    const numChildren = Children.count(children);\n    useEffect(() => {\n        if (isNodeEnv(\"production\")) {\n            return;\n        }\n\n        if (childRef != null && childRefs != null) {\n            console.error(OVERLAY_CHILD_REF_AND_REFS_MUTEX);\n        }\n\n        if (numChildren > 1 && childRefs == null) {\n            console.error(OVERLAY_WITH_MULTIPLE_CHILDREN_REQUIRES_CHILD_REFS);\n        }\n    }, [childRef, childRefs, numChildren]);\n}\n\n/**\n * Generates a unique ID for a given Overlay which persists across the component's lifecycle.\n */\nfunction useOverlay2ID(): string {\n    const id = useId();\n    return `${Overlay2.displayName}-${id}`;\n}\n\n// N.B. the `onExiting` callback is not provided with the `node` argument as suggested in CSSTransition types since\n// we are using the `nodeRef` prop, so we must inject it dynamically.\nfunction getLifecycleCallbackWithChildRef(\n    callback: ((node: HTMLElement) => void) | undefined,\n    childRef: React.RefObject<HTMLElement> | undefined,\n) {\n    return () => {\n        if (childRef?.current != null) {\n            callback?.(childRef.current);\n        }\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}