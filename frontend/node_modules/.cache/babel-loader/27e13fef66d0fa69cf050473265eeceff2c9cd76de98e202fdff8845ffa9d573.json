{"ast":null,"code":"import { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\n/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport classNames from \"classnames\";\nimport { IconSize } from \"@blueprintjs/icons\";\nimport { AbstractPureComponent, Classes, refHandler, setRef, Utils } from \"../../common\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\nimport { getActiveElement } from \"../../common/utils\";\nimport { Icon } from \"../icon/icon\";\nimport { Tag } from \"../tag/tag\";\nimport { ResizableInput } from \"./resizableInput\";\n/** special value for absence of active tag */\nconst NONE = -1;\n/**\n * Tag input component.\n *\n * @see https://blueprintjs.com/docs/#core/components/tag-input\n */\nexport class TagInput extends AbstractPureComponent {\n  constructor() {\n    super(...arguments);\n    this.state = {\n      activeIndex: NONE,\n      inputValue: this.props.inputValue || \"\",\n      isInputFocused: false\n    };\n    this.inputElement = null;\n    this.handleRef = refHandler(this, \"inputElement\", this.props.inputRef);\n    this.addTags = (value, method = \"default\") => {\n      const {\n        inputValue,\n        onAdd,\n        onChange,\n        values\n      } = this.props;\n      const newValues = this.getValues(value);\n      let shouldClearInput = (onAdd === null || onAdd === void 0 ? void 0 : onAdd(newValues, method)) !== false && inputValue === undefined;\n      // avoid a potentially expensive computation if this prop is omitted\n      if (Utils.isFunction(onChange)) {\n        shouldClearInput = onChange([...values, ...newValues]) !== false && shouldClearInput;\n      }\n      // only explicit return false cancels text clearing\n      if (shouldClearInput) {\n        this.setState({\n          inputValue: \"\"\n        });\n      }\n    };\n    this.maybeRenderTag = (tag, index) => {\n      if (!tag) {\n        return null;\n      }\n      // eslint-disable-next-line @typescript-eslint/no-deprecated\n      const {\n        large,\n        size,\n        tagProps\n      } = this.props;\n      const props = Utils.isFunction(tagProps) ? tagProps(tag, index) : tagProps;\n      return _jsx(Tag, {\n        active: index === this.state.activeIndex,\n        \"data-tag-index\": index,\n        // eslint-disable-next-line @typescript-eslint/no-deprecated\n        large: large,\n        onRemove: this.props.disabled ? undefined : this.handleRemoveTag,\n        size: size,\n        ...props,\n        children: tag\n      }, tag + \"__\" + index);\n    };\n    this.handleContainerClick = () => {\n      var _a;\n      (_a = this.inputElement) === null || _a === void 0 ? void 0 : _a.focus();\n    };\n    this.handleContainerBlur = ({\n      currentTarget\n    }) => {\n      this.requestAnimationFrame(() => {\n        // we only care if the blur event is leaving the container.\n        // defer this check using rAF so activeElement will have updated.\n        const isFocusInsideContainer = currentTarget.contains(getActiveElement(this.inputElement));\n        if (!isFocusInsideContainer) {\n          if (this.props.addOnBlur && this.state.inputValue !== undefined && this.state.inputValue.length > 0) {\n            this.addTags(this.state.inputValue, \"blur\");\n          }\n          this.setState({\n            activeIndex: NONE,\n            isInputFocused: false\n          });\n        }\n      });\n    };\n    this.handleInputFocus = event => {\n      var _a, _b;\n      this.setState({\n        isInputFocused: true\n      });\n      (_b = (_a = this.props.inputProps) === null || _a === void 0 ? void 0 : _a.onFocus) === null || _b === void 0 ? void 0 : _b.call(_a, event);\n    };\n    this.handleInputChange = event => {\n      var _a, _b, _c, _d;\n      this.setState({\n        activeIndex: NONE,\n        inputValue: event.currentTarget.value\n      });\n      (_b = (_a = this.props).onInputChange) === null || _b === void 0 ? void 0 : _b.call(_a, event);\n      (_d = (_c = this.props.inputProps) === null || _c === void 0 ? void 0 : _c.onChange) === null || _d === void 0 ? void 0 : _d.call(_c, event);\n    };\n    this.handleInputKeyDown = event => {\n      const {\n        selectionEnd,\n        value\n      } = event.currentTarget;\n      const {\n        activeIndex\n      } = this.state;\n      let activeIndexToEmit = activeIndex;\n      // do not add a new tag if the user is composing (e.g. for Japanese or Chinese)\n      if (event.key === \"Enter\" && !event.nativeEvent.isComposing && value.length > 0) {\n        this.addTags(value, \"default\");\n      } else if (selectionEnd === 0 && this.props.values.length > 0) {\n        // cursor at beginning of input allows interaction with tags.\n        // use selectionEnd to verify cursor position and no text selection.\n        const direction = Utils.getArrowKeyDirection(event, [\"ArrowLeft\"], [\"ArrowRight\"]);\n        if (direction !== undefined) {\n          const nextActiveIndex = this.getNextActiveIndex(direction);\n          if (nextActiveIndex !== activeIndex) {\n            event.stopPropagation();\n            activeIndexToEmit = nextActiveIndex;\n            this.setState({\n              activeIndex: nextActiveIndex\n            });\n          }\n        } else if (event.key === \"Backspace\") {\n          this.handleBackspaceToRemove(event);\n        } else if (event.key === \"Delete\") {\n          this.handleDeleteToRemove(event);\n        }\n      }\n      this.invokeKeyPressCallback(\"onKeyDown\", event, activeIndexToEmit);\n    };\n    this.handleInputKeyUp = event => {\n      this.invokeKeyPressCallback(\"onKeyUp\", event, this.state.activeIndex);\n    };\n    this.handleInputPaste = event => {\n      const {\n        separator\n      } = this.props;\n      const value = event.clipboardData.getData(\"text\");\n      if (!this.props.addOnPaste || value.length === 0) {\n        return;\n      }\n      // special case as a UX nicety: if the user pasted only one value with no delimiters in it, leave that value in\n      // the input field so that the user can refine it before converting it to a tag manually.\n      if (separator === false || value.split(separator).length === 1) {\n        return;\n      }\n      event.preventDefault();\n      this.addTags(value, \"paste\");\n    };\n    this.handleRemoveTag = event => {\n      // using data attribute to simplify callback logic -- one handler for all children\n      const index = +event.currentTarget.parentElement.getAttribute(\"data-tag-index\");\n      this.removeIndexFromValues(index);\n    };\n  }\n  static getDerivedStateFromProps(props, state) {\n    if (props.inputValue !== state.prevInputValueProp) {\n      return {\n        inputValue: props.inputValue,\n        prevInputValueProp: props.inputValue\n      };\n    }\n    return null;\n  }\n  render() {\n    const {\n      autoResize,\n      className,\n      disabled,\n      fill,\n      inputProps,\n      intent,\n      // eslint-disable-next-line @typescript-eslint/no-deprecated\n      large,\n      leftIcon,\n      placeholder,\n      size = \"medium\",\n      values\n    } = this.props;\n    const classes = classNames(Classes.INPUT, Classes.TAG_INPUT, {\n      [Classes.ACTIVE]: this.state.isInputFocused,\n      [Classes.DISABLED]: disabled,\n      [Classes.FILL]: fill\n    }, Classes.intentClass(intent), Classes.sizeClass(size, {\n      large\n    }), className);\n    const isLarge = classes.indexOf(Classes.LARGE) > NONE;\n    // use placeholder prop only if it's defined and values list is empty or contains only falsy values\n    const isSomeValueDefined = values.some(val => !!val);\n    const resolvedPlaceholder = placeholder == null || isSomeValueDefined ? inputProps === null || inputProps === void 0 ? void 0 : inputProps.placeholder : placeholder;\n    // final props that may be sent to <input> or <ResizableInput>\n    const resolvedInputProps = {\n      value: this.state.inputValue,\n      ...inputProps,\n      className: classNames(Classes.INPUT_GHOST, inputProps === null || inputProps === void 0 ? void 0 : inputProps.className),\n      disabled,\n      onChange: this.handleInputChange,\n      onFocus: this.handleInputFocus,\n      onKeyDown: this.handleInputKeyDown,\n      onKeyUp: this.handleInputKeyUp,\n      onPaste: this.handleInputPaste,\n      placeholder: resolvedPlaceholder,\n      ref: this.handleRef\n    };\n    return _jsxs(\"div\", {\n      className: classes,\n      onBlur: this.handleContainerBlur,\n      onClick: this.handleContainerClick,\n      children: [_jsx(Icon, {\n        className: Classes.TAG_INPUT_ICON,\n        icon: leftIcon,\n        size: isLarge ? IconSize.LARGE : IconSize.STANDARD\n      }), _jsxs(\"div\", {\n        className: Classes.TAG_INPUT_VALUES,\n        children: [values.map(this.maybeRenderTag), this.props.children, autoResize ? _jsx(ResizableInput, {\n          ...resolvedInputProps\n        }) : _jsx(\"input\", {\n          ...resolvedInputProps\n        })]\n      }), this.props.rightElement]\n    });\n  }\n  componentDidUpdate(prevProps) {\n    if (prevProps.inputRef !== this.props.inputRef) {\n      setRef(prevProps.inputRef, null);\n      this.handleRef = refHandler(this, \"inputElement\", this.props.inputRef);\n      setRef(this.props.inputRef, this.inputElement);\n    }\n  }\n  getNextActiveIndex(direction) {\n    const {\n      activeIndex\n    } = this.state;\n    if (activeIndex === NONE) {\n      // nothing active & moving left: select last defined value. otherwise select nothing.\n      return direction < 0 ? this.findNextIndex(this.props.values.length, -1) : NONE;\n    } else {\n      // otherwise, move in direction and clamp to bounds.\n      // note that upper bound allows going one beyond last item\n      // so focus can move off the right end, into the text input.\n      return this.findNextIndex(activeIndex, direction);\n    }\n  }\n  findNextIndex(startIndex, direction) {\n    const {\n      values\n    } = this.props;\n    let index = startIndex + direction;\n    while (index > 0 && index < values.length && !values[index]) {\n      index += direction;\n    }\n    return Utils.clamp(index, 0, values.length);\n  }\n  /**\n   * Splits inputValue on separator prop,\n   * trims whitespace from each new value,\n   * and ignores empty values.\n   */\n  getValues(inputValue) {\n    const {\n      separator\n    } = this.props;\n    // NOTE: split() typings define two overrides for string and RegExp.\n    // this does not play well with our union prop type, so we'll just declare it as a valid type.\n    return (separator === false ? [inputValue] : inputValue.split(separator)).map(val => val.trim()).filter(val => val.length > 0);\n  }\n  handleBackspaceToRemove(event) {\n    const previousActiveIndex = this.state.activeIndex;\n    // always move leftward one item (this will focus last item if nothing is focused)\n    this.setState({\n      activeIndex: this.getNextActiveIndex(-1)\n    });\n    // delete item if there was a previous valid selection (ignore first backspace to focus last item)\n    if (this.isValidIndex(previousActiveIndex)) {\n      event.stopPropagation();\n      this.removeIndexFromValues(previousActiveIndex);\n    }\n  }\n  handleDeleteToRemove(event) {\n    const {\n      activeIndex\n    } = this.state;\n    if (this.isValidIndex(activeIndex)) {\n      event.stopPropagation();\n      this.removeIndexFromValues(activeIndex);\n    }\n  }\n  /** Remove the item at the given index by invoking `onRemove` and `onChange` accordingly. */\n  removeIndexFromValues(index) {\n    const {\n      onChange,\n      onRemove,\n      values\n    } = this.props;\n    onRemove === null || onRemove === void 0 ? void 0 : onRemove(values[index], index);\n    onChange === null || onChange === void 0 ? void 0 : onChange(values.filter((_, i) => i !== index));\n  }\n  invokeKeyPressCallback(propCallbackName, event, activeIndex) {\n    var _a, _b, _c, _d;\n    (_b = (_a = this.props)[propCallbackName]) === null || _b === void 0 ? void 0 : _b.call(_a, event, activeIndex === NONE ? undefined : activeIndex);\n    (_d = (_c = this.props.inputProps)[propCallbackName]) === null || _d === void 0 ? void 0 : _d.call(_c, event);\n  }\n  /** Returns whether the given index represents a valid item in `this.props.values`. */\n  isValidIndex(index) {\n    return index !== NONE && index < this.props.values.length;\n  }\n}\nTagInput.displayName = `${DISPLAYNAME_PREFIX}.TagInput`;\nTagInput.defaultProps = {\n  addOnBlur: false,\n  addOnPaste: true,\n  autoResize: false,\n  inputProps: {},\n  separator: /[,\\n\\r]/,\n  tagProps: {}\n};","map":{"version":3,"names":["classNames","IconSize","AbstractPureComponent","Classes","refHandler","setRef","Utils","DISPLAYNAME_PREFIX","getActiveElement","Icon","Tag","ResizableInput","NONE","TagInput","constructor","state","activeIndex","inputValue","props","isInputFocused","inputElement","handleRef","inputRef","addTags","value","method","onAdd","onChange","values","newValues","getValues","shouldClearInput","undefined","isFunction","setState","maybeRenderTag","tag","index","large","size","tagProps","_jsx","active","onRemove","disabled","handleRemoveTag","children","handleContainerClick","_a","focus","handleContainerBlur","currentTarget","requestAnimationFrame","isFocusInsideContainer","contains","addOnBlur","length","handleInputFocus","event","_b","inputProps","onFocus","call","handleInputChange","onInputChange","_d","_c","handleInputKeyDown","selectionEnd","activeIndexToEmit","key","nativeEvent","isComposing","direction","getArrowKeyDirection","nextActiveIndex","getNextActiveIndex","stopPropagation","handleBackspaceToRemove","handleDeleteToRemove","invokeKeyPressCallback","handleInputKeyUp","handleInputPaste","separator","clipboardData","getData","addOnPaste","split","preventDefault","parentElement","getAttribute","removeIndexFromValues","getDerivedStateFromProps","prevInputValueProp","render","autoResize","className","fill","intent","leftIcon","placeholder","classes","INPUT","TAG_INPUT","ACTIVE","DISABLED","FILL","intentClass","sizeClass","isLarge","indexOf","LARGE","isSomeValueDefined","some","val","resolvedPlaceholder","resolvedInputProps","INPUT_GHOST","onKeyDown","onKeyUp","onPaste","ref","_jsxs","onBlur","onClick","TAG_INPUT_ICON","icon","STANDARD","TAG_INPUT_VALUES","map","rightElement","componentDidUpdate","prevProps","findNextIndex","startIndex","clamp","trim","filter","previousActiveIndex","isValidIndex","_","i","propCallbackName","displayName","defaultProps"],"sources":["/Users/husseingalal/Desktop/Hackathon/Elrond/frontend/node_modules/@blueprintjs/core/src/components/tag-input/tagInput.tsx"],"sourcesContent":["/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport classNames from \"classnames\";\n\nimport { type IconName, IconSize } from \"@blueprintjs/icons\";\n\nimport { AbstractPureComponent, Classes, type NonSmallSize, refHandler, setRef, Utils } from \"../../common\";\nimport {\n    DISPLAYNAME_PREFIX,\n    type HTMLInputProps,\n    type IntentProps,\n    type MaybeElement,\n    type Props,\n} from \"../../common/props\";\nimport { getActiveElement } from \"../../common/utils\";\nimport { Icon } from \"../icon/icon\";\nimport { Tag, type TagProps } from \"../tag/tag\";\n\nimport { ResizableInput } from \"./resizableInput\";\n\n/**\n * The method in which a `TagInput` value was added.\n * - `\"default\"` - indicates that a value was added by manual selection.\n * - `\"blur\"` - indicates that a value was added when the `TagInput` lost focus.\n *   This is only possible when `addOnBlur=true`.\n * - `\"paste\"` - indicates that a value was added via paste. This is only\n *   possible when `addOnPaste=true`.\n */\nexport type TagInputAddMethod = \"default\" | \"blur\" | \"paste\";\n\nexport interface TagInputProps extends IntentProps, Props {\n    /**\n     * If true, `onAdd` will be invoked when the input loses focus.\n     * Otherwise, `onAdd` is only invoked when `enter` is pressed.\n     *\n     * @default false\n     */\n    addOnBlur?: boolean;\n\n    /**\n     * If true, `onAdd` will be invoked when the user pastes text containing the `separator`\n     * into the input. Otherwise, pasted text will remain in the input.\n     *\n     * __Note:__ For example, if `addOnPaste=true` and `separator=\"\\n\"` (new line), then:\n     * - Pasting `\"hello\"` will _not_ invoke `onAdd`\n     * - Pasting `\"hello\\n\"` will invoke `onAdd` with `[\"hello\"]`\n     * - Pasting `\"hello\\nworld\"` will invoke `onAdd` with `[\"hello\", \"world\"]`\n     *\n     * @default true\n     */\n    addOnPaste?: boolean;\n\n    /**\n     * Whether the component should automatically resize as a user types in the text input.\n     * This will have no effect when `fill={true}`.\n     *\n     * @default false\n     */\n    autoResize?: boolean;\n\n    /**\n     * Optional child elements which will be rendered between the selected tags and\n     * the text input. Rendering children is usually unnecessary.\n     *\n     * @default undefined\n     */\n    children?: React.ReactNode;\n\n    /**\n     * Whether the component is non-interactive.\n     * Note that you'll also need to disable the component's `rightElement`,\n     * if appropriate.\n     *\n     * @default false\n     */\n    disabled?: boolean;\n\n    /** Whether the tag input should take up the full width of its container. */\n    fill?: boolean;\n\n    /**\n     * React props to pass to the `<input>` element.\n     * Note that `ref` and `key` are not supported here; use `inputRef` below.\n     * Also note that `inputProps.style.width` will be overriden if `autoResize={true}`.\n     */\n    inputProps?: HTMLInputProps;\n\n    /** Ref handler for the `<input>` element. */\n    inputRef?: React.Ref<HTMLInputElement>;\n\n    /** Controlled value of the `<input>` element. This is shorthand for `inputProps={{ value }}`. */\n    inputValue?: string;\n\n    /**\n     * Whether the tag input should use a large size.\n     *\n     * @deprecated use `size=\"large\"` instead.\n     * @default false\n     */\n    large?: boolean;\n\n    /** Name of a Blueprint UI icon (or an icon element) to render on the left side of the input. */\n    leftIcon?: IconName | MaybeElement;\n\n    /**\n     * Callback invoked when new tags are added by the user pressing `enter` on the input.\n     * Receives the current value of the input field split by `separator` into an array.\n     * New tags are expected to be appended to the list.\n     *\n     * The input will be cleared after `onAdd` is invoked _unless_ the callback explicitly\n     * returns `false`. This is useful if the provided `value` is somehow invalid and should\n     * not be added as a tag.\n     */\n    onAdd?: (values: string[], method: TagInputAddMethod) => boolean | void;\n\n    /**\n     * Callback invoked when new tags are added or removed. Receives the updated list of `values`:\n     * new tags are appended to the end of the list, removed tags are removed at their index.\n     *\n     * Like `onAdd`, the input will be cleared after this handler is invoked _unless_ the callback\n     * explicitly returns `false`.\n     *\n     * This callback essentially implements basic `onAdd` and `onRemove` functionality and merges\n     * the two handlers into one to simplify controlled usage.\n     * ```\n     */\n    onChange?: (values: React.ReactNode[]) => boolean | void;\n\n    /**\n     * Callback invoked when the value of `<input>` element is changed.\n     * This is shorthand for `inputProps={{ onChange }}`.\n     */\n    onInputChange?: React.FormEventHandler<HTMLInputElement>;\n\n    /**\n     * Callback invoked when the user depresses a keyboard key.\n     * Receives the event and the index of the active tag (or `undefined` if\n     * focused in the input).\n     */\n    onKeyDown?: (event: React.KeyboardEvent<HTMLElement>, index?: number) => void;\n\n    /**\n     * Callback invoked when the user releases a keyboard key.\n     * Receives the event and the index of the active tag (or `undefined` if\n     * focused in the input).\n     */\n    onKeyUp?: (event: React.KeyboardEvent<HTMLElement>, index?: number) => void;\n\n    /**\n     * Callback invoked when the user clicks the X button on a tag.\n     * Receives value and index of removed tag.\n     */\n    onRemove?: (value: React.ReactNode, index: number) => void;\n\n    /**\n     * Input placeholder text which will not appear if `values` contains any items\n     * (consistent with default HTML input behavior).\n     * Use `inputProps.placeholder` if you want the placeholder text to _always_ appear.\n     *\n     * If you define both `placeholder` and `inputProps.placeholder`, then the former will appear\n     * when `values` is empty and the latter at all other times.\n     */\n    placeholder?: string;\n\n    /**\n     * Element to render on right side of input.\n     * For best results, use a small spinner or minimal button (button height will adjust if `TagInput` uses large styles).\n     * Other elements will likely require custom styles for correct positioning.\n     */\n    rightElement?: React.JSX.Element;\n\n    /**\n     * Separator pattern used to split input text into multiple values. Default value splits on commas and newlines.\n     * Explicit `false` value disables splitting (note that `onAdd` will still receive an array of length 1).\n     *\n     * @default /[,\\n\\r]/\n     */\n    separator?: string | RegExp | false;\n\n    /**\n     * The size of the tag input.\n     *\n     * @default \"medium\"\n     */\n    size?: NonSmallSize;\n\n    /**\n     * React props to pass to each `Tag`. Provide an object to pass the same props to every tag,\n     * or a function to customize props per tag.\n     *\n     * If you define `onRemove` here then you will have to implement your own tag removal\n     * handling as `TagInput`'s own `onRemove` handler will never be invoked.\n     */\n    tagProps?: TagProps | ((value: React.ReactNode, index: number) => TagProps);\n\n    /**\n     * Controlled tag values. Each value will be rendered inside a `Tag`, which can be customized\n     * using `tagProps`. Therefore, any valid React node can be used as a `TagInput` value; falsy\n     * values will not be rendered.\n     */\n    values: readonly React.ReactNode[];\n}\n\nexport interface TagInputState {\n    activeIndex: number;\n    inputValue: string;\n    isInputFocused: boolean;\n    prevInputValueProp?: string;\n}\n\n/** special value for absence of active tag */\nconst NONE = -1;\n\n/**\n * Tag input component.\n *\n * @see https://blueprintjs.com/docs/#core/components/tag-input\n */\nexport class TagInput extends AbstractPureComponent<TagInputProps, TagInputState> {\n    public static displayName = `${DISPLAYNAME_PREFIX}.TagInput`;\n\n    public static defaultProps: Partial<TagInputProps> = {\n        addOnBlur: false,\n        addOnPaste: true,\n        autoResize: false,\n        inputProps: {},\n        separator: /[,\\n\\r]/,\n        tagProps: {},\n    };\n\n    public static getDerivedStateFromProps(\n        props: Readonly<TagInputProps>,\n        state: Readonly<TagInputState>,\n    ): Partial<TagInputState> | null {\n        if (props.inputValue !== state.prevInputValueProp) {\n            return {\n                inputValue: props.inputValue,\n                prevInputValueProp: props.inputValue,\n            };\n        }\n        return null;\n    }\n\n    public state: TagInputState = {\n        activeIndex: NONE,\n        inputValue: this.props.inputValue || \"\",\n        isInputFocused: false,\n    };\n\n    public inputElement: HTMLInputElement | null = null;\n\n    private handleRef: React.Ref<HTMLInputElement> = refHandler(this, \"inputElement\", this.props.inputRef);\n\n    public render() {\n        const {\n            autoResize,\n            className,\n            disabled,\n            fill,\n            inputProps,\n            intent,\n            // eslint-disable-next-line @typescript-eslint/no-deprecated\n            large,\n            leftIcon,\n            placeholder,\n            size = \"medium\",\n            values,\n        } = this.props;\n\n        const classes = classNames(\n            Classes.INPUT,\n            Classes.TAG_INPUT,\n            {\n                [Classes.ACTIVE]: this.state.isInputFocused,\n                [Classes.DISABLED]: disabled,\n                [Classes.FILL]: fill,\n            },\n            Classes.intentClass(intent),\n            Classes.sizeClass(size, { large }),\n            className,\n        );\n        const isLarge = classes.indexOf(Classes.LARGE) > NONE;\n\n        // use placeholder prop only if it's defined and values list is empty or contains only falsy values\n        const isSomeValueDefined = values.some(val => !!val);\n        const resolvedPlaceholder = placeholder == null || isSomeValueDefined ? inputProps?.placeholder : placeholder;\n\n        // final props that may be sent to <input> or <ResizableInput>\n        const resolvedInputProps = {\n            value: this.state.inputValue,\n            ...inputProps,\n            className: classNames(Classes.INPUT_GHOST, inputProps?.className),\n            disabled,\n            onChange: this.handleInputChange,\n            onFocus: this.handleInputFocus,\n            onKeyDown: this.handleInputKeyDown,\n            onKeyUp: this.handleInputKeyUp,\n            onPaste: this.handleInputPaste,\n            placeholder: resolvedPlaceholder,\n            ref: this.handleRef,\n        } satisfies React.HTMLProps<HTMLElement>;\n\n        return (\n            <div className={classes} onBlur={this.handleContainerBlur} onClick={this.handleContainerClick}>\n                <Icon\n                    className={Classes.TAG_INPUT_ICON}\n                    icon={leftIcon}\n                    size={isLarge ? IconSize.LARGE : IconSize.STANDARD}\n                />\n                <div className={Classes.TAG_INPUT_VALUES}>\n                    {values.map(this.maybeRenderTag)}\n                    {this.props.children}\n                    {autoResize ? <ResizableInput {...resolvedInputProps} /> : <input {...resolvedInputProps} />}\n                </div>\n                {this.props.rightElement}\n            </div>\n        );\n    }\n\n    public componentDidUpdate(prevProps: TagInputProps) {\n        if (prevProps.inputRef !== this.props.inputRef) {\n            setRef(prevProps.inputRef, null);\n            this.handleRef = refHandler(this, \"inputElement\", this.props.inputRef);\n            setRef(this.props.inputRef, this.inputElement);\n        }\n    }\n\n    private addTags = (value: string, method: TagInputAddMethod = \"default\") => {\n        const { inputValue, onAdd, onChange, values } = this.props;\n        const newValues = this.getValues(value);\n        let shouldClearInput = onAdd?.(newValues, method) !== false && inputValue === undefined;\n        // avoid a potentially expensive computation if this prop is omitted\n        if (Utils.isFunction(onChange)) {\n            shouldClearInput = onChange([...values, ...newValues]) !== false && shouldClearInput;\n        }\n        // only explicit return false cancels text clearing\n        if (shouldClearInput) {\n            this.setState({ inputValue: \"\" });\n        }\n    };\n\n    private maybeRenderTag = (tag: React.ReactNode, index: number) => {\n        if (!tag) {\n            return null;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-deprecated\n        const { large, size, tagProps } = this.props;\n        const props = Utils.isFunction(tagProps) ? tagProps(tag, index) : tagProps;\n        return (\n            <Tag\n                active={index === this.state.activeIndex}\n                data-tag-index={index}\n                key={tag + \"__\" + index}\n                // eslint-disable-next-line @typescript-eslint/no-deprecated\n                large={large}\n                onRemove={this.props.disabled ? undefined : this.handleRemoveTag}\n                size={size}\n                {...props}\n            >\n                {tag}\n            </Tag>\n        );\n    };\n\n    private getNextActiveIndex(direction: 1 | -1) {\n        const { activeIndex } = this.state;\n        if (activeIndex === NONE) {\n            // nothing active & moving left: select last defined value. otherwise select nothing.\n            return direction < 0 ? this.findNextIndex(this.props.values.length, -1) : NONE;\n        } else {\n            // otherwise, move in direction and clamp to bounds.\n            // note that upper bound allows going one beyond last item\n            // so focus can move off the right end, into the text input.\n            return this.findNextIndex(activeIndex, direction);\n        }\n    }\n\n    private findNextIndex(startIndex: number, direction: 1 | -1) {\n        const { values } = this.props;\n        let index = startIndex + direction;\n        while (index > 0 && index < values.length && !values[index]) {\n            index += direction;\n        }\n        return Utils.clamp(index, 0, values.length);\n    }\n\n    /**\n     * Splits inputValue on separator prop,\n     * trims whitespace from each new value,\n     * and ignores empty values.\n     */\n    private getValues(inputValue: string) {\n        const { separator } = this.props;\n        // NOTE: split() typings define two overrides for string and RegExp.\n        // this does not play well with our union prop type, so we'll just declare it as a valid type.\n        return (separator === false ? [inputValue] : inputValue.split(separator as string))\n            .map(val => val.trim())\n            .filter(val => val.length > 0);\n    }\n\n    private handleContainerClick = () => {\n        this.inputElement?.focus();\n    };\n\n    private handleContainerBlur = ({ currentTarget }: React.FocusEvent<HTMLDivElement>) => {\n        this.requestAnimationFrame(() => {\n            // we only care if the blur event is leaving the container.\n            // defer this check using rAF so activeElement will have updated.\n            const isFocusInsideContainer = currentTarget.contains(getActiveElement(this.inputElement));\n            if (!isFocusInsideContainer) {\n                if (this.props.addOnBlur && this.state.inputValue !== undefined && this.state.inputValue.length > 0) {\n                    this.addTags(this.state.inputValue, \"blur\");\n                }\n                this.setState({ activeIndex: NONE, isInputFocused: false });\n            }\n        });\n    };\n\n    private handleInputFocus = (event: React.FocusEvent<HTMLInputElement>) => {\n        this.setState({ isInputFocused: true });\n        this.props.inputProps?.onFocus?.(event);\n    };\n\n    private handleInputChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n        this.setState({ activeIndex: NONE, inputValue: event.currentTarget.value });\n        this.props.onInputChange?.(event);\n        this.props.inputProps?.onChange?.(event);\n    };\n\n    private handleInputKeyDown = (event: React.KeyboardEvent<HTMLInputElement>) => {\n        const { selectionEnd, value } = event.currentTarget;\n        const { activeIndex } = this.state;\n\n        let activeIndexToEmit = activeIndex;\n\n        // do not add a new tag if the user is composing (e.g. for Japanese or Chinese)\n        if (event.key === \"Enter\" && !event.nativeEvent.isComposing && value.length > 0) {\n            this.addTags(value, \"default\");\n        } else if (selectionEnd === 0 && this.props.values.length > 0) {\n            // cursor at beginning of input allows interaction with tags.\n            // use selectionEnd to verify cursor position and no text selection.\n            const direction = Utils.getArrowKeyDirection(event, [\"ArrowLeft\"], [\"ArrowRight\"]);\n            if (direction !== undefined) {\n                const nextActiveIndex = this.getNextActiveIndex(direction);\n                if (nextActiveIndex !== activeIndex) {\n                    event.stopPropagation();\n                    activeIndexToEmit = nextActiveIndex;\n                    this.setState({ activeIndex: nextActiveIndex });\n                }\n            } else if (event.key === \"Backspace\") {\n                this.handleBackspaceToRemove(event);\n            } else if (event.key === \"Delete\") {\n                this.handleDeleteToRemove(event);\n            }\n        }\n\n        this.invokeKeyPressCallback(\"onKeyDown\", event, activeIndexToEmit);\n    };\n\n    private handleInputKeyUp = (event: React.KeyboardEvent<HTMLInputElement>) => {\n        this.invokeKeyPressCallback(\"onKeyUp\", event, this.state.activeIndex);\n    };\n\n    private handleInputPaste = (event: React.ClipboardEvent<HTMLInputElement>) => {\n        const { separator } = this.props;\n        const value = event.clipboardData.getData(\"text\");\n\n        if (!this.props.addOnPaste || value.length === 0) {\n            return;\n        }\n\n        // special case as a UX nicety: if the user pasted only one value with no delimiters in it, leave that value in\n        // the input field so that the user can refine it before converting it to a tag manually.\n        if (separator === false || value.split(separator!).length === 1) {\n            return;\n        }\n\n        event.preventDefault();\n        this.addTags(value, \"paste\");\n    };\n\n    private handleRemoveTag = (event: React.MouseEvent<HTMLSpanElement>) => {\n        // using data attribute to simplify callback logic -- one handler for all children\n        const index = +event.currentTarget.parentElement!.getAttribute(\"data-tag-index\")!;\n        this.removeIndexFromValues(index);\n    };\n\n    private handleBackspaceToRemove(event: React.KeyboardEvent<HTMLInputElement>) {\n        const previousActiveIndex = this.state.activeIndex;\n        // always move leftward one item (this will focus last item if nothing is focused)\n        this.setState({ activeIndex: this.getNextActiveIndex(-1) });\n        // delete item if there was a previous valid selection (ignore first backspace to focus last item)\n        if (this.isValidIndex(previousActiveIndex)) {\n            event.stopPropagation();\n            this.removeIndexFromValues(previousActiveIndex);\n        }\n    }\n\n    private handleDeleteToRemove(event: React.KeyboardEvent<HTMLInputElement>) {\n        const { activeIndex } = this.state;\n        if (this.isValidIndex(activeIndex)) {\n            event.stopPropagation();\n            this.removeIndexFromValues(activeIndex);\n        }\n    }\n\n    /** Remove the item at the given index by invoking `onRemove` and `onChange` accordingly. */\n    private removeIndexFromValues(index: number) {\n        const { onChange, onRemove, values } = this.props;\n        onRemove?.(values[index], index);\n        onChange?.(values.filter((_, i) => i !== index));\n    }\n\n    private invokeKeyPressCallback(\n        propCallbackName: \"onKeyDown\" | \"onKeyUp\",\n        event: React.KeyboardEvent<HTMLInputElement>,\n        activeIndex: number,\n    ) {\n        this.props[propCallbackName]?.(event, activeIndex === NONE ? undefined : activeIndex);\n        this.props.inputProps![propCallbackName]?.(event);\n    }\n\n    /** Returns whether the given index represents a valid item in `this.props.values`. */\n    private isValidIndex(index: number) {\n        return index !== NONE && index < this.props.values.length;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}