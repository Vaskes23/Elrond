{"ast":null,"code":"import { createElement as _createElement } from \"react\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\n/*\n * Copyright 2023 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport classNames from \"classnames\";\nimport { memo, useCallback } from \"react\";\nimport { Classes, DISPLAYNAME_PREFIX } from \"../../common\";\nimport { Popover } from \"../popover/popover\";\nimport { Portal } from \"../portal/portal\";\n/**\n * A floating popover which is positioned at a given target offset inside its parent element container.\n * Used to display context menus. Note that this behaves differently from other popover components like\n * Popover and Tooltip, which wrap their children with interaction handlers -- if you're looking for the whole\n * interaction package, use ContextMenu instead.\n *\n * @see https://blueprintjs.com/docs/#core/components/context-menu-popover\n */\nexport const ContextMenuPopover = memo(function ContextMenuPopover(props) {\n  const {\n    content,\n    popoverClassName,\n    onClose,\n    isDarkTheme = false,\n    rootBoundary = \"viewport\",\n    targetOffset,\n    transitionDuration = 100,\n    ...popoverProps\n  } = props;\n  const cancelContextMenu = useCallback(e => e.preventDefault(), []);\n  // Popover should attach its ref to the virtual target we render inside a Portal, not the \"inline\" child target\n  const renderTarget = useCallback(({\n    ref\n  }) => _jsx(Portal, {\n    children: _jsx(\"div\", {\n      className: Classes.CONTEXT_MENU_VIRTUAL_TARGET,\n      style: targetOffset,\n      ref: ref\n    })\n  }), [targetOffset]);\n  const handleInteraction = useCallback(nextOpenState => {\n    if (!nextOpenState) {\n      onClose === null || onClose === void 0 ? void 0 : onClose();\n    }\n  }, [onClose]);\n  return _createElement(Popover, {\n    placement: \"right-start\",\n    rootBoundary: rootBoundary,\n    transitionDuration: transitionDuration,\n    ...popoverProps,\n    content:\n    // this prevents right-clicking inside our context menu\n    _jsx(\"div\", {\n      onContextMenu: cancelContextMenu,\n      children: content\n    }),\n    enforceFocus: false,\n    // Generate key based on offset so that a new Popover instance is created\n    // when offset changes, to force recomputing position.\n    key: getPopoverKey(targetOffset),\n    hasBackdrop: true,\n    backdropProps: {\n      className: Classes.CONTEXT_MENU_BACKDROP\n    },\n    minimal: true,\n    onInteraction: handleInteraction,\n    popoverClassName: classNames(Classes.CONTEXT_MENU_POPOVER, popoverClassName, {\n      [Classes.DARK]: isDarkTheme\n    }),\n    positioningStrategy: \"fixed\",\n    renderTarget: renderTarget\n  });\n});\nContextMenuPopover.displayName = `${DISPLAYNAME_PREFIX}.ContextMenuPopover`;\nfunction getPopoverKey(targetOffset) {\n  return targetOffset === undefined ? \"default\" : `${targetOffset.left}x${targetOffset.top}`;\n}","map":{"version":3,"names":["classNames","memo","useCallback","Classes","DISPLAYNAME_PREFIX","Popover","Portal","ContextMenuPopover","props","content","popoverClassName","onClose","isDarkTheme","rootBoundary","targetOffset","transitionDuration","popoverProps","cancelContextMenu","e","preventDefault","renderTarget","ref","_jsx","children","className","CONTEXT_MENU_VIRTUAL_TARGET","style","handleInteraction","nextOpenState","_createElement","placement","onContextMenu","enforceFocus","key","getPopoverKey","hasBackdrop","backdropProps","CONTEXT_MENU_BACKDROP","minimal","onInteraction","CONTEXT_MENU_POPOVER","DARK","positioningStrategy","displayName","undefined","left","top"],"sources":["/Users/husseingalal/Desktop/Hackathon/Elrond/frontend/node_modules/@blueprintjs/core/src/components/context-menu/contextMenuPopover.tsx"],"sourcesContent":["/*\n * Copyright 2023 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport classNames from \"classnames\";\nimport { memo, useCallback } from \"react\";\n\nimport { Classes, DISPLAYNAME_PREFIX } from \"../../common\";\nimport { Popover } from \"../popover/popover\";\nimport type { PopoverTargetProps } from \"../popover/popoverSharedProps\";\nimport { Portal } from \"../portal/portal\";\n\nimport type { ContextMenuPopoverOptions, Offset } from \"./contextMenuShared\";\n\nexport interface ContextMenuPopoverProps extends ContextMenuPopoverOptions {\n    isOpen: boolean;\n    isDarkTheme?: boolean;\n    content: React.JSX.Element;\n    onClose?: () => void;\n    targetOffset: Offset | undefined;\n}\n\n/**\n * A floating popover which is positioned at a given target offset inside its parent element container.\n * Used to display context menus. Note that this behaves differently from other popover components like\n * Popover and Tooltip, which wrap their children with interaction handlers -- if you're looking for the whole\n * interaction package, use ContextMenu instead.\n *\n * @see https://blueprintjs.com/docs/#core/components/context-menu-popover\n */\nexport const ContextMenuPopover = memo(function ContextMenuPopover(props: ContextMenuPopoverProps) {\n    const {\n        content,\n        popoverClassName,\n        onClose,\n        isDarkTheme = false,\n        rootBoundary = \"viewport\",\n        targetOffset,\n        transitionDuration = 100,\n        ...popoverProps\n    } = props;\n    const cancelContextMenu = useCallback((e: React.SyntheticEvent<HTMLDivElement>) => e.preventDefault(), []);\n\n    // Popover should attach its ref to the virtual target we render inside a Portal, not the \"inline\" child target\n    const renderTarget = useCallback(\n        ({ ref }: PopoverTargetProps) => (\n            <Portal>\n                <div className={Classes.CONTEXT_MENU_VIRTUAL_TARGET} style={targetOffset} ref={ref} />\n            </Portal>\n        ),\n        [targetOffset],\n    );\n\n    const handleInteraction = useCallback(\n        (nextOpenState: boolean) => {\n            if (!nextOpenState) {\n                onClose?.();\n            }\n        },\n        [onClose],\n    );\n\n    return (\n        <Popover\n            placement=\"right-start\"\n            rootBoundary={rootBoundary}\n            transitionDuration={transitionDuration}\n            {...popoverProps}\n            content={\n                // this prevents right-clicking inside our context menu\n                <div onContextMenu={cancelContextMenu}>{content}</div>\n            }\n            enforceFocus={false}\n            // Generate key based on offset so that a new Popover instance is created\n            // when offset changes, to force recomputing position.\n            key={getPopoverKey(targetOffset)}\n            hasBackdrop={true}\n            backdropProps={{ className: Classes.CONTEXT_MENU_BACKDROP }}\n            minimal={true}\n            onInteraction={handleInteraction}\n            popoverClassName={classNames(Classes.CONTEXT_MENU_POPOVER, popoverClassName, {\n                [Classes.DARK]: isDarkTheme,\n            })}\n            positioningStrategy=\"fixed\"\n            renderTarget={renderTarget}\n        />\n    );\n});\nContextMenuPopover.displayName = `${DISPLAYNAME_PREFIX}.ContextMenuPopover`;\n\nfunction getPopoverKey(targetOffset: Offset | undefined) {\n    return targetOffset === undefined ? \"default\" : `${targetOffset.left}x${targetOffset.top}`;\n}\n"],"mappings":";;AAAA;;;;;;;;;;;;;;;AAgBA,OAAOA,UAAU,MAAM,YAAY;AACnC,SAASC,IAAI,EAAEC,WAAW,QAAQ,OAAO;AAEzC,SAASC,OAAO,EAAEC,kBAAkB,QAAQ,cAAc;AAC1D,SAASC,OAAO,QAAQ,oBAAoB;AAE5C,SAASC,MAAM,QAAQ,kBAAkB;AAYzC;;;;;;;;AAQA,OAAO,MAAMC,kBAAkB,GAAGN,IAAI,CAAC,SAASM,kBAAkBA,CAACC,KAA8B;EAC7F,MAAM;IACFC,OAAO;IACPC,gBAAgB;IAChBC,OAAO;IACPC,WAAW,GAAG,KAAK;IACnBC,YAAY,GAAG,UAAU;IACzBC,YAAY;IACZC,kBAAkB,GAAG,GAAG;IACxB,GAAGC;EAAY,CAClB,GAAGR,KAAK;EACT,MAAMS,iBAAiB,GAAGf,WAAW,CAAEgB,CAAuC,IAAKA,CAAC,CAACC,cAAc,EAAE,EAAE,EAAE,CAAC;EAE1G;EACA,MAAMC,YAAY,GAAGlB,WAAW,CAC5B,CAAC;IAAEmB;EAAG,CAAsB,KACxBC,IAAA,CAAChB,MAAM;IAAAiB,QAAA,EACHD,IAAA;MAAKE,SAAS,EAAErB,OAAO,CAACsB,2BAA2B;MAAEC,KAAK,EAAEZ,YAAY;MAAEO,GAAG,EAAEA;IAAG;EAAI,EAE7F,EACD,CAACP,YAAY,CAAC,CACjB;EAED,MAAMa,iBAAiB,GAAGzB,WAAW,CAChC0B,aAAsB,IAAI;IACvB,IAAI,CAACA,aAAa,EAAE;MAChBjB,OAAO,aAAPA,OAAO,uBAAPA,OAAO,EAAI;IACf;EACJ,CAAC,EACD,CAACA,OAAO,CAAC,CACZ;EAED,OACIkB,cAAA,CAACxB,OAAO;IACJyB,SAAS,EAAC,aAAa;IACvBjB,YAAY,EAAEA,YAAY;IAC1BE,kBAAkB,EAAEA,kBAAkB;IAAA,GAClCC,YAAY;IAChBP,OAAO;IACH;IACAa,IAAA;MAAKS,aAAa,EAAEd,iBAAiB;MAAAM,QAAA,EAAGd;IAAO,EAAO;IAE1DuB,YAAY,EAAE,KAAK;IACnB;IACA;IACAC,GAAG,EAAEC,aAAa,CAACpB,YAAY,CAAC;IAChCqB,WAAW,EAAE,IAAI;IACjBC,aAAa,EAAE;MAAEZ,SAAS,EAAErB,OAAO,CAACkC;IAAqB,CAAE;IAC3DC,OAAO,EAAE,IAAI;IACbC,aAAa,EAAEZ,iBAAiB;IAChCjB,gBAAgB,EAAEV,UAAU,CAACG,OAAO,CAACqC,oBAAoB,EAAE9B,gBAAgB,EAAE;MACzE,CAACP,OAAO,CAACsC,IAAI,GAAG7B;KACnB,CAAC;IACF8B,mBAAmB,EAAC,OAAO;IAC3BtB,YAAY,EAAEA;EAAY,EAC5B;AAEV,CAAC,CAAC;AACFb,kBAAkB,CAACoC,WAAW,GAAG,GAAGvC,kBAAkB,qBAAqB;AAE3E,SAAS8B,aAAaA,CAACpB,YAAgC;EACnD,OAAOA,YAAY,KAAK8B,SAAS,GAAG,SAAS,GAAG,GAAG9B,YAAY,CAAC+B,IAAI,IAAI/B,YAAY,CAACgC,GAAG,EAAE;AAC9F","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}