{"ast":null,"code":"import { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\n/*\n * Copyright 2018 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport classNames from \"classnames\";\nimport { Children } from \"react\";\nimport { AbstractPureComponent, Classes, DISPLAYNAME_PREFIX, Intent, Utils } from \"../../common\";\nimport * as Errors from \"../../common/errors\";\nimport { Handle } from \"./handle\";\nimport { HandleInteractionKind, HandleType } from \"./handleProps\";\nimport { argMin, fillValues, formatPercentage } from \"./sliderUtils\";\n/**\n * Multi slider handle component, used as a child of MultiSlider. This component is not rendered directly.\n *\n * @see https://blueprintjs.com/docs/#core/components/sliders.handle\n */\nexport const MultiSliderHandle = () => null;\nMultiSliderHandle.displayName = `${DISPLAYNAME_PREFIX}.MultiSliderHandle`;\n/**\n * Multi slider component.\n *\n * @see https://blueprintjs.com/docs/#core/components/sliders.multi-slider\n */\nexport class MultiSlider extends AbstractPureComponent {\n  constructor() {\n    super(...arguments);\n    this.state = {\n      labelPrecision: getLabelPrecision(this.props),\n      tickSize: 0,\n      tickSizeRatio: 0\n    };\n    this.handleElements = [];\n    this.trackElement = null;\n    this.addHandleRef = ref => {\n      if (ref != null) {\n        this.handleElements.push(ref);\n      }\n    };\n    this.maybeHandleTrackClick = event => {\n      if (this.canHandleTrackEvent(event)) {\n        const foundHandle = this.nearestHandleForValue(this.handleElements, handle => handle.mouseEventClientOffset(event));\n        if (foundHandle) {\n          foundHandle.beginHandleMovement(event);\n        }\n      }\n    };\n    this.maybeHandleTrackTouch = event => {\n      if (this.canHandleTrackEvent(event)) {\n        const foundHandle = this.nearestHandleForValue(this.handleElements, handle => handle.touchEventClientOffset(event));\n        if (foundHandle) {\n          foundHandle.beginHandleTouchMovement(event);\n        }\n      }\n    };\n    this.canHandleTrackEvent = event => {\n      const target = event.target;\n      // ensure event does not come from inside the handle\n      return !this.props.disabled && target.closest(`.${Classes.SLIDER_HANDLE}`) == null;\n    };\n    this.getHandlerForIndex = (index, callback) => {\n      return newValue => {\n        callback === null || callback === void 0 ? void 0 : callback(this.getNewHandleValues(newValue, index));\n      };\n    };\n    this.handleChange = newValues => {\n      var _a, _b;\n      const handleProps = getSortedInteractiveHandleProps(this.props);\n      const oldValues = handleProps.map(handle => handle.value);\n      if (!Utils.arraysEqual(newValues, oldValues)) {\n        (_b = (_a = this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, newValues);\n        handleProps.forEach((handle, index) => {\n          var _a;\n          if (oldValues[index] !== newValues[index]) {\n            (_a = handle.onChange) === null || _a === void 0 ? void 0 : _a.call(handle, newValues[index]);\n          }\n        });\n      }\n    };\n    this.handleRelease = newValues => {\n      var _a, _b;\n      const handleProps = getSortedInteractiveHandleProps(this.props);\n      (_b = (_a = this.props).onRelease) === null || _b === void 0 ? void 0 : _b.call(_a, newValues);\n      handleProps.forEach((handle, index) => {\n        var _a;\n        (_a = handle.onRelease) === null || _a === void 0 ? void 0 : _a.call(handle, newValues[index]);\n      });\n    };\n  }\n  static getDerivedStateFromProps(props) {\n    return {\n      labelPrecision: MultiSlider.getLabelPrecision(props)\n    };\n  }\n  static getLabelPrecision({\n    labelPrecision,\n    stepSize\n  }) {\n    // infer default label precision from stepSize because that's how much the handle moves.\n    return labelPrecision == null ? Utils.countDecimalPlaces(stepSize) : labelPrecision;\n  }\n  getSnapshotBeforeUpdate(prevProps) {\n    const prevHandleProps = getSortedInteractiveHandleProps(prevProps);\n    const newHandleProps = getSortedInteractiveHandleProps(this.props);\n    if (newHandleProps.length !== prevHandleProps.length) {\n      // clear refs\n      this.handleElements = [];\n    }\n    return null;\n  }\n  render() {\n    const classes = classNames(Classes.SLIDER, {\n      [Classes.DISABLED]: this.props.disabled,\n      [`${Classes.SLIDER}-unlabeled`]: this.props.labelRenderer === false,\n      [Classes.VERTICAL]: this.props.vertical\n    }, this.props.className);\n    return _jsxs(\"div\", {\n      className: classes,\n      onMouseDown: this.maybeHandleTrackClick,\n      onTouchStart: this.maybeHandleTrackTouch,\n      children: [_jsx(\"div\", {\n        className: Classes.SLIDER_TRACK,\n        ref: ref => this.trackElement = ref,\n        children: this.renderTracks()\n      }), _jsx(\"div\", {\n        className: Classes.SLIDER_AXIS,\n        children: this.renderLabels()\n      }), this.renderHandles()]\n    });\n  }\n  componentDidMount() {\n    this.updateTickSize();\n  }\n  componentDidUpdate(prevProps, prevState) {\n    super.componentDidUpdate(prevProps, prevState);\n    this.updateTickSize();\n  }\n  validateProps(props) {\n    if (props.stepSize <= 0) {\n      throw new Error(Errors.SLIDER_ZERO_STEP);\n    }\n    if (props.labelStepSize !== undefined && props.labelValues !== undefined) {\n      throw new Error(Errors.MULTISLIDER_WARN_LABEL_STEP_SIZE_LABEL_VALUES_MUTEX);\n    }\n    if (props.labelStepSize !== undefined && props.labelStepSize <= 0) {\n      throw new Error(Errors.SLIDER_ZERO_LABEL_STEP);\n    }\n    if (props.min !== undefined && !isFinite(props.min)) {\n      throw new Error(Errors.SLIDER_MIN);\n    }\n    if (props.max !== undefined && !isFinite(props.max)) {\n      throw new Error(Errors.SLIDER_MAX);\n    }\n    let anyInvalidChildren = false;\n    Children.forEach(props.children, child => {\n      // allow boolean coercion to omit nulls and false values\n      if (child && !Utils.isElementOfType(child, MultiSliderHandle)) {\n        anyInvalidChildren = true;\n      }\n    });\n    if (anyInvalidChildren) {\n      throw new Error(Errors.MULTISLIDER_INVALID_CHILD);\n    }\n  }\n  formatLabel(value, isHandleTooltip = false) {\n    const {\n      labelRenderer\n    } = this.props;\n    if (labelRenderer === false) {\n      return undefined;\n    } else if (Utils.isFunction(labelRenderer)) {\n      return labelRenderer(value, {\n        isHandleTooltip\n      });\n    } else {\n      return value.toFixed(this.state.labelPrecision);\n    }\n  }\n  renderLabels() {\n    if (this.props.labelRenderer === false) {\n      return null;\n    }\n    const values = this.getLabelValues();\n    const {\n      max,\n      min\n    } = this.props;\n    const labels = values.map((step, i) => {\n      const offsetPercentage = formatPercentage((step - min) / (max - min));\n      const style = this.props.vertical ? {\n        bottom: offsetPercentage\n      } : {\n        left: offsetPercentage\n      };\n      return _jsx(\"div\", {\n        className: Classes.SLIDER_LABEL,\n        style: style,\n        children: this.formatLabel(step)\n      }, i);\n    });\n    return labels;\n  }\n  renderTracks() {\n    const trackStops = getSortedHandleProps(this.props);\n    trackStops.push({\n      value: this.props.max\n    });\n    // render from current to previous, then increment previous\n    let previous = {\n      value: this.props.min\n    };\n    const handles = [];\n    for (let index = 0; index < trackStops.length; index++) {\n      const current = trackStops[index];\n      handles.push(this.renderTrackFill(index, previous, current));\n      previous = current;\n    }\n    return handles;\n  }\n  renderTrackFill(index, start, end) {\n    // ensure startRatio <= endRatio\n    const [startRatio, endRatio] = [this.getOffsetRatio(start.value), this.getOffsetRatio(end.value)].sort((left, right) => left - right);\n    const startOffset = formatPercentage(startRatio);\n    const endOffset = formatPercentage(1 - endRatio);\n    const orientationStyle = this.props.vertical ? {\n      bottom: startOffset,\n      left: 0,\n      top: endOffset\n    } : {\n      left: startOffset,\n      right: endOffset,\n      top: 0\n    };\n    const style = {\n      ...orientationStyle,\n      ...(start.trackStyleAfter || end.trackStyleBefore || {})\n    };\n    const classes = classNames(Classes.SLIDER_PROGRESS, Classes.intentClass(this.getTrackIntent(start, end)));\n    return _jsx(\"div\", {\n      className: classes,\n      style: style\n    }, `track-${index}`);\n  }\n  renderHandles() {\n    const {\n      disabled,\n      max,\n      min,\n      stepSize,\n      vertical\n    } = this.props;\n    const handleProps = getSortedInteractiveHandleProps(this.props);\n    if (handleProps.length === 0) {\n      return null;\n    }\n    return handleProps.map(({\n      value,\n      type,\n      className,\n      htmlProps\n    }, index) => _jsx(Handle, {\n      htmlProps: htmlProps,\n      className: classNames({\n        [Classes.START]: type === HandleType.START,\n        [Classes.END]: type === HandleType.END\n      }, className),\n      disabled: disabled,\n      label: this.formatLabel(value, true),\n      max: max,\n      min: min,\n      onChange: this.getHandlerForIndex(index, this.handleChange),\n      onRelease: this.getHandlerForIndex(index, this.handleRelease),\n      ref: this.addHandleRef,\n      stepSize: stepSize,\n      tickSize: this.state.tickSize,\n      tickSizeRatio: this.state.tickSizeRatio,\n      value: value,\n      vertical: vertical\n    }, `${index}-${handleProps.length}`));\n  }\n  nearestHandleForValue(handles, getOffset) {\n    return argMin(handles, handle => {\n      const offset = getOffset(handle);\n      const offsetValue = handle.clientToValue(offset);\n      const handleValue = handle.props.value;\n      return Math.abs(offsetValue - handleValue);\n    });\n  }\n  getNewHandleValues(newValue, oldIndex) {\n    const handleProps = getSortedInteractiveHandleProps(this.props);\n    const oldValues = handleProps.map(handle => handle.value);\n    const newValues = oldValues.slice();\n    newValues[oldIndex] = newValue;\n    newValues.sort((left, right) => left - right);\n    const newIndex = newValues.indexOf(newValue);\n    const lockIndex = this.findFirstLockedHandleIndex(oldIndex, newIndex);\n    if (lockIndex === -1) {\n      fillValues(newValues, oldIndex, newIndex, newValue);\n    } else {\n      // If pushing past a locked handle, discard the new value and only make the updates to clamp values against the lock.\n      const lockValue = oldValues[lockIndex];\n      fillValues(oldValues, oldIndex, lockIndex, lockValue);\n      return oldValues;\n    }\n    return newValues;\n  }\n  findFirstLockedHandleIndex(startIndex, endIndex) {\n    const inc = startIndex < endIndex ? 1 : -1;\n    const handleProps = getSortedInteractiveHandleProps(this.props);\n    for (let index = startIndex + inc; index !== endIndex + inc; index += inc) {\n      if (handleProps[index].interactionKind !== HandleInteractionKind.PUSH) {\n        return index;\n      }\n    }\n    return -1;\n  }\n  getLabelValues() {\n    const {\n      labelStepSize,\n      labelValues,\n      min,\n      max\n    } = this.props;\n    let values = [];\n    if (labelValues !== undefined) {\n      values = labelValues.slice();\n    } else {\n      for (let i = min; i < max || Utils.approxEqual(i, max); i += labelStepSize !== null && labelStepSize !== void 0 ? labelStepSize : 1) {\n        values.push(i);\n      }\n    }\n    return values;\n  }\n  getOffsetRatio(value) {\n    return Utils.clamp((value - this.props.min) * this.state.tickSizeRatio, 0, 1);\n  }\n  getTrackIntent(start, end) {\n    if (!this.props.showTrackFill) {\n      return Intent.NONE;\n    }\n    if (start.intentAfter !== undefined) {\n      return start.intentAfter;\n    } else if (end !== undefined && end.intentBefore !== undefined) {\n      return end.intentBefore;\n    }\n    return this.props.defaultTrackIntent;\n  }\n  updateTickSize() {\n    if (this.trackElement != null) {\n      const trackSize = this.props.vertical ? this.trackElement.clientHeight : this.trackElement.clientWidth;\n      const tickSizeRatio = 1 / (this.props.max - this.props.min);\n      const tickSize = trackSize * tickSizeRatio;\n      this.setState({\n        tickSize,\n        tickSizeRatio\n      });\n    }\n  }\n}\nMultiSlider.defaultSliderProps = {\n  disabled: false,\n  max: 10,\n  min: 0,\n  showTrackFill: true,\n  stepSize: 1,\n  vertical: false\n};\nMultiSlider.defaultProps = {\n  ...MultiSlider.defaultSliderProps,\n  defaultTrackIntent: Intent.NONE\n};\nMultiSlider.displayName = `${DISPLAYNAME_PREFIX}.MultiSlider`;\n/** @deprecated Use `MultiSliderHandle` instead */\nMultiSlider.Handle = MultiSliderHandle;\nfunction getLabelPrecision({\n  labelPrecision,\n  stepSize = MultiSlider.defaultSliderProps.stepSize\n}) {\n  // infer default label precision from stepSize because that's how much the handle moves.\n  return labelPrecision == null ? Utils.countDecimalPlaces(stepSize) : labelPrecision;\n}\nfunction getSortedInteractiveHandleProps(props) {\n  return getSortedHandleProps(props, childProps => childProps.interactionKind !== HandleInteractionKind.NONE);\n}\nfunction getSortedHandleProps({\n  children\n}, predicate = () => true) {\n  const maybeHandles = Children.map(children, child => Utils.isElementOfType(child, MultiSliderHandle) && predicate(child.props) ? child.props : null);\n  let handles = maybeHandles != null ? maybeHandles : [];\n  handles = handles.filter(handle => handle !== null);\n  handles.sort((left, right) => left.value - right.value);\n  return handles;\n}","map":{"version":3,"names":["classNames","Children","AbstractPureComponent","Classes","DISPLAYNAME_PREFIX","Intent","Utils","Errors","Handle","HandleInteractionKind","HandleType","argMin","fillValues","formatPercentage","MultiSliderHandle","displayName","MultiSlider","constructor","state","labelPrecision","getLabelPrecision","props","tickSize","tickSizeRatio","handleElements","trackElement","addHandleRef","ref","push","maybeHandleTrackClick","event","canHandleTrackEvent","foundHandle","nearestHandleForValue","handle","mouseEventClientOffset","beginHandleMovement","maybeHandleTrackTouch","touchEventClientOffset","beginHandleTouchMovement","target","disabled","closest","SLIDER_HANDLE","getHandlerForIndex","index","callback","newValue","getNewHandleValues","handleChange","newValues","handleProps","getSortedInteractiveHandleProps","oldValues","map","value","arraysEqual","_b","_a","onChange","call","forEach","handleRelease","onRelease","getDerivedStateFromProps","stepSize","countDecimalPlaces","getSnapshotBeforeUpdate","prevProps","prevHandleProps","newHandleProps","length","render","classes","SLIDER","DISABLED","labelRenderer","VERTICAL","vertical","className","_jsxs","onMouseDown","onTouchStart","children","_jsx","SLIDER_TRACK","renderTracks","SLIDER_AXIS","renderLabels","renderHandles","componentDidMount","updateTickSize","componentDidUpdate","prevState","validateProps","Error","SLIDER_ZERO_STEP","labelStepSize","undefined","labelValues","MULTISLIDER_WARN_LABEL_STEP_SIZE_LABEL_VALUES_MUTEX","SLIDER_ZERO_LABEL_STEP","min","isFinite","SLIDER_MIN","max","SLIDER_MAX","anyInvalidChildren","child","isElementOfType","MULTISLIDER_INVALID_CHILD","formatLabel","isHandleTooltip","isFunction","toFixed","values","getLabelValues","labels","step","i","offsetPercentage","style","bottom","left","SLIDER_LABEL","trackStops","getSortedHandleProps","previous","handles","current","renderTrackFill","start","end","startRatio","endRatio","getOffsetRatio","sort","right","startOffset","endOffset","orientationStyle","top","trackStyleAfter","trackStyleBefore","SLIDER_PROGRESS","intentClass","getTrackIntent","type","htmlProps","START","END","label","getOffset","offset","offsetValue","clientToValue","handleValue","Math","abs","oldIndex","slice","newIndex","indexOf","lockIndex","findFirstLockedHandleIndex","lockValue","startIndex","endIndex","inc","interactionKind","PUSH","approxEqual","clamp","showTrackFill","NONE","intentAfter","intentBefore","defaultTrackIntent","trackSize","clientHeight","clientWidth","setState","defaultSliderProps","defaultProps","childProps","predicate","maybeHandles","filter"],"sources":["/Users/husseingalal/Desktop/Hackathon/Elrond/frontend/node_modules/@blueprintjs/core/src/components/slider/multiSlider.tsx"],"sourcesContent":["/*\n * Copyright 2018 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport classNames from \"classnames\";\nimport { Children } from \"react\";\n\nimport {\n    AbstractPureComponent,\n    Classes,\n    DISPLAYNAME_PREFIX,\n    Intent,\n    type IntentProps,\n    type Props,\n    Utils,\n} from \"../../common\";\nimport * as Errors from \"../../common/errors\";\n\nimport { Handle } from \"./handle\";\nimport { HandleInteractionKind, type HandleProps, HandleType } from \"./handleProps\";\nimport { argMin, fillValues, formatPercentage } from \"./sliderUtils\";\n\n/**\n * Multi slider handle component, used as a child of MultiSlider. This component is not rendered directly.\n *\n * @see https://blueprintjs.com/docs/#core/components/sliders.handle\n */\nexport const MultiSliderHandle: React.FC<HandleProps> = () => null;\nMultiSliderHandle.displayName = `${DISPLAYNAME_PREFIX}.MultiSliderHandle`;\n\nexport interface SliderBaseProps extends Props, IntentProps {\n    children?: React.ReactNode;\n\n    /**\n     * Whether the slider is non-interactive.\n     *\n     * @default false\n     */\n    disabled?: boolean;\n\n    /**\n     * Increment between successive labels. Must be greater than zero.\n     *\n     * @default inferred (if labelStepSize is undefined)\n     */\n    labelStepSize?: number;\n\n    /**\n     * Array of specific values for the label placement. This prop is mutually exclusive with\n     * `labelStepSize`.\n     */\n    labelValues?: readonly number[];\n\n    /**\n     * Number of decimal places to use when rendering label value. Default value is the number of\n     * decimals used in the `stepSize` prop. This prop has _no effect_ if you supply a custom\n     * `labelRenderer` callback.\n     *\n     * @default inferred from stepSize\n     */\n    labelPrecision?: number;\n\n    /**\n     * Maximum value of the slider. Value must be a finite number.\n     *\n     * @default 10\n     */\n    max?: number;\n\n    /**\n     * Minimum value of the slider. Value must be a finite number.\n     *\n     * @default 0\n     */\n    min?: number;\n\n    /**\n     * Whether a solid bar should be rendered on the track between current and initial values,\n     * or between handles for `RangeSlider`.\n     *\n     * @default true\n     */\n    showTrackFill?: boolean;\n\n    /**\n     * Increment between successive values; amount by which the handle moves. Must be greater than zero.\n     *\n     * @default 1\n     */\n    stepSize?: number;\n\n    /**\n     * Callback to render a single label. Useful for formatting numbers as currency or percentages.\n     * If `true`, labels will use number value formatted to `labelPrecision` decimal places.\n     * If `false`, labels will not be shown.\n     *\n     * The callback is provided a numeric value and optional rendering options, which include:\n     * - isHandleTooltip: whether this label is being rendered within a handle tooltip\n     *\n     * @default true\n     */\n    labelRenderer?: boolean | ((value: number, opts?: { isHandleTooltip: boolean }) => string | React.JSX.Element);\n\n    /**\n     * Whether to show the slider in a vertical orientation.\n     *\n     * @default false\n     */\n    vertical?: boolean;\n}\n\nexport interface MultiSliderProps extends SliderBaseProps {\n    /** Default intent of a track segment, used only if no handle specifies `intentBefore/After`. */\n    defaultTrackIntent?: Intent;\n\n    /** Callback invoked when a handle value changes. Receives handle values in sorted order. */\n    onChange?(values: number[]): void;\n\n    /** Callback invoked when a handle is released. Receives handle values in sorted order. */\n    onRelease?(values: number[]): void;\n}\n\nexport interface SliderState {\n    labelPrecision: number;\n    /** the client size, in pixels, of one tick */\n    tickSize: number;\n    /** the size of one tick as a ratio of the component's client size */\n    tickSizeRatio: number;\n}\n\n/**\n * Multi slider component.\n *\n * @see https://blueprintjs.com/docs/#core/components/sliders.multi-slider\n */\nexport class MultiSlider extends AbstractPureComponent<MultiSliderProps, SliderState> {\n    public static defaultSliderProps: SliderBaseProps = {\n        disabled: false,\n        max: 10,\n        min: 0,\n        showTrackFill: true,\n        stepSize: 1,\n        vertical: false,\n    };\n\n    public static defaultProps: MultiSliderProps = {\n        ...MultiSlider.defaultSliderProps,\n        defaultTrackIntent: Intent.NONE,\n    };\n\n    public static displayName = `${DISPLAYNAME_PREFIX}.MultiSlider`;\n\n    /** @deprecated Use `MultiSliderHandle` instead */\n    public static Handle = MultiSliderHandle;\n\n    public static getDerivedStateFromProps(props: MultiSliderProps) {\n        return { labelPrecision: MultiSlider.getLabelPrecision(props) };\n    }\n\n    private static getLabelPrecision({ labelPrecision, stepSize }: MultiSliderProps) {\n        // infer default label precision from stepSize because that's how much the handle moves.\n        return labelPrecision == null ? Utils.countDecimalPlaces(stepSize!) : labelPrecision;\n    }\n\n    public state: SliderState = {\n        labelPrecision: getLabelPrecision(this.props),\n        tickSize: 0,\n        tickSizeRatio: 0,\n    };\n\n    private handleElements: Handle[] = [];\n\n    private trackElement: HTMLElement | null = null;\n\n    public getSnapshotBeforeUpdate(prevProps: MultiSliderProps): null {\n        const prevHandleProps = getSortedInteractiveHandleProps(prevProps);\n        const newHandleProps = getSortedInteractiveHandleProps(this.props);\n        if (newHandleProps.length !== prevHandleProps.length) {\n            // clear refs\n            this.handleElements = [];\n        }\n        return null;\n    }\n\n    public render() {\n        const classes = classNames(\n            Classes.SLIDER,\n            {\n                [Classes.DISABLED]: this.props.disabled,\n                [`${Classes.SLIDER}-unlabeled`]: this.props.labelRenderer === false,\n                [Classes.VERTICAL]: this.props.vertical,\n            },\n            this.props.className,\n        );\n        return (\n            <div className={classes} onMouseDown={this.maybeHandleTrackClick} onTouchStart={this.maybeHandleTrackTouch}>\n                <div className={Classes.SLIDER_TRACK} ref={ref => (this.trackElement = ref)}>\n                    {this.renderTracks()}\n                </div>\n                <div className={Classes.SLIDER_AXIS}>{this.renderLabels()}</div>\n                {this.renderHandles()}\n            </div>\n        );\n    }\n\n    public componentDidMount() {\n        this.updateTickSize();\n    }\n\n    public componentDidUpdate(prevProps: MultiSliderProps, prevState: SliderState) {\n        super.componentDidUpdate(prevProps, prevState);\n        this.updateTickSize();\n    }\n\n    protected validateProps(props: React.PropsWithChildren<MultiSliderProps>) {\n        if (props.stepSize! <= 0) {\n            throw new Error(Errors.SLIDER_ZERO_STEP);\n        }\n        if (props.labelStepSize !== undefined && props.labelValues !== undefined) {\n            throw new Error(Errors.MULTISLIDER_WARN_LABEL_STEP_SIZE_LABEL_VALUES_MUTEX);\n        }\n        if (props.labelStepSize !== undefined && props.labelStepSize! <= 0) {\n            throw new Error(Errors.SLIDER_ZERO_LABEL_STEP);\n        }\n        if (props.min !== undefined && !isFinite(props.min)) {\n            throw new Error(Errors.SLIDER_MIN);\n        }\n        if (props.max !== undefined && !isFinite(props.max)) {\n            throw new Error(Errors.SLIDER_MAX);\n        }\n\n        let anyInvalidChildren = false;\n        Children.forEach(props.children, child => {\n            // allow boolean coercion to omit nulls and false values\n            if (child && !Utils.isElementOfType(child, MultiSliderHandle)) {\n                anyInvalidChildren = true;\n            }\n        });\n        if (anyInvalidChildren) {\n            throw new Error(Errors.MULTISLIDER_INVALID_CHILD);\n        }\n    }\n\n    private formatLabel(value: number, isHandleTooltip: boolean = false) {\n        const { labelRenderer } = this.props;\n        if (labelRenderer === false) {\n            return undefined;\n        } else if (Utils.isFunction(labelRenderer)) {\n            return labelRenderer(value, { isHandleTooltip });\n        } else {\n            return value.toFixed(this.state.labelPrecision);\n        }\n    }\n\n    private renderLabels() {\n        if (this.props.labelRenderer === false) {\n            return null;\n        }\n\n        const values = this.getLabelValues();\n        const { max, min } = this.props;\n        const labels = values.map((step, i) => {\n            const offsetPercentage = formatPercentage((step - min!) / (max! - min!));\n            const style = this.props.vertical ? { bottom: offsetPercentage } : { left: offsetPercentage };\n            return (\n                <div className={Classes.SLIDER_LABEL} key={i} style={style}>\n                    {this.formatLabel(step)}\n                </div>\n            );\n        });\n\n        return labels;\n    }\n\n    private renderTracks() {\n        const trackStops = getSortedHandleProps(this.props);\n        trackStops.push({ value: this.props.max! });\n\n        // render from current to previous, then increment previous\n        let previous: HandleProps = { value: this.props.min! };\n        const handles: React.JSX.Element[] = [];\n        for (let index = 0; index < trackStops.length; index++) {\n            const current = trackStops[index];\n            handles.push(this.renderTrackFill(index, previous, current));\n            previous = current;\n        }\n        return handles;\n    }\n\n    private renderTrackFill(index: number, start: HandleProps, end: HandleProps) {\n        // ensure startRatio <= endRatio\n        const [startRatio, endRatio] = [this.getOffsetRatio(start.value), this.getOffsetRatio(end.value)].sort(\n            (left, right) => left - right,\n        );\n        const startOffset = formatPercentage(startRatio);\n        const endOffset = formatPercentage(1 - endRatio);\n        const orientationStyle: React.CSSProperties = this.props.vertical\n            ? { bottom: startOffset, left: 0, top: endOffset }\n            : { left: startOffset, right: endOffset, top: 0 };\n\n        const style: React.CSSProperties = {\n            ...orientationStyle,\n            ...(start.trackStyleAfter || end.trackStyleBefore || {}),\n        };\n\n        const classes = classNames(Classes.SLIDER_PROGRESS, Classes.intentClass(this.getTrackIntent(start, end)));\n        return <div key={`track-${index}`} className={classes} style={style} />;\n    }\n\n    private renderHandles() {\n        const { disabled, max, min, stepSize, vertical } = this.props;\n        const handleProps = getSortedInteractiveHandleProps(this.props);\n\n        if (handleProps.length === 0) {\n            return null;\n        }\n\n        return handleProps.map(({ value, type, className, htmlProps }, index) => (\n            <Handle\n                htmlProps={htmlProps}\n                className={classNames(\n                    {\n                        [Classes.START]: type === HandleType.START,\n                        [Classes.END]: type === HandleType.END,\n                    },\n                    className,\n                )}\n                disabled={disabled}\n                key={`${index}-${handleProps.length}`}\n                label={this.formatLabel(value, true)}\n                max={max!}\n                min={min!}\n                onChange={this.getHandlerForIndex(index, this.handleChange)}\n                onRelease={this.getHandlerForIndex(index, this.handleRelease)}\n                ref={this.addHandleRef}\n                stepSize={stepSize!}\n                tickSize={this.state.tickSize}\n                tickSizeRatio={this.state.tickSizeRatio}\n                value={value}\n                vertical={vertical!}\n            />\n        ));\n    }\n\n    private addHandleRef = (ref: Handle) => {\n        if (ref != null) {\n            this.handleElements.push(ref);\n        }\n    };\n\n    private maybeHandleTrackClick = (event: React.MouseEvent<HTMLDivElement>) => {\n        if (this.canHandleTrackEvent(event)) {\n            const foundHandle = this.nearestHandleForValue(this.handleElements, handle =>\n                handle.mouseEventClientOffset(event),\n            );\n            if (foundHandle) {\n                foundHandle.beginHandleMovement(event);\n            }\n        }\n    };\n\n    private maybeHandleTrackTouch = (event: React.TouchEvent<HTMLDivElement>) => {\n        if (this.canHandleTrackEvent(event)) {\n            const foundHandle = this.nearestHandleForValue(this.handleElements, handle =>\n                handle.touchEventClientOffset(event),\n            );\n            if (foundHandle) {\n                foundHandle.beginHandleTouchMovement(event);\n            }\n        }\n    };\n\n    private canHandleTrackEvent = (event: React.MouseEvent<HTMLDivElement> | React.TouchEvent<HTMLDivElement>) => {\n        const target = event.target as HTMLElement;\n        // ensure event does not come from inside the handle\n        return !this.props.disabled && target.closest(`.${Classes.SLIDER_HANDLE}`) == null;\n    };\n\n    private nearestHandleForValue(handles: Handle[], getOffset: (handle: Handle) => number): Handle | undefined {\n        return argMin(handles, handle => {\n            const offset = getOffset(handle);\n            const offsetValue = handle.clientToValue(offset);\n            const handleValue = handle.props.value!;\n            return Math.abs(offsetValue - handleValue);\n        });\n    }\n\n    private getHandlerForIndex = (index: number, callback?: (values: number[]) => void) => {\n        return (newValue: number) => {\n            callback?.(this.getNewHandleValues(newValue, index));\n        };\n    };\n\n    private getNewHandleValues(newValue: number, oldIndex: number) {\n        const handleProps = getSortedInteractiveHandleProps(this.props);\n        const oldValues = handleProps.map(handle => handle.value);\n        const newValues = oldValues.slice();\n        newValues[oldIndex] = newValue;\n        newValues.sort((left, right) => left - right);\n\n        const newIndex = newValues.indexOf(newValue);\n        const lockIndex = this.findFirstLockedHandleIndex(oldIndex, newIndex);\n        if (lockIndex === -1) {\n            fillValues(newValues, oldIndex, newIndex, newValue);\n        } else {\n            // If pushing past a locked handle, discard the new value and only make the updates to clamp values against the lock.\n            const lockValue = oldValues[lockIndex];\n            fillValues(oldValues, oldIndex, lockIndex, lockValue);\n            return oldValues;\n        }\n\n        return newValues;\n    }\n\n    private findFirstLockedHandleIndex(startIndex: number, endIndex: number): number {\n        const inc = startIndex < endIndex ? 1 : -1;\n        const handleProps = getSortedInteractiveHandleProps(this.props);\n\n        for (let index = startIndex + inc; index !== endIndex + inc; index += inc) {\n            if (handleProps[index].interactionKind !== HandleInteractionKind.PUSH) {\n                return index;\n            }\n        }\n\n        return -1;\n    }\n\n    private handleChange = (newValues: number[]) => {\n        const handleProps = getSortedInteractiveHandleProps(this.props);\n        const oldValues = handleProps.map(handle => handle.value);\n        if (!Utils.arraysEqual(newValues, oldValues)) {\n            this.props.onChange?.(newValues);\n            handleProps.forEach((handle, index) => {\n                if (oldValues[index] !== newValues[index]) {\n                    handle.onChange?.(newValues[index]);\n                }\n            });\n        }\n    };\n\n    private handleRelease = (newValues: number[]) => {\n        const handleProps = getSortedInteractiveHandleProps(this.props);\n        this.props.onRelease?.(newValues);\n        handleProps.forEach((handle, index) => {\n            handle.onRelease?.(newValues[index]);\n        });\n    };\n\n    private getLabelValues() {\n        const { labelStepSize, labelValues, min, max } = this.props;\n        let values: number[] = [];\n        if (labelValues !== undefined) {\n            values = labelValues.slice();\n        } else {\n            for (let i = min!; i < max! || Utils.approxEqual(i, max!); i += labelStepSize ?? 1) {\n                values.push(i);\n            }\n        }\n\n        return values;\n    }\n\n    private getOffsetRatio(value: number) {\n        return Utils.clamp((value - this.props.min!) * this.state.tickSizeRatio, 0, 1);\n    }\n\n    private getTrackIntent(start: HandleProps, end?: HandleProps): Intent {\n        if (!this.props.showTrackFill) {\n            return Intent.NONE;\n        }\n        if (start.intentAfter !== undefined) {\n            return start.intentAfter;\n        } else if (end !== undefined && end.intentBefore !== undefined) {\n            return end.intentBefore;\n        }\n        return this.props.defaultTrackIntent!;\n    }\n\n    private updateTickSize() {\n        if (this.trackElement != null) {\n            const trackSize = this.props.vertical ? this.trackElement.clientHeight : this.trackElement.clientWidth;\n            const tickSizeRatio = 1 / ((this.props.max as number) - (this.props.min as number));\n            const tickSize = trackSize * tickSizeRatio;\n            this.setState({ tickSize, tickSizeRatio });\n        }\n    }\n}\n\nfunction getLabelPrecision({ labelPrecision, stepSize = MultiSlider.defaultSliderProps.stepSize! }: MultiSliderProps) {\n    // infer default label precision from stepSize because that's how much the handle moves.\n    return labelPrecision == null ? Utils.countDecimalPlaces(stepSize) : labelPrecision;\n}\n\nfunction getSortedInteractiveHandleProps(props: React.PropsWithChildren<MultiSliderProps>): HandleProps[] {\n    return getSortedHandleProps(props, childProps => childProps.interactionKind !== HandleInteractionKind.NONE);\n}\n\nfunction getSortedHandleProps({ children }: MultiSliderProps, predicate: (props: HandleProps) => boolean = () => true) {\n    const maybeHandles = Children.map(children, child =>\n        Utils.isElementOfType(child, MultiSliderHandle) && predicate(child.props) ? child.props : null,\n    );\n    let handles = maybeHandles != null ? maybeHandles : [];\n    handles = handles.filter(handle => handle !== null);\n    handles.sort((left, right) => left.value - right.value);\n    return handles;\n}\n"],"mappings":";AAAA;;;;;;;;;;;;;;;AAgBA,OAAOA,UAAU,MAAM,YAAY;AACnC,SAASC,QAAQ,QAAQ,OAAO;AAEhC,SACIC,qBAAqB,EACrBC,OAAO,EACPC,kBAAkB,EAClBC,MAAM,EAGNC,KAAK,QACF,cAAc;AACrB,OAAO,KAAKC,MAAM,MAAM,qBAAqB;AAE7C,SAASC,MAAM,QAAQ,UAAU;AACjC,SAASC,qBAAqB,EAAoBC,UAAU,QAAQ,eAAe;AACnF,SAASC,MAAM,EAAEC,UAAU,EAAEC,gBAAgB,QAAQ,eAAe;AAEpE;;;;;AAKA,OAAO,MAAMC,iBAAiB,GAA0BA,CAAA,KAAM,IAAI;AAClEA,iBAAiB,CAACC,WAAW,GAAG,GAAGX,kBAAkB,oBAAoB;AAsGzE;;;;;AAKA,OAAM,MAAOY,WAAY,SAAQd,qBAAoD;EAArFe,YAAA;;IA6BW,KAAAC,KAAK,GAAgB;MACxBC,cAAc,EAAEC,iBAAiB,CAAC,IAAI,CAACC,KAAK,CAAC;MAC7CC,QAAQ,EAAE,CAAC;MACXC,aAAa,EAAE;KAClB;IAEO,KAAAC,cAAc,GAAa,EAAE;IAE7B,KAAAC,YAAY,GAAuB,IAAI;IA4KvC,KAAAC,YAAY,GAAIC,GAAW,IAAI;MACnC,IAAIA,GAAG,IAAI,IAAI,EAAE;QACb,IAAI,CAACH,cAAc,CAACI,IAAI,CAACD,GAAG,CAAC;MACjC;IACJ,CAAC;IAEO,KAAAE,qBAAqB,GAAIC,KAAuC,IAAI;MACxE,IAAI,IAAI,CAACC,mBAAmB,CAACD,KAAK,CAAC,EAAE;QACjC,MAAME,WAAW,GAAG,IAAI,CAACC,qBAAqB,CAAC,IAAI,CAACT,cAAc,EAAEU,MAAM,IACtEA,MAAM,CAACC,sBAAsB,CAACL,KAAK,CAAC,CACvC;QACD,IAAIE,WAAW,EAAE;UACbA,WAAW,CAACI,mBAAmB,CAACN,KAAK,CAAC;QAC1C;MACJ;IACJ,CAAC;IAEO,KAAAO,qBAAqB,GAAIP,KAAuC,IAAI;MACxE,IAAI,IAAI,CAACC,mBAAmB,CAACD,KAAK,CAAC,EAAE;QACjC,MAAME,WAAW,GAAG,IAAI,CAACC,qBAAqB,CAAC,IAAI,CAACT,cAAc,EAAEU,MAAM,IACtEA,MAAM,CAACI,sBAAsB,CAACR,KAAK,CAAC,CACvC;QACD,IAAIE,WAAW,EAAE;UACbA,WAAW,CAACO,wBAAwB,CAACT,KAAK,CAAC;QAC/C;MACJ;IACJ,CAAC;IAEO,KAAAC,mBAAmB,GAAID,KAA0E,IAAI;MACzG,MAAMU,MAAM,GAAGV,KAAK,CAACU,MAAqB;MAC1C;MACA,OAAO,CAAC,IAAI,CAACnB,KAAK,CAACoB,QAAQ,IAAID,MAAM,CAACE,OAAO,CAAC,IAAIvC,OAAO,CAACwC,aAAa,EAAE,CAAC,IAAI,IAAI;IACtF,CAAC;IAWO,KAAAC,kBAAkB,GAAG,CAACC,KAAa,EAAEC,QAAqC,KAAI;MAClF,OAAQC,QAAgB,IAAI;QACxBD,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAG,IAAI,CAACE,kBAAkB,CAACD,QAAQ,EAAEF,KAAK,CAAC,CAAC;MACxD,CAAC;IACL,CAAC;IAoCO,KAAAI,YAAY,GAAIC,SAAmB,IAAI;;MAC3C,MAAMC,WAAW,GAAGC,+BAA+B,CAAC,IAAI,CAAC/B,KAAK,CAAC;MAC/D,MAAMgC,SAAS,GAAGF,WAAW,CAACG,GAAG,CAACpB,MAAM,IAAIA,MAAM,CAACqB,KAAK,CAAC;MACzD,IAAI,CAACjD,KAAK,CAACkD,WAAW,CAACN,SAAS,EAAEG,SAAS,CAAC,EAAE;QAC1C,CAAAI,EAAA,IAAAC,EAAA,OAAI,CAACrC,KAAK,EAACsC,QAAQ,cAAAF,EAAA,uBAAAA,EAAA,CAAAG,IAAA,CAAAF,EAAA,EAAGR,SAAS,CAAC;QAChCC,WAAW,CAACU,OAAO,CAAC,CAAC3B,MAAM,EAAEW,KAAK,KAAI;;UAClC,IAAIQ,SAAS,CAACR,KAAK,CAAC,KAAKK,SAAS,CAACL,KAAK,CAAC,EAAE;YACvC,CAAAa,EAAA,GAAAxB,MAAM,CAACyB,QAAQ,cAAAD,EAAA,uBAAAA,EAAA,CAAAE,IAAA,CAAA1B,MAAA,EAAGgB,SAAS,CAACL,KAAK,CAAC,CAAC;UACvC;QACJ,CAAC,CAAC;MACN;IACJ,CAAC;IAEO,KAAAiB,aAAa,GAAIZ,SAAmB,IAAI;;MAC5C,MAAMC,WAAW,GAAGC,+BAA+B,CAAC,IAAI,CAAC/B,KAAK,CAAC;MAC/D,CAAAoC,EAAA,IAAAC,EAAA,OAAI,CAACrC,KAAK,EAAC0C,SAAS,cAAAN,EAAA,uBAAAA,EAAA,CAAAG,IAAA,CAAAF,EAAA,EAAGR,SAAS,CAAC;MACjCC,WAAW,CAACU,OAAO,CAAC,CAAC3B,MAAM,EAAEW,KAAK,KAAI;;QAClC,CAAAa,EAAA,GAAAxB,MAAM,CAAC6B,SAAS,cAAAL,EAAA,uBAAAA,EAAA,CAAAE,IAAA,CAAA1B,MAAA,EAAGgB,SAAS,CAACL,KAAK,CAAC,CAAC;MACxC,CAAC,CAAC;IACN,CAAC;EAwCL;EA3UW,OAAOmB,wBAAwBA,CAAC3C,KAAuB;IAC1D,OAAO;MAAEF,cAAc,EAAEH,WAAW,CAACI,iBAAiB,CAACC,KAAK;IAAC,CAAE;EACnE;EAEQ,OAAOD,iBAAiBA,CAAC;IAAED,cAAc;IAAE8C;EAAQ,CAAoB;IAC3E;IACA,OAAO9C,cAAc,IAAI,IAAI,GAAGb,KAAK,CAAC4D,kBAAkB,CAACD,QAAS,CAAC,GAAG9C,cAAc;EACxF;EAYOgD,uBAAuBA,CAACC,SAA2B;IACtD,MAAMC,eAAe,GAAGjB,+BAA+B,CAACgB,SAAS,CAAC;IAClE,MAAME,cAAc,GAAGlB,+BAA+B,CAAC,IAAI,CAAC/B,KAAK,CAAC;IAClE,IAAIiD,cAAc,CAACC,MAAM,KAAKF,eAAe,CAACE,MAAM,EAAE;MAClD;MACA,IAAI,CAAC/C,cAAc,GAAG,EAAE;IAC5B;IACA,OAAO,IAAI;EACf;EAEOgD,MAAMA,CAAA;IACT,MAAMC,OAAO,GAAGzE,UAAU,CACtBG,OAAO,CAACuE,MAAM,EACd;MACI,CAACvE,OAAO,CAACwE,QAAQ,GAAG,IAAI,CAACtD,KAAK,CAACoB,QAAQ;MACvC,CAAC,GAAGtC,OAAO,CAACuE,MAAM,YAAY,GAAG,IAAI,CAACrD,KAAK,CAACuD,aAAa,KAAK,KAAK;MACnE,CAACzE,OAAO,CAAC0E,QAAQ,GAAG,IAAI,CAACxD,KAAK,CAACyD;KAClC,EACD,IAAI,CAACzD,KAAK,CAAC0D,SAAS,CACvB;IACD,OACIC,KAAA;MAAKD,SAAS,EAAEN,OAAO;MAAEQ,WAAW,EAAE,IAAI,CAACpD,qBAAqB;MAAEqD,YAAY,EAAE,IAAI,CAAC7C,qBAAqB;MAAA8C,QAAA,GACtGC,IAAA;QAAKL,SAAS,EAAE5E,OAAO,CAACkF,YAAY;QAAE1D,GAAG,EAAEA,GAAG,IAAK,IAAI,CAACF,YAAY,GAAGE,GAAI;QAAAwD,QAAA,EACtE,IAAI,CAACG,YAAY;MAAE,EAClB,EACNF,IAAA;QAAKL,SAAS,EAAE5E,OAAO,CAACoF,WAAW;QAAAJ,QAAA,EAAG,IAAI,CAACK,YAAY;MAAE,EAAO,EAC/D,IAAI,CAACC,aAAa,EAAE;IAAA,EACnB;EAEd;EAEOC,iBAAiBA,CAAA;IACpB,IAAI,CAACC,cAAc,EAAE;EACzB;EAEOC,kBAAkBA,CAACxB,SAA2B,EAAEyB,SAAsB;IACzE,KAAK,CAACD,kBAAkB,CAACxB,SAAS,EAAEyB,SAAS,CAAC;IAC9C,IAAI,CAACF,cAAc,EAAE;EACzB;EAEUG,aAAaA,CAACzE,KAAgD;IACpE,IAAIA,KAAK,CAAC4C,QAAS,IAAI,CAAC,EAAE;MACtB,MAAM,IAAI8B,KAAK,CAACxF,MAAM,CAACyF,gBAAgB,CAAC;IAC5C;IACA,IAAI3E,KAAK,CAAC4E,aAAa,KAAKC,SAAS,IAAI7E,KAAK,CAAC8E,WAAW,KAAKD,SAAS,EAAE;MACtE,MAAM,IAAIH,KAAK,CAACxF,MAAM,CAAC6F,mDAAmD,CAAC;IAC/E;IACA,IAAI/E,KAAK,CAAC4E,aAAa,KAAKC,SAAS,IAAI7E,KAAK,CAAC4E,aAAc,IAAI,CAAC,EAAE;MAChE,MAAM,IAAIF,KAAK,CAACxF,MAAM,CAAC8F,sBAAsB,CAAC;IAClD;IACA,IAAIhF,KAAK,CAACiF,GAAG,KAAKJ,SAAS,IAAI,CAACK,QAAQ,CAAClF,KAAK,CAACiF,GAAG,CAAC,EAAE;MACjD,MAAM,IAAIP,KAAK,CAACxF,MAAM,CAACiG,UAAU,CAAC;IACtC;IACA,IAAInF,KAAK,CAACoF,GAAG,KAAKP,SAAS,IAAI,CAACK,QAAQ,CAAClF,KAAK,CAACoF,GAAG,CAAC,EAAE;MACjD,MAAM,IAAIV,KAAK,CAACxF,MAAM,CAACmG,UAAU,CAAC;IACtC;IAEA,IAAIC,kBAAkB,GAAG,KAAK;IAC9B1G,QAAQ,CAAC4D,OAAO,CAACxC,KAAK,CAAC8D,QAAQ,EAAEyB,KAAK,IAAG;MACrC;MACA,IAAIA,KAAK,IAAI,CAACtG,KAAK,CAACuG,eAAe,CAACD,KAAK,EAAE9F,iBAAiB,CAAC,EAAE;QAC3D6F,kBAAkB,GAAG,IAAI;MAC7B;IACJ,CAAC,CAAC;IACF,IAAIA,kBAAkB,EAAE;MACpB,MAAM,IAAIZ,KAAK,CAACxF,MAAM,CAACuG,yBAAyB,CAAC;IACrD;EACJ;EAEQC,WAAWA,CAACxD,KAAa,EAAEyD,eAAA,GAA2B,KAAK;IAC/D,MAAM;MAAEpC;IAAa,CAAE,GAAG,IAAI,CAACvD,KAAK;IACpC,IAAIuD,aAAa,KAAK,KAAK,EAAE;MACzB,OAAOsB,SAAS;IACpB,CAAC,MAAM,IAAI5F,KAAK,CAAC2G,UAAU,CAACrC,aAAa,CAAC,EAAE;MACxC,OAAOA,aAAa,CAACrB,KAAK,EAAE;QAAEyD;MAAe,CAAE,CAAC;IACpD,CAAC,MAAM;MACH,OAAOzD,KAAK,CAAC2D,OAAO,CAAC,IAAI,CAAChG,KAAK,CAACC,cAAc,CAAC;IACnD;EACJ;EAEQqE,YAAYA,CAAA;IAChB,IAAI,IAAI,CAACnE,KAAK,CAACuD,aAAa,KAAK,KAAK,EAAE;MACpC,OAAO,IAAI;IACf;IAEA,MAAMuC,MAAM,GAAG,IAAI,CAACC,cAAc,EAAE;IACpC,MAAM;MAAEX,GAAG;MAAEH;IAAG,CAAE,GAAG,IAAI,CAACjF,KAAK;IAC/B,MAAMgG,MAAM,GAAGF,MAAM,CAAC7D,GAAG,CAAC,CAACgE,IAAI,EAAEC,CAAC,KAAI;MAClC,MAAMC,gBAAgB,GAAG3G,gBAAgB,CAAC,CAACyG,IAAI,GAAGhB,GAAI,KAAKG,GAAI,GAAGH,GAAI,CAAC,CAAC;MACxE,MAAMmB,KAAK,GAAG,IAAI,CAACpG,KAAK,CAACyD,QAAQ,GAAG;QAAE4C,MAAM,EAAEF;MAAgB,CAAE,GAAG;QAAEG,IAAI,EAAEH;MAAgB,CAAE;MAC7F,OACIpC,IAAA;QAAKL,SAAS,EAAE5E,OAAO,CAACyH,YAAY;QAAUH,KAAK,EAAEA,KAAK;QAAAtC,QAAA,EACrD,IAAI,CAAC4B,WAAW,CAACO,IAAI;MAAC,GADgBC,CAAC,CAEtC;IAEd,CAAC,CAAC;IAEF,OAAOF,MAAM;EACjB;EAEQ/B,YAAYA,CAAA;IAChB,MAAMuC,UAAU,GAAGC,oBAAoB,CAAC,IAAI,CAACzG,KAAK,CAAC;IACnDwG,UAAU,CAACjG,IAAI,CAAC;MAAE2B,KAAK,EAAE,IAAI,CAAClC,KAAK,CAACoF;IAAI,CAAE,CAAC;IAE3C;IACA,IAAIsB,QAAQ,GAAgB;MAAExE,KAAK,EAAE,IAAI,CAAClC,KAAK,CAACiF;IAAI,CAAE;IACtD,MAAM0B,OAAO,GAAwB,EAAE;IACvC,KAAK,IAAInF,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGgF,UAAU,CAACtD,MAAM,EAAE1B,KAAK,EAAE,EAAE;MACpD,MAAMoF,OAAO,GAAGJ,UAAU,CAAChF,KAAK,CAAC;MACjCmF,OAAO,CAACpG,IAAI,CAAC,IAAI,CAACsG,eAAe,CAACrF,KAAK,EAAEkF,QAAQ,EAAEE,OAAO,CAAC,CAAC;MAC5DF,QAAQ,GAAGE,OAAO;IACtB;IACA,OAAOD,OAAO;EAClB;EAEQE,eAAeA,CAACrF,KAAa,EAAEsF,KAAkB,EAAEC,GAAgB;IACvE;IACA,MAAM,CAACC,UAAU,EAAEC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAACC,cAAc,CAACJ,KAAK,CAAC5E,KAAK,CAAC,EAAE,IAAI,CAACgF,cAAc,CAACH,GAAG,CAAC7E,KAAK,CAAC,CAAC,CAACiF,IAAI,CAClG,CAACb,IAAI,EAAEc,KAAK,KAAKd,IAAI,GAAGc,KAAK,CAChC;IACD,MAAMC,WAAW,GAAG7H,gBAAgB,CAACwH,UAAU,CAAC;IAChD,MAAMM,SAAS,GAAG9H,gBAAgB,CAAC,CAAC,GAAGyH,QAAQ,CAAC;IAChD,MAAMM,gBAAgB,GAAwB,IAAI,CAACvH,KAAK,CAACyD,QAAQ,GAC3D;MAAE4C,MAAM,EAAEgB,WAAW;MAAEf,IAAI,EAAE,CAAC;MAAEkB,GAAG,EAAEF;IAAS,CAAE,GAChD;MAAEhB,IAAI,EAAEe,WAAW;MAAED,KAAK,EAAEE,SAAS;MAAEE,GAAG,EAAE;IAAC,CAAE;IAErD,MAAMpB,KAAK,GAAwB;MAC/B,GAAGmB,gBAAgB;MACnB,IAAIT,KAAK,CAACW,eAAe,IAAIV,GAAG,CAACW,gBAAgB,IAAI,EAAE;KAC1D;IAED,MAAMtE,OAAO,GAAGzE,UAAU,CAACG,OAAO,CAAC6I,eAAe,EAAE7I,OAAO,CAAC8I,WAAW,CAAC,IAAI,CAACC,cAAc,CAACf,KAAK,EAAEC,GAAG,CAAC,CAAC,CAAC;IACzG,OAAOhD,IAAA;MAA4BL,SAAS,EAAEN,OAAO;MAAEgD,KAAK,EAAEA;IAAK,GAAlD,SAAS5E,KAAK,EAAE,CAAsC;EAC3E;EAEQ4C,aAAaA,CAAA;IACjB,MAAM;MAAEhD,QAAQ;MAAEgE,GAAG;MAAEH,GAAG;MAAErC,QAAQ;MAAEa;IAAQ,CAAE,GAAG,IAAI,CAACzD,KAAK;IAC7D,MAAM8B,WAAW,GAAGC,+BAA+B,CAAC,IAAI,CAAC/B,KAAK,CAAC;IAE/D,IAAI8B,WAAW,CAACoB,MAAM,KAAK,CAAC,EAAE;MAC1B,OAAO,IAAI;IACf;IAEA,OAAOpB,WAAW,CAACG,GAAG,CAAC,CAAC;MAAEC,KAAK;MAAE4F,IAAI;MAAEpE,SAAS;MAAEqE;IAAS,CAAE,EAAEvG,KAAK,KAChEuC,IAAA,CAAC5E,MAAM;MACH4I,SAAS,EAAEA,SAAS;MACpBrE,SAAS,EAAE/E,UAAU,CACjB;QACI,CAACG,OAAO,CAACkJ,KAAK,GAAGF,IAAI,KAAKzI,UAAU,CAAC2I,KAAK;QAC1C,CAAClJ,OAAO,CAACmJ,GAAG,GAAGH,IAAI,KAAKzI,UAAU,CAAC4I;OACtC,EACDvE,SAAS,CACZ;MACDtC,QAAQ,EAAEA,QAAQ;MAElB8G,KAAK,EAAE,IAAI,CAACxC,WAAW,CAACxD,KAAK,EAAE,IAAI,CAAC;MACpCkD,GAAG,EAAEA,GAAI;MACTH,GAAG,EAAEA,GAAI;MACT3C,QAAQ,EAAE,IAAI,CAACf,kBAAkB,CAACC,KAAK,EAAE,IAAI,CAACI,YAAY,CAAC;MAC3Dc,SAAS,EAAE,IAAI,CAACnB,kBAAkB,CAACC,KAAK,EAAE,IAAI,CAACiB,aAAa,CAAC;MAC7DnC,GAAG,EAAE,IAAI,CAACD,YAAY;MACtBuC,QAAQ,EAAEA,QAAS;MACnB3C,QAAQ,EAAE,IAAI,CAACJ,KAAK,CAACI,QAAQ;MAC7BC,aAAa,EAAE,IAAI,CAACL,KAAK,CAACK,aAAa;MACvCgC,KAAK,EAAEA,KAAK;MACZuB,QAAQ,EAAEA;IAAS,GAXd,GAAGjC,KAAK,IAAIM,WAAW,CAACoB,MAAM,EAAE,CAa5C,CAAC;EACN;EAoCQtC,qBAAqBA,CAAC+F,OAAiB,EAAEwB,SAAqC;IAClF,OAAO7I,MAAM,CAACqH,OAAO,EAAE9F,MAAM,IAAG;MAC5B,MAAMuH,MAAM,GAAGD,SAAS,CAACtH,MAAM,CAAC;MAChC,MAAMwH,WAAW,GAAGxH,MAAM,CAACyH,aAAa,CAACF,MAAM,CAAC;MAChD,MAAMG,WAAW,GAAG1H,MAAM,CAACb,KAAK,CAACkC,KAAM;MACvC,OAAOsG,IAAI,CAACC,GAAG,CAACJ,WAAW,GAAGE,WAAW,CAAC;IAC9C,CAAC,CAAC;EACN;EAQQ5G,kBAAkBA,CAACD,QAAgB,EAAEgH,QAAgB;IACzD,MAAM5G,WAAW,GAAGC,+BAA+B,CAAC,IAAI,CAAC/B,KAAK,CAAC;IAC/D,MAAMgC,SAAS,GAAGF,WAAW,CAACG,GAAG,CAACpB,MAAM,IAAIA,MAAM,CAACqB,KAAK,CAAC;IACzD,MAAML,SAAS,GAAGG,SAAS,CAAC2G,KAAK,EAAE;IACnC9G,SAAS,CAAC6G,QAAQ,CAAC,GAAGhH,QAAQ;IAC9BG,SAAS,CAACsF,IAAI,CAAC,CAACb,IAAI,EAAEc,KAAK,KAAKd,IAAI,GAAGc,KAAK,CAAC;IAE7C,MAAMwB,QAAQ,GAAG/G,SAAS,CAACgH,OAAO,CAACnH,QAAQ,CAAC;IAC5C,MAAMoH,SAAS,GAAG,IAAI,CAACC,0BAA0B,CAACL,QAAQ,EAAEE,QAAQ,CAAC;IACrE,IAAIE,SAAS,KAAK,CAAC,CAAC,EAAE;MAClBvJ,UAAU,CAACsC,SAAS,EAAE6G,QAAQ,EAAEE,QAAQ,EAAElH,QAAQ,CAAC;IACvD,CAAC,MAAM;MACH;MACA,MAAMsH,SAAS,GAAGhH,SAAS,CAAC8G,SAAS,CAAC;MACtCvJ,UAAU,CAACyC,SAAS,EAAE0G,QAAQ,EAAEI,SAAS,EAAEE,SAAS,CAAC;MACrD,OAAOhH,SAAS;IACpB;IAEA,OAAOH,SAAS;EACpB;EAEQkH,0BAA0BA,CAACE,UAAkB,EAAEC,QAAgB;IACnE,MAAMC,GAAG,GAAGF,UAAU,GAAGC,QAAQ,GAAG,CAAC,GAAG,CAAC,CAAC;IAC1C,MAAMpH,WAAW,GAAGC,+BAA+B,CAAC,IAAI,CAAC/B,KAAK,CAAC;IAE/D,KAAK,IAAIwB,KAAK,GAAGyH,UAAU,GAAGE,GAAG,EAAE3H,KAAK,KAAK0H,QAAQ,GAAGC,GAAG,EAAE3H,KAAK,IAAI2H,GAAG,EAAE;MACvE,IAAIrH,WAAW,CAACN,KAAK,CAAC,CAAC4H,eAAe,KAAKhK,qBAAqB,CAACiK,IAAI,EAAE;QACnE,OAAO7H,KAAK;MAChB;IACJ;IAEA,OAAO,CAAC,CAAC;EACb;EAuBQuE,cAAcA,CAAA;IAClB,MAAM;MAAEnB,aAAa;MAAEE,WAAW;MAAEG,GAAG;MAAEG;IAAG,CAAE,GAAG,IAAI,CAACpF,KAAK;IAC3D,IAAI8F,MAAM,GAAa,EAAE;IACzB,IAAIhB,WAAW,KAAKD,SAAS,EAAE;MAC3BiB,MAAM,GAAGhB,WAAW,CAAC6D,KAAK,EAAE;IAChC,CAAC,MAAM;MACH,KAAK,IAAIzC,CAAC,GAAGjB,GAAI,EAAEiB,CAAC,GAAGd,GAAI,IAAInG,KAAK,CAACqK,WAAW,CAACpD,CAAC,EAAEd,GAAI,CAAC,EAAEc,CAAC,IAAItB,aAAa,aAAbA,aAAa,cAAbA,aAAa,GAAI,CAAC,EAAE;QAChFkB,MAAM,CAACvF,IAAI,CAAC2F,CAAC,CAAC;MAClB;IACJ;IAEA,OAAOJ,MAAM;EACjB;EAEQoB,cAAcA,CAAChF,KAAa;IAChC,OAAOjD,KAAK,CAACsK,KAAK,CAAC,CAACrH,KAAK,GAAG,IAAI,CAAClC,KAAK,CAACiF,GAAI,IAAI,IAAI,CAACpF,KAAK,CAACK,aAAa,EAAE,CAAC,EAAE,CAAC,CAAC;EAClF;EAEQ2H,cAAcA,CAACf,KAAkB,EAAEC,GAAiB;IACxD,IAAI,CAAC,IAAI,CAAC/G,KAAK,CAACwJ,aAAa,EAAE;MAC3B,OAAOxK,MAAM,CAACyK,IAAI;IACtB;IACA,IAAI3C,KAAK,CAAC4C,WAAW,KAAK7E,SAAS,EAAE;MACjC,OAAOiC,KAAK,CAAC4C,WAAW;IAC5B,CAAC,MAAM,IAAI3C,GAAG,KAAKlC,SAAS,IAAIkC,GAAG,CAAC4C,YAAY,KAAK9E,SAAS,EAAE;MAC5D,OAAOkC,GAAG,CAAC4C,YAAY;IAC3B;IACA,OAAO,IAAI,CAAC3J,KAAK,CAAC4J,kBAAmB;EACzC;EAEQtF,cAAcA,CAAA;IAClB,IAAI,IAAI,CAAClE,YAAY,IAAI,IAAI,EAAE;MAC3B,MAAMyJ,SAAS,GAAG,IAAI,CAAC7J,KAAK,CAACyD,QAAQ,GAAG,IAAI,CAACrD,YAAY,CAAC0J,YAAY,GAAG,IAAI,CAAC1J,YAAY,CAAC2J,WAAW;MACtG,MAAM7J,aAAa,GAAG,CAAC,IAAK,IAAI,CAACF,KAAK,CAACoF,GAAc,GAAI,IAAI,CAACpF,KAAK,CAACiF,GAAc,CAAC;MACnF,MAAMhF,QAAQ,GAAG4J,SAAS,GAAG3J,aAAa;MAC1C,IAAI,CAAC8J,QAAQ,CAAC;QAAE/J,QAAQ;QAAEC;MAAa,CAAE,CAAC;IAC9C;EACJ;;AA7VcP,WAAA,CAAAsK,kBAAkB,GAAoB;EAChD7I,QAAQ,EAAE,KAAK;EACfgE,GAAG,EAAE,EAAE;EACPH,GAAG,EAAE,CAAC;EACNuE,aAAa,EAAE,IAAI;EACnB5G,QAAQ,EAAE,CAAC;EACXa,QAAQ,EAAE;CACb;AAEa9D,WAAA,CAAAuK,YAAY,GAAqB;EAC3C,GAAGvK,WAAW,CAACsK,kBAAkB;EACjCL,kBAAkB,EAAE5K,MAAM,CAACyK;CAC9B;AAEa9J,WAAA,CAAAD,WAAW,GAAG,GAAGX,kBAAkB,cAAc;AAE/D;AACcY,WAAA,CAAAR,MAAM,GAAGM,iBAAiB;AA+U5C,SAASM,iBAAiBA,CAAC;EAAED,cAAc;EAAE8C,QAAQ,GAAGjD,WAAW,CAACsK,kBAAkB,CAACrH;AAAS,CAAoB;EAChH;EACA,OAAO9C,cAAc,IAAI,IAAI,GAAGb,KAAK,CAAC4D,kBAAkB,CAACD,QAAQ,CAAC,GAAG9C,cAAc;AACvF;AAEA,SAASiC,+BAA+BA,CAAC/B,KAAgD;EACrF,OAAOyG,oBAAoB,CAACzG,KAAK,EAAEmK,UAAU,IAAIA,UAAU,CAACf,eAAe,KAAKhK,qBAAqB,CAACqK,IAAI,CAAC;AAC/G;AAEA,SAAShD,oBAAoBA,CAAC;EAAE3C;AAAQ,CAAoB,EAAEsG,SAAA,GAA6CA,CAAA,KAAM,IAAI;EACjH,MAAMC,YAAY,GAAGzL,QAAQ,CAACqD,GAAG,CAAC6B,QAAQ,EAAEyB,KAAK,IAC7CtG,KAAK,CAACuG,eAAe,CAACD,KAAK,EAAE9F,iBAAiB,CAAC,IAAI2K,SAAS,CAAC7E,KAAK,CAACvF,KAAK,CAAC,GAAGuF,KAAK,CAACvF,KAAK,GAAG,IAAI,CACjG;EACD,IAAI2G,OAAO,GAAG0D,YAAY,IAAI,IAAI,GAAGA,YAAY,GAAG,EAAE;EACtD1D,OAAO,GAAGA,OAAO,CAAC2D,MAAM,CAACzJ,MAAM,IAAIA,MAAM,KAAK,IAAI,CAAC;EACnD8F,OAAO,CAACQ,IAAI,CAAC,CAACb,IAAI,EAAEc,KAAK,KAAKd,IAAI,CAACpE,KAAK,GAAGkF,KAAK,CAAClF,KAAK,CAAC;EACvD,OAAOyE,OAAO;AAClB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}