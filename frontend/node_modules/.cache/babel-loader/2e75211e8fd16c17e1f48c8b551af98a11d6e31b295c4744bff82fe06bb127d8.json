{"ast":null,"code":"import { jsx as _jsx } from \"react/jsx-runtime\";\n/*\n * Copyright 2015 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @fileoverview This component is DEPRECATED, and the code is frozen.\n * All changes & bugfixes should be made to Overlay2 instead.\n */\n/* eslint-disable @typescript-eslint/no-deprecated */\nimport classNames from \"classnames\";\nimport { Children, cloneElement, createRef } from \"react\";\nimport { CSSTransition, TransitionGroup } from \"react-transition-group\";\nimport { AbstractPureComponent, Classes } from \"../../common\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\nimport { getActiveElement, isFunction } from \"../../common/utils\";\nimport { Portal } from \"../portal/portal\";\nimport { getKeyboardFocusableElements } from \"./overlayUtils\";\n/**\n * Overlay component.\n *\n * @deprecated use `Overlay2` instead\n * @see https://blueprintjs.com/docs/#core/components/overlay\n */\nexport class Overlay extends AbstractPureComponent {\n  constructor() {\n    super(...arguments);\n    this.isAutoFocusing = false;\n    this.state = {\n      hasEverOpened: this.props.isOpen\n    };\n    /** Ref for container element, containing all children and the backdrop */\n    this.containerElement = createRef();\n    // An empty, keyboard-focusable div at the beginning of the Overlay content\n    this.startFocusTrapElement = createRef();\n    // An empty, keyboard-focusable div at the end of the Overlay content\n    this.endFocusTrapElement = createRef();\n    this.maybeRenderChild = child => {\n      if (isFunction(child)) {\n        child = child();\n      }\n      if (child == null) {\n        return null;\n      }\n      // decorate the child with a few injected props\n      const tabIndex = this.props.enforceFocus || this.props.autoFocus ? 0 : undefined;\n      const decoratedChild = typeof child === \"object\" ? cloneElement(child, {\n        className: classNames(child.props.className, Classes.OVERLAY_CONTENT),\n        tabIndex\n      }) : _jsx(\"span\", {\n        className: Classes.OVERLAY_CONTENT,\n        tabIndex: tabIndex,\n        children: child\n      });\n      const {\n        onOpening,\n        onOpened,\n        onClosing,\n        transitionDuration,\n        transitionName\n      } = this.props;\n      return _jsx(CSSTransition, {\n        classNames: transitionName,\n        onEntering: onOpening,\n        onEntered: onOpened,\n        onExiting: onClosing,\n        onExited: this.handleTransitionExited,\n        timeout: transitionDuration,\n        addEndListener: this.handleTransitionAddEnd,\n        children: decoratedChild\n      });\n    };\n    /**\n     * Ensures repeatedly pressing shift+tab keeps focus inside the Overlay. Moves focus to\n     * the `endFocusTrapElement` or the first keyboard-focusable element in the Overlay (excluding\n     * the `startFocusTrapElement`), depending on whether the element losing focus is inside the\n     * Overlay.\n     */\n    this.handleStartFocusTrapElementFocus = e => {\n      var _a, _b;\n      if (!this.props.enforceFocus || this.isAutoFocusing) {\n        return;\n      }\n      // e.relatedTarget will not be defined if this was a programmatic focus event, as is the\n      // case when we call this.bringFocusInsideOverlay() after a user clicked on the backdrop.\n      // Otherwise, we're handling a user interaction, and we should wrap around to the last\n      // element in this transition group.\n      if (e.relatedTarget != null && ((_a = this.containerElement.current) === null || _a === void 0 ? void 0 : _a.contains(e.relatedTarget)) && e.relatedTarget !== this.endFocusTrapElement.current) {\n        (_b = this.endFocusTrapElement.current) === null || _b === void 0 ? void 0 : _b.focus({\n          preventScroll: true\n        });\n      }\n    };\n    /**\n     * Wrap around to the end of the dialog if `enforceFocus` is enabled.\n     */\n    this.handleStartFocusTrapElementKeyDown = e => {\n      var _a;\n      if (!this.props.enforceFocus) {\n        return;\n      }\n      if (e.shiftKey && e.key === \"Tab\") {\n        const lastFocusableElement = getKeyboardFocusableElements(this.containerElement).pop();\n        if (lastFocusableElement != null) {\n          lastFocusableElement.focus();\n        } else {\n          (_a = this.endFocusTrapElement.current) === null || _a === void 0 ? void 0 : _a.focus({\n            preventScroll: true\n          });\n        }\n      }\n    };\n    /**\n     * Ensures repeatedly pressing tab keeps focus inside the Overlay. Moves focus to the\n     * `startFocusTrapElement` or the last keyboard-focusable element in the Overlay (excluding the\n     * `startFocusTrapElement`), depending on whether the element losing focus is inside the\n     * Overlay.\n     */\n    this.handleEndFocusTrapElementFocus = e => {\n      var _a, _b, _c;\n      // No need for this.props.enforceFocus check here because this element is only rendered\n      // when that prop is true.\n      // During user interactions, e.relatedTarget will be defined, and we should wrap around to the\n      // \"start focus trap\" element.\n      // Otherwise, we're handling a programmatic focus event, which can only happen after a user\n      // presses shift+tab from the first focusable element in the overlay.\n      if (e.relatedTarget != null && ((_a = this.containerElement.current) === null || _a === void 0 ? void 0 : _a.contains(e.relatedTarget)) && e.relatedTarget !== this.startFocusTrapElement.current) {\n        const firstFocusableElement = getKeyboardFocusableElements(this.containerElement).shift();\n        // ensure we don't re-focus an already active element by comparing against e.relatedTarget\n        if (!this.isAutoFocusing && firstFocusableElement != null && firstFocusableElement !== e.relatedTarget) {\n          firstFocusableElement.focus();\n        } else {\n          (_b = this.startFocusTrapElement.current) === null || _b === void 0 ? void 0 : _b.focus({\n            preventScroll: true\n          });\n        }\n      } else {\n        const lastFocusableElement = getKeyboardFocusableElements(this.containerElement).pop();\n        if (lastFocusableElement != null) {\n          lastFocusableElement.focus();\n        } else {\n          // Keeps focus within Overlay even if there are no keyboard-focusable children\n          (_c = this.startFocusTrapElement.current) === null || _c === void 0 ? void 0 : _c.focus({\n            preventScroll: true\n          });\n        }\n      }\n    };\n    this.handleTransitionExited = node => {\n      var _a, _b;\n      if (this.props.shouldReturnFocusOnClose && this.lastActiveElementBeforeOpened instanceof HTMLElement) {\n        this.lastActiveElementBeforeOpened.focus();\n      }\n      (_b = (_a = this.props).onClosed) === null || _b === void 0 ? void 0 : _b.call(_a, node);\n    };\n    this.handleBackdropMouseDown = e => {\n      var _a;\n      const {\n        backdropProps,\n        canOutsideClickClose,\n        enforceFocus,\n        onClose\n      } = this.props;\n      if (canOutsideClickClose) {\n        onClose === null || onClose === void 0 ? void 0 : onClose(e);\n      }\n      if (enforceFocus) {\n        this.bringFocusInsideOverlay();\n      }\n      (_a = backdropProps === null || backdropProps === void 0 ? void 0 : backdropProps.onMouseDown) === null || _a === void 0 ? void 0 : _a.call(backdropProps, e);\n    };\n    this.handleDocumentClick = e => {\n      const {\n        canOutsideClickClose,\n        isOpen,\n        onClose\n      } = this.props;\n      // get the actual target even in the Shadow DOM\n      // see https://github.com/palantir/blueprint/issues/4220\n      const eventTarget = e.composed ? e.composedPath()[0] : e.target;\n      const stackIndex = Overlay.openStack.indexOf(this);\n      const isClickInThisOverlayOrDescendant = Overlay.openStack.slice(stackIndex).some(({\n        containerElement: elem\n      }) => {\n        var _a;\n        // `elem` is the container of backdrop & content, so clicking directly on that container\n        // should not count as being \"inside\" the overlay.\n        return ((_a = elem.current) === null || _a === void 0 ? void 0 : _a.contains(eventTarget)) && !elem.current.isSameNode(eventTarget);\n      });\n      if (isOpen && !isClickInThisOverlayOrDescendant && canOutsideClickClose) {\n        // casting to any because this is a native event\n        onClose === null || onClose === void 0 ? void 0 : onClose(e);\n      }\n    };\n    /**\n     * When multiple Overlays are open, this event handler is only active for the most recently\n     * opened one to avoid Overlays competing with each other for focus.\n     */\n    this.handleDocumentFocus = e => {\n      // get the actual target even in the Shadow DOM\n      // see https://github.com/palantir/blueprint/issues/4220\n      const eventTarget = e.composed ? e.composedPath()[0] : e.target;\n      if (this.props.enforceFocus && this.containerElement.current != null && eventTarget instanceof Node && !this.containerElement.current.contains(eventTarget)) {\n        // prevent default focus behavior (sometimes auto-scrolls the page)\n        e.preventDefault();\n        e.stopImmediatePropagation();\n        this.bringFocusInsideOverlay();\n      }\n    };\n    this.handleKeyDown = e => {\n      const {\n        canEscapeKeyClose,\n        onClose\n      } = this.props;\n      if (e.key === \"Escape\" && canEscapeKeyClose) {\n        onClose === null || onClose === void 0 ? void 0 : onClose(e);\n        // prevent other overlays from closing\n        e.stopPropagation();\n        // prevent browser-specific escape key behavior (Safari exits fullscreen)\n        e.preventDefault();\n      }\n    };\n    this.handleTransitionAddEnd = () => {\n      // no-op\n    };\n  }\n  static getDerivedStateFromProps({\n    isOpen: hasEverOpened\n  }) {\n    if (hasEverOpened) {\n      return {\n        hasEverOpened\n      };\n    }\n    return null;\n  }\n  render() {\n    var _a;\n    // oh snap! no reason to render anything at all if we're being truly lazy\n    if (this.props.lazy && !this.state.hasEverOpened) {\n      return null;\n    }\n    const {\n      autoFocus,\n      children,\n      className,\n      enforceFocus,\n      usePortal,\n      isOpen\n    } = this.props;\n    // TransitionGroup types require single array of children; does not support nested arrays.\n    // So we must collapse backdrop and children into one array, and every item must be wrapped in a\n    // Transition element (no ReactText allowed).\n    const childrenWithTransitions = isOpen ? (_a = Children.map(children, this.maybeRenderChild)) !== null && _a !== void 0 ? _a : [] : [];\n    const maybeBackdrop = this.maybeRenderBackdrop();\n    if (maybeBackdrop !== null) {\n      childrenWithTransitions.unshift(maybeBackdrop);\n    }\n    if (isOpen && (autoFocus || enforceFocus) && childrenWithTransitions.length > 0) {\n      childrenWithTransitions.unshift(this.renderDummyElement(\"__start\", {\n        className: Classes.OVERLAY_START_FOCUS_TRAP,\n        onFocus: this.handleStartFocusTrapElementFocus,\n        onKeyDown: this.handleStartFocusTrapElementKeyDown,\n        ref: this.startFocusTrapElement\n      }));\n      if (enforceFocus) {\n        childrenWithTransitions.push(this.renderDummyElement(\"__end\", {\n          className: Classes.OVERLAY_END_FOCUS_TRAP,\n          onFocus: this.handleEndFocusTrapElementFocus,\n          ref: this.endFocusTrapElement\n        }));\n      }\n    }\n    const containerClasses = classNames(Classes.OVERLAY, {\n      [Classes.OVERLAY_OPEN]: isOpen,\n      [Classes.OVERLAY_INLINE]: !usePortal\n    }, className);\n    const transitionGroup = _jsx(\"div\", {\n      \"aria-live\": \"polite\",\n      className: containerClasses,\n      onKeyDown: this.handleKeyDown,\n      ref: this.containerElement,\n      children: _jsx(TransitionGroup, {\n        appear: true,\n        component: null,\n        children: childrenWithTransitions\n      })\n    });\n    if (usePortal) {\n      return _jsx(Portal, {\n        className: this.props.portalClassName,\n        container: this.props.portalContainer,\n        stopPropagationEvents: this.props.portalStopPropagationEvents,\n        children: transitionGroup\n      });\n    } else {\n      return transitionGroup;\n    }\n  }\n  componentDidMount() {\n    if (this.props.isOpen) {\n      this.overlayWillOpen();\n    }\n  }\n  componentDidUpdate(prevProps) {\n    if (prevProps.isOpen && !this.props.isOpen) {\n      this.overlayWillClose();\n    } else if (!prevProps.isOpen && this.props.isOpen) {\n      this.overlayWillOpen();\n    }\n  }\n  componentWillUnmount() {\n    this.overlayWillClose();\n  }\n  /**\n   * @public for testing\n   * @internal\n   */\n  bringFocusInsideOverlay() {\n    // always delay focus manipulation to just before repaint to prevent scroll jumping\n    return this.requestAnimationFrame(() => {\n      var _a;\n      // container element may be undefined between component mounting and Portal rendering\n      // activeElement may be undefined in some rare cases in IE\n      const activeElement = getActiveElement(this.containerElement.current);\n      if (this.containerElement.current == null || activeElement == null || !this.props.isOpen) {\n        return;\n      }\n      const container = this.containerElement.current;\n      const isFocusOutsideModal = !container.contains(activeElement);\n      if (isFocusOutsideModal) {\n        (_a = this.startFocusTrapElement.current) === null || _a === void 0 ? void 0 : _a.focus({\n          preventScroll: true\n        });\n        this.isAutoFocusing = false;\n      }\n    });\n  }\n  maybeRenderBackdrop() {\n    const {\n      backdropClassName,\n      backdropProps,\n      hasBackdrop,\n      isOpen,\n      transitionDuration,\n      transitionName\n    } = this.props;\n    if (hasBackdrop && isOpen) {\n      return _jsx(CSSTransition, {\n        classNames: transitionName,\n        timeout: transitionDuration,\n        addEndListener: this.handleTransitionAddEnd,\n        children: _jsx(\"div\", {\n          ...backdropProps,\n          className: classNames(Classes.OVERLAY_BACKDROP, backdropClassName, backdropProps === null || backdropProps === void 0 ? void 0 : backdropProps.className),\n          onMouseDown: this.handleBackdropMouseDown\n        })\n      }, \"__backdrop\");\n    } else {\n      return null;\n    }\n  }\n  renderDummyElement(key, props) {\n    const {\n      transitionDuration,\n      transitionName\n    } = this.props;\n    return _jsx(CSSTransition, {\n      classNames: transitionName,\n      addEndListener: this.handleTransitionAddEnd,\n      timeout: transitionDuration,\n      unmountOnExit: true,\n      children: _jsx(\"div\", {\n        tabIndex: 0,\n        ...props\n      })\n    }, key);\n  }\n  overlayWillClose() {\n    document.removeEventListener(\"focus\", this.handleDocumentFocus, /* useCapture */true);\n    document.removeEventListener(\"mousedown\", this.handleDocumentClick);\n    const {\n      openStack\n    } = Overlay;\n    const stackIndex = openStack.indexOf(this);\n    if (stackIndex !== -1) {\n      openStack.splice(stackIndex, 1);\n      if (openStack.length > 0) {\n        const lastOpenedOverlay = Overlay.getLastOpened();\n        // Only bring focus back to last overlay if it had autoFocus _and_ enforceFocus enabled.\n        // If `autoFocus={false}`, it's likely that the overlay never received focus in the first place,\n        // so it would be surprising for us to send it there. See https://github.com/palantir/blueprint/issues/4921\n        if (lastOpenedOverlay.props.autoFocus && lastOpenedOverlay.props.enforceFocus) {\n          lastOpenedOverlay.bringFocusInsideOverlay();\n          document.addEventListener(\"focus\", lastOpenedOverlay.handleDocumentFocus, /* useCapture */true);\n        }\n      }\n      if (openStack.filter(o => o.props.usePortal && o.props.hasBackdrop).length === 0) {\n        document.body.classList.remove(Classes.OVERLAY_OPEN);\n      }\n    }\n  }\n  overlayWillOpen() {\n    const {\n      getLastOpened,\n      openStack\n    } = Overlay;\n    if (openStack.length > 0) {\n      document.removeEventListener(\"focus\", getLastOpened().handleDocumentFocus, /* useCapture */true);\n    }\n    openStack.push(this);\n    if (this.props.autoFocus) {\n      this.isAutoFocusing = true;\n      this.bringFocusInsideOverlay();\n    }\n    if (this.props.enforceFocus) {\n      // Focus events do not bubble, but setting useCapture allows us to listen in and execute\n      // our handler before all others\n      document.addEventListener(\"focus\", this.handleDocumentFocus, /* useCapture */true);\n    }\n    if (this.props.canOutsideClickClose && !this.props.hasBackdrop) {\n      document.addEventListener(\"mousedown\", this.handleDocumentClick);\n    }\n    if (this.props.hasBackdrop && this.props.usePortal) {\n      // add a class to the body to prevent scrolling of content below the overlay\n      document.body.classList.add(Classes.OVERLAY_OPEN);\n    }\n    this.lastActiveElementBeforeOpened = getActiveElement(this.containerElement.current);\n  }\n}\nOverlay.displayName = `${DISPLAYNAME_PREFIX}.Overlay`;\nOverlay.defaultProps = {\n  autoFocus: true,\n  backdropProps: {},\n  canEscapeKeyClose: true,\n  canOutsideClickClose: true,\n  enforceFocus: true,\n  hasBackdrop: true,\n  isOpen: false,\n  lazy: true,\n  shouldReturnFocusOnClose: true,\n  transitionDuration: 300,\n  transitionName: Classes.OVERLAY,\n  usePortal: true\n};\nOverlay.openStack = [];\nOverlay.getLastOpened = () => Overlay.openStack[Overlay.openStack.length - 1];","map":{"version":3,"names":["classNames","Children","cloneElement","createRef","CSSTransition","TransitionGroup","AbstractPureComponent","Classes","DISPLAYNAME_PREFIX","getActiveElement","isFunction","Portal","getKeyboardFocusableElements","Overlay","constructor","isAutoFocusing","state","hasEverOpened","props","isOpen","containerElement","startFocusTrapElement","endFocusTrapElement","maybeRenderChild","child","tabIndex","enforceFocus","autoFocus","undefined","decoratedChild","className","OVERLAY_CONTENT","_jsx","children","onOpening","onOpened","onClosing","transitionDuration","transitionName","onEntering","onEntered","onExiting","onExited","handleTransitionExited","timeout","addEndListener","handleTransitionAddEnd","handleStartFocusTrapElementFocus","e","relatedTarget","_a","current","contains","_b","focus","preventScroll","handleStartFocusTrapElementKeyDown","shiftKey","key","lastFocusableElement","pop","handleEndFocusTrapElementFocus","firstFocusableElement","shift","_c","node","shouldReturnFocusOnClose","lastActiveElementBeforeOpened","HTMLElement","onClosed","call","handleBackdropMouseDown","backdropProps","canOutsideClickClose","onClose","bringFocusInsideOverlay","onMouseDown","handleDocumentClick","eventTarget","composed","composedPath","target","stackIndex","openStack","indexOf","isClickInThisOverlayOrDescendant","slice","some","elem","isSameNode","handleDocumentFocus","Node","preventDefault","stopImmediatePropagation","handleKeyDown","canEscapeKeyClose","stopPropagation","getDerivedStateFromProps","render","lazy","usePortal","childrenWithTransitions","map","maybeBackdrop","maybeRenderBackdrop","unshift","length","renderDummyElement","OVERLAY_START_FOCUS_TRAP","onFocus","onKeyDown","ref","push","OVERLAY_END_FOCUS_TRAP","containerClasses","OVERLAY","OVERLAY_OPEN","OVERLAY_INLINE","transitionGroup","appear","component","portalClassName","container","portalContainer","stopPropagationEvents","portalStopPropagationEvents","componentDidMount","overlayWillOpen","componentDidUpdate","prevProps","overlayWillClose","componentWillUnmount","requestAnimationFrame","activeElement","isFocusOutsideModal","backdropClassName","hasBackdrop","OVERLAY_BACKDROP","unmountOnExit","document","removeEventListener","splice","lastOpenedOverlay","getLastOpened","addEventListener","filter","o","body","classList","remove","add","displayName","defaultProps"],"sources":["/Users/husseingalal/Desktop/Hackathon/Elrond/frontend/node_modules/@blueprintjs/core/src/components/overlay/overlay.tsx"],"sourcesContent":["/*\n * Copyright 2015 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview This component is DEPRECATED, and the code is frozen.\n * All changes & bugfixes should be made to Overlay2 instead.\n */\n\n/* eslint-disable @typescript-eslint/no-deprecated */\n\nimport classNames from \"classnames\";\nimport { Children, cloneElement, createRef } from \"react\";\nimport { CSSTransition, TransitionGroup } from \"react-transition-group\";\n\nimport { AbstractPureComponent, Classes } from \"../../common\";\nimport { DISPLAYNAME_PREFIX, type HTMLDivProps } from \"../../common/props\";\nimport { getActiveElement, isFunction } from \"../../common/utils\";\nimport { Portal } from \"../portal/portal\";\n\nimport type { OverlayProps } from \"./overlayProps\";\nimport { getKeyboardFocusableElements } from \"./overlayUtils\";\n\nexport interface OverlayState {\n    hasEverOpened?: boolean;\n}\n\n/**\n * Overlay component.\n *\n * @deprecated use `Overlay2` instead\n * @see https://blueprintjs.com/docs/#core/components/overlay\n */\nexport class Overlay extends AbstractPureComponent<OverlayProps, OverlayState> {\n    public static displayName = `${DISPLAYNAME_PREFIX}.Overlay`;\n\n    public static defaultProps: OverlayProps = {\n        autoFocus: true,\n        backdropProps: {},\n        canEscapeKeyClose: true,\n        canOutsideClickClose: true,\n        enforceFocus: true,\n        hasBackdrop: true,\n        isOpen: false,\n        lazy: true,\n        shouldReturnFocusOnClose: true,\n        transitionDuration: 300,\n        transitionName: Classes.OVERLAY,\n        usePortal: true,\n    };\n\n    public static getDerivedStateFromProps({ isOpen: hasEverOpened }: OverlayProps) {\n        if (hasEverOpened) {\n            return { hasEverOpened };\n        }\n        return null;\n    }\n\n    private static openStack: Overlay[] = [];\n\n    private static getLastOpened = () => Overlay.openStack[Overlay.openStack.length - 1];\n\n    private isAutoFocusing = false;\n\n    private lastActiveElementBeforeOpened: Element | null | undefined;\n\n    public state: OverlayState = {\n        hasEverOpened: this.props.isOpen,\n    };\n\n    /** Ref for container element, containing all children and the backdrop */\n    public containerElement = createRef<HTMLDivElement>();\n\n    // An empty, keyboard-focusable div at the beginning of the Overlay content\n    private startFocusTrapElement = createRef<HTMLDivElement>();\n\n    // An empty, keyboard-focusable div at the end of the Overlay content\n    private endFocusTrapElement = createRef<HTMLDivElement>();\n\n    public render() {\n        // oh snap! no reason to render anything at all if we're being truly lazy\n        if (this.props.lazy && !this.state.hasEverOpened) {\n            return null;\n        }\n\n        const { autoFocus, children, className, enforceFocus, usePortal, isOpen } = this.props;\n\n        // TransitionGroup types require single array of children; does not support nested arrays.\n        // So we must collapse backdrop and children into one array, and every item must be wrapped in a\n        // Transition element (no ReactText allowed).\n        const childrenWithTransitions = isOpen ? Children.map(children, this.maybeRenderChild) ?? [] : [];\n\n        const maybeBackdrop = this.maybeRenderBackdrop();\n        if (maybeBackdrop !== null) {\n            childrenWithTransitions.unshift(maybeBackdrop);\n        }\n        if (isOpen && (autoFocus || enforceFocus) && childrenWithTransitions.length > 0) {\n            childrenWithTransitions.unshift(\n                this.renderDummyElement(\"__start\", {\n                    className: Classes.OVERLAY_START_FOCUS_TRAP,\n                    onFocus: this.handleStartFocusTrapElementFocus,\n                    onKeyDown: this.handleStartFocusTrapElementKeyDown,\n                    ref: this.startFocusTrapElement,\n                }),\n            );\n            if (enforceFocus) {\n                childrenWithTransitions.push(\n                    this.renderDummyElement(\"__end\", {\n                        className: Classes.OVERLAY_END_FOCUS_TRAP,\n                        onFocus: this.handleEndFocusTrapElementFocus,\n                        ref: this.endFocusTrapElement,\n                    }),\n                );\n            }\n        }\n\n        const containerClasses = classNames(\n            Classes.OVERLAY,\n            {\n                [Classes.OVERLAY_OPEN]: isOpen,\n                [Classes.OVERLAY_INLINE]: !usePortal,\n            },\n            className,\n        );\n\n        const transitionGroup = (\n            <div\n                aria-live=\"polite\"\n                className={containerClasses}\n                onKeyDown={this.handleKeyDown}\n                ref={this.containerElement}\n            >\n                <TransitionGroup appear={true} component={null}>\n                    {childrenWithTransitions}\n                </TransitionGroup>\n            </div>\n        );\n        if (usePortal) {\n            return (\n                <Portal\n                    className={this.props.portalClassName}\n                    container={this.props.portalContainer}\n                    stopPropagationEvents={this.props.portalStopPropagationEvents}\n                >\n                    {transitionGroup}\n                </Portal>\n            );\n        } else {\n            return transitionGroup;\n        }\n    }\n\n    public componentDidMount() {\n        if (this.props.isOpen) {\n            this.overlayWillOpen();\n        }\n    }\n\n    public componentDidUpdate(prevProps: OverlayProps) {\n        if (prevProps.isOpen && !this.props.isOpen) {\n            this.overlayWillClose();\n        } else if (!prevProps.isOpen && this.props.isOpen) {\n            this.overlayWillOpen();\n        }\n    }\n\n    public componentWillUnmount() {\n        this.overlayWillClose();\n    }\n\n    /**\n     * @public for testing\n     * @internal\n     */\n    public bringFocusInsideOverlay() {\n        // always delay focus manipulation to just before repaint to prevent scroll jumping\n        return this.requestAnimationFrame(() => {\n            // container element may be undefined between component mounting and Portal rendering\n            // activeElement may be undefined in some rare cases in IE\n            const activeElement = getActiveElement(this.containerElement.current);\n\n            if (this.containerElement.current == null || activeElement == null || !this.props.isOpen) {\n                return;\n            }\n\n            const container = this.containerElement.current;\n            const isFocusOutsideModal = !container.contains(activeElement);\n            if (isFocusOutsideModal) {\n                this.startFocusTrapElement.current?.focus({ preventScroll: true });\n                this.isAutoFocusing = false;\n            }\n        });\n    }\n\n    private maybeRenderChild = (child?: React.ReactNode | (() => React.ReactNode)) => {\n        if (isFunction(child)) {\n            child = child();\n        }\n\n        if (child == null) {\n            return null;\n        }\n\n        // decorate the child with a few injected props\n        const tabIndex = this.props.enforceFocus || this.props.autoFocus ? 0 : undefined;\n        const decoratedChild =\n            typeof child === \"object\" ? (\n                cloneElement(child as React.ReactElement, {\n                    className: classNames((child as React.ReactElement).props.className, Classes.OVERLAY_CONTENT),\n                    tabIndex,\n                })\n            ) : (\n                <span className={Classes.OVERLAY_CONTENT} tabIndex={tabIndex}>\n                    {child}\n                </span>\n            );\n\n        const { onOpening, onOpened, onClosing, transitionDuration, transitionName } = this.props;\n\n        return (\n            <CSSTransition\n                classNames={transitionName}\n                onEntering={onOpening}\n                onEntered={onOpened}\n                onExiting={onClosing}\n                onExited={this.handleTransitionExited}\n                timeout={transitionDuration}\n                addEndListener={this.handleTransitionAddEnd}\n            >\n                {decoratedChild}\n            </CSSTransition>\n        );\n    };\n\n    private maybeRenderBackdrop() {\n        const { backdropClassName, backdropProps, hasBackdrop, isOpen, transitionDuration, transitionName } =\n            this.props;\n\n        if (hasBackdrop && isOpen) {\n            return (\n                <CSSTransition\n                    classNames={transitionName}\n                    key=\"__backdrop\"\n                    timeout={transitionDuration}\n                    addEndListener={this.handleTransitionAddEnd}\n                >\n                    <div\n                        {...backdropProps}\n                        className={classNames(Classes.OVERLAY_BACKDROP, backdropClassName, backdropProps?.className)}\n                        onMouseDown={this.handleBackdropMouseDown}\n                    />\n                </CSSTransition>\n            );\n        } else {\n            return null;\n        }\n    }\n\n    private renderDummyElement(key: string, props: HTMLDivProps & { ref?: React.Ref<HTMLDivElement> }) {\n        const { transitionDuration, transitionName } = this.props;\n        return (\n            <CSSTransition\n                classNames={transitionName}\n                key={key}\n                addEndListener={this.handleTransitionAddEnd}\n                timeout={transitionDuration}\n                unmountOnExit={true}\n            >\n                <div tabIndex={0} {...props} />\n            </CSSTransition>\n        );\n    }\n\n    /**\n     * Ensures repeatedly pressing shift+tab keeps focus inside the Overlay. Moves focus to\n     * the `endFocusTrapElement` or the first keyboard-focusable element in the Overlay (excluding\n     * the `startFocusTrapElement`), depending on whether the element losing focus is inside the\n     * Overlay.\n     */\n    private handleStartFocusTrapElementFocus = (e: React.FocusEvent<HTMLDivElement>) => {\n        if (!this.props.enforceFocus || this.isAutoFocusing) {\n            return;\n        }\n        // e.relatedTarget will not be defined if this was a programmatic focus event, as is the\n        // case when we call this.bringFocusInsideOverlay() after a user clicked on the backdrop.\n        // Otherwise, we're handling a user interaction, and we should wrap around to the last\n        // element in this transition group.\n        if (\n            e.relatedTarget != null &&\n            this.containerElement.current?.contains(e.relatedTarget as Element) &&\n            e.relatedTarget !== this.endFocusTrapElement.current\n        ) {\n            this.endFocusTrapElement.current?.focus({ preventScroll: true });\n        }\n    };\n\n    /**\n     * Wrap around to the end of the dialog if `enforceFocus` is enabled.\n     */\n    private handleStartFocusTrapElementKeyDown = (e: React.KeyboardEvent<HTMLDivElement>) => {\n        if (!this.props.enforceFocus) {\n            return;\n        }\n        if (e.shiftKey && e.key === \"Tab\") {\n            const lastFocusableElement = getKeyboardFocusableElements(this.containerElement).pop();\n            if (lastFocusableElement != null) {\n                lastFocusableElement.focus();\n            } else {\n                this.endFocusTrapElement.current?.focus({ preventScroll: true });\n            }\n        }\n    };\n\n    /**\n     * Ensures repeatedly pressing tab keeps focus inside the Overlay. Moves focus to the\n     * `startFocusTrapElement` or the last keyboard-focusable element in the Overlay (excluding the\n     * `startFocusTrapElement`), depending on whether the element losing focus is inside the\n     * Overlay.\n     */\n    private handleEndFocusTrapElementFocus = (e: React.FocusEvent<HTMLDivElement>) => {\n        // No need for this.props.enforceFocus check here because this element is only rendered\n        // when that prop is true.\n        // During user interactions, e.relatedTarget will be defined, and we should wrap around to the\n        // \"start focus trap\" element.\n        // Otherwise, we're handling a programmatic focus event, which can only happen after a user\n        // presses shift+tab from the first focusable element in the overlay.\n        if (\n            e.relatedTarget != null &&\n            this.containerElement.current?.contains(e.relatedTarget as Element) &&\n            e.relatedTarget !== this.startFocusTrapElement.current\n        ) {\n            const firstFocusableElement = getKeyboardFocusableElements(this.containerElement).shift();\n            // ensure we don't re-focus an already active element by comparing against e.relatedTarget\n            if (!this.isAutoFocusing && firstFocusableElement != null && firstFocusableElement !== e.relatedTarget) {\n                firstFocusableElement.focus();\n            } else {\n                this.startFocusTrapElement.current?.focus({ preventScroll: true });\n            }\n        } else {\n            const lastFocusableElement = getKeyboardFocusableElements(this.containerElement).pop();\n            if (lastFocusableElement != null) {\n                lastFocusableElement.focus();\n            } else {\n                // Keeps focus within Overlay even if there are no keyboard-focusable children\n                this.startFocusTrapElement.current?.focus({ preventScroll: true });\n            }\n        }\n    };\n\n    private overlayWillClose() {\n        document.removeEventListener(\"focus\", this.handleDocumentFocus, /* useCapture */ true);\n        document.removeEventListener(\"mousedown\", this.handleDocumentClick);\n\n        const { openStack } = Overlay;\n        const stackIndex = openStack.indexOf(this);\n        if (stackIndex !== -1) {\n            openStack.splice(stackIndex, 1);\n            if (openStack.length > 0) {\n                const lastOpenedOverlay = Overlay.getLastOpened();\n                // Only bring focus back to last overlay if it had autoFocus _and_ enforceFocus enabled.\n                // If `autoFocus={false}`, it's likely that the overlay never received focus in the first place,\n                // so it would be surprising for us to send it there. See https://github.com/palantir/blueprint/issues/4921\n                if (lastOpenedOverlay.props.autoFocus && lastOpenedOverlay.props.enforceFocus) {\n                    lastOpenedOverlay.bringFocusInsideOverlay();\n                    document.addEventListener(\"focus\", lastOpenedOverlay.handleDocumentFocus, /* useCapture */ true);\n                }\n            }\n\n            if (openStack.filter(o => o.props.usePortal && o.props.hasBackdrop).length === 0) {\n                document.body.classList.remove(Classes.OVERLAY_OPEN);\n            }\n        }\n    }\n\n    private overlayWillOpen() {\n        const { getLastOpened, openStack } = Overlay;\n        if (openStack.length > 0) {\n            document.removeEventListener(\"focus\", getLastOpened().handleDocumentFocus, /* useCapture */ true);\n        }\n        openStack.push(this);\n\n        if (this.props.autoFocus) {\n            this.isAutoFocusing = true;\n            this.bringFocusInsideOverlay();\n        }\n\n        if (this.props.enforceFocus) {\n            // Focus events do not bubble, but setting useCapture allows us to listen in and execute\n            // our handler before all others\n            document.addEventListener(\"focus\", this.handleDocumentFocus, /* useCapture */ true);\n        }\n\n        if (this.props.canOutsideClickClose && !this.props.hasBackdrop) {\n            document.addEventListener(\"mousedown\", this.handleDocumentClick);\n        }\n\n        if (this.props.hasBackdrop && this.props.usePortal) {\n            // add a class to the body to prevent scrolling of content below the overlay\n            document.body.classList.add(Classes.OVERLAY_OPEN);\n        }\n\n        this.lastActiveElementBeforeOpened = getActiveElement(this.containerElement.current);\n    }\n\n    private handleTransitionExited = (node: HTMLElement) => {\n        if (this.props.shouldReturnFocusOnClose && this.lastActiveElementBeforeOpened instanceof HTMLElement) {\n            this.lastActiveElementBeforeOpened.focus();\n        }\n        this.props.onClosed?.(node);\n    };\n\n    private handleBackdropMouseDown = (e: React.MouseEvent<HTMLDivElement>) => {\n        const { backdropProps, canOutsideClickClose, enforceFocus, onClose } = this.props;\n        if (canOutsideClickClose) {\n            onClose?.(e);\n        }\n        if (enforceFocus) {\n            this.bringFocusInsideOverlay();\n        }\n        backdropProps?.onMouseDown?.(e);\n    };\n\n    private handleDocumentClick = (e: MouseEvent) => {\n        const { canOutsideClickClose, isOpen, onClose } = this.props;\n        // get the actual target even in the Shadow DOM\n        // see https://github.com/palantir/blueprint/issues/4220\n        const eventTarget = (e.composed ? e.composedPath()[0] : e.target) as HTMLElement;\n\n        const stackIndex = Overlay.openStack.indexOf(this);\n        const isClickInThisOverlayOrDescendant = Overlay.openStack\n            .slice(stackIndex)\n            .some(({ containerElement: elem }) => {\n                // `elem` is the container of backdrop & content, so clicking directly on that container\n                // should not count as being \"inside\" the overlay.\n                return elem.current?.contains(eventTarget) && !elem.current.isSameNode(eventTarget);\n            });\n\n        if (isOpen && !isClickInThisOverlayOrDescendant && canOutsideClickClose) {\n            // casting to any because this is a native event\n            onClose?.(e as any);\n        }\n    };\n\n    /**\n     * When multiple Overlays are open, this event handler is only active for the most recently\n     * opened one to avoid Overlays competing with each other for focus.\n     */\n    private handleDocumentFocus = (e: FocusEvent) => {\n        // get the actual target even in the Shadow DOM\n        // see https://github.com/palantir/blueprint/issues/4220\n        const eventTarget = e.composed ? e.composedPath()[0] : e.target;\n        if (\n            this.props.enforceFocus &&\n            this.containerElement.current != null &&\n            eventTarget instanceof Node &&\n            !this.containerElement.current.contains(eventTarget as HTMLElement)\n        ) {\n            // prevent default focus behavior (sometimes auto-scrolls the page)\n            e.preventDefault();\n            e.stopImmediatePropagation();\n            this.bringFocusInsideOverlay();\n        }\n    };\n\n    private handleKeyDown = (e: React.KeyboardEvent<HTMLElement>) => {\n        const { canEscapeKeyClose, onClose } = this.props;\n        if (e.key === \"Escape\" && canEscapeKeyClose) {\n            onClose?.(e);\n            // prevent other overlays from closing\n            e.stopPropagation();\n            // prevent browser-specific escape key behavior (Safari exits fullscreen)\n            e.preventDefault();\n        }\n    };\n\n    private handleTransitionAddEnd = () => {\n        // no-op\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}