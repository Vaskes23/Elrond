{"ast":null,"code":"import { jsx as _jsx } from \"react/jsx-runtime\";\n/* !\n * Copyright 2020 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { AbstractPureComponent, DISPLAYNAME_PREFIX } from \"../../common\";\n/**\n * A stateful wrapper around the low-level <input> component which works around a\n * [React bug](https://github.com/facebook/react/issues/3926). This bug is reproduced when an input\n * receives CompositionEvents (for example, through IME composition) and has its value prop updated\n * asychronously. This might happen if a component chooses to do async validation of a value\n * returned by the input's `onChange` callback.\n *\n * Note: this component does not apply any Blueprint-specific styling.\n */\nexport class AsyncControllableInput extends AbstractPureComponent {\n  constructor() {\n    super(...arguments);\n    this.state = {\n      hasPendingUpdate: false,\n      isComposing: false,\n      nextValue: this.props.value,\n      value: this.props.value\n    };\n    this.cancelPendingCompositionEnd = null;\n    this.handleCompositionStart = e => {\n      var _a, _b, _c;\n      (_a = this.cancelPendingCompositionEnd) === null || _a === void 0 ? void 0 : _a.call(this);\n      this.setState({\n        isComposing: true\n      });\n      (_c = (_b = this.props).onCompositionStart) === null || _c === void 0 ? void 0 : _c.call(_b, e);\n    };\n    this.handleCompositionEnd = e => {\n      var _a, _b;\n      // In some non-latin languages, a keystroke can end a composition event and immediately afterwards start another.\n      // This can lead to unexpected characters showing up in the text input. In order to circumvent this problem, we\n      // use a timeout which creates a delay which merges the two composition events, creating a more natural and predictable UX.\n      // `this.state.nextValue` will become \"locked\" (it cannot be overwritten by the `value` prop) until a delay (10ms) has\n      // passed without a new composition event starting.\n      this.cancelPendingCompositionEnd = this.setTimeout(() => this.setState({\n        isComposing: false\n      }), AsyncControllableInput.COMPOSITION_END_DELAY);\n      (_b = (_a = this.props).onCompositionEnd) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n    };\n    this.handleChange = e => {\n      var _a, _b;\n      const {\n        value\n      } = e.target;\n      this.setState({\n        nextValue: value\n      });\n      (_b = (_a = this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n    };\n  }\n  static getDerivedStateFromProps(nextProps, nextState) {\n    if (nextState.isComposing || nextProps.value === undefined) {\n      // don't derive anything from props if:\n      // - in uncontrolled mode, OR\n      // - currently composing, since we'll do that after composition ends\n      return null;\n    }\n    const userTriggeredUpdate = nextState.nextValue !== nextState.value;\n    if (userTriggeredUpdate) {\n      if (nextProps.value === nextState.nextValue) {\n        // parent has processed and accepted our update\n        if (nextState.hasPendingUpdate) {\n          return {\n            hasPendingUpdate: false,\n            value: nextProps.value\n          };\n        } else {\n          return {\n            value: nextState.nextValue\n          };\n        }\n      } else {\n        if (nextProps.value === nextState.value) {\n          // we have sent the update to our parent, but it has not been processed yet. just wait.\n          // DO NOT set nextValue here, since that will temporarily render a potentially stale controlled value,\n          // causing the cursor to jump once the new value is accepted\n          return {\n            hasPendingUpdate: true\n          };\n        }\n        // accept controlled update overriding user action\n        return {\n          hasPendingUpdate: false,\n          nextValue: nextProps.value,\n          value: nextProps.value\n        };\n      }\n    } else {\n      // accept controlled update, could be confirming or denying user action\n      return {\n        hasPendingUpdate: false,\n        nextValue: nextProps.value,\n        value: nextProps.value\n      };\n    }\n  }\n  render() {\n    const {\n      isComposing,\n      hasPendingUpdate,\n      value,\n      nextValue\n    } = this.state;\n    const {\n      inputRef,\n      ...restProps\n    } = this.props;\n    return _jsx(\"input\", {\n      ...restProps,\n      ref: inputRef,\n      // render the pending value even if it is not confirmed by a parent's async controlled update\n      // so that the cursor does not jump to the end of input as reported in\n      // https://github.com/palantir/blueprint/issues/4298\n      value: isComposing || hasPendingUpdate ? nextValue : value,\n      onCompositionStart: this.handleCompositionStart,\n      onCompositionEnd: this.handleCompositionEnd,\n      onChange: this.handleChange\n    });\n  }\n}\nAsyncControllableInput.displayName = `${DISPLAYNAME_PREFIX}.AsyncControllableInput`;\n/**\n * The amount of time (in milliseconds) which the input will wait after a compositionEnd event before\n * unlocking its state value for external updates via props. See `handleCompositionEnd` for more details.\n */\nAsyncControllableInput.COMPOSITION_END_DELAY = 10;","map":{"version":3,"names":["AbstractPureComponent","DISPLAYNAME_PREFIX","AsyncControllableInput","constructor","state","hasPendingUpdate","isComposing","nextValue","props","value","cancelPendingCompositionEnd","handleCompositionStart","e","_a","call","setState","_c","_b","onCompositionStart","handleCompositionEnd","setTimeout","COMPOSITION_END_DELAY","onCompositionEnd","handleChange","target","onChange","getDerivedStateFromProps","nextProps","nextState","undefined","userTriggeredUpdate","render","inputRef","restProps","_jsx","ref","displayName"],"sources":["/Users/husseingalal/Desktop/Hackathon/Elrond/frontend/node_modules/@blueprintjs/core/src/components/forms/asyncControllableInput.tsx"],"sourcesContent":["/* !\n * Copyright 2020 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { AbstractPureComponent, DISPLAYNAME_PREFIX } from \"../../common\";\n\nexport type AsyncControllableInputProps = React.InputHTMLAttributes<HTMLInputElement> & {\n    inputRef?: React.Ref<HTMLInputElement>;\n};\n\ntype InputValue = AsyncControllableInputProps[\"value\"];\n\nexport interface AsyncControllableInputState {\n    /**\n     * Whether we are in the middle of a composition event.\n     *\n     * @default false\n     */\n    isComposing: boolean;\n\n    /**\n     * The source of truth for the input value. This is not updated during IME composition.\n     * It may be updated by a parent component.\n     *\n     * @default \"\"\n     */\n    value: InputValue;\n\n    /**\n     * The latest input value, which updates during IME composition. Defaults to props.value.\n     */\n    nextValue: InputValue;\n\n    /**\n     * Whether there is a pending update we are expecting from a parent component.\n     *\n     * @default false\n     */\n    hasPendingUpdate: boolean;\n}\n\n/**\n * A stateful wrapper around the low-level <input> component which works around a\n * [React bug](https://github.com/facebook/react/issues/3926). This bug is reproduced when an input\n * receives CompositionEvents (for example, through IME composition) and has its value prop updated\n * asychronously. This might happen if a component chooses to do async validation of a value\n * returned by the input's `onChange` callback.\n *\n * Note: this component does not apply any Blueprint-specific styling.\n */\nexport class AsyncControllableInput extends AbstractPureComponent<\n    AsyncControllableInputProps,\n    AsyncControllableInputState\n> {\n    public static displayName = `${DISPLAYNAME_PREFIX}.AsyncControllableInput`;\n\n    /**\n     * The amount of time (in milliseconds) which the input will wait after a compositionEnd event before\n     * unlocking its state value for external updates via props. See `handleCompositionEnd` for more details.\n     */\n    public static COMPOSITION_END_DELAY = 10;\n\n    public state: AsyncControllableInputState = {\n        hasPendingUpdate: false,\n        isComposing: false,\n        nextValue: this.props.value,\n        value: this.props.value,\n    };\n\n    private cancelPendingCompositionEnd: (() => void) | null = null;\n\n    public static getDerivedStateFromProps(\n        nextProps: AsyncControllableInputProps,\n        nextState: AsyncControllableInputState,\n    ): Partial<AsyncControllableInputState> | null {\n        if (nextState.isComposing || nextProps.value === undefined) {\n            // don't derive anything from props if:\n            // - in uncontrolled mode, OR\n            // - currently composing, since we'll do that after composition ends\n            return null;\n        }\n\n        const userTriggeredUpdate = nextState.nextValue !== nextState.value;\n\n        if (userTriggeredUpdate) {\n            if (nextProps.value === nextState.nextValue) {\n                // parent has processed and accepted our update\n                if (nextState.hasPendingUpdate) {\n                    return { hasPendingUpdate: false, value: nextProps.value };\n                } else {\n                    return { value: nextState.nextValue };\n                }\n            } else {\n                if (nextProps.value === nextState.value) {\n                    // we have sent the update to our parent, but it has not been processed yet. just wait.\n                    // DO NOT set nextValue here, since that will temporarily render a potentially stale controlled value,\n                    // causing the cursor to jump once the new value is accepted\n                    return { hasPendingUpdate: true };\n                }\n                // accept controlled update overriding user action\n                return { hasPendingUpdate: false, nextValue: nextProps.value, value: nextProps.value };\n            }\n        } else {\n            // accept controlled update, could be confirming or denying user action\n            return { hasPendingUpdate: false, nextValue: nextProps.value, value: nextProps.value };\n        }\n    }\n\n    public render() {\n        const { isComposing, hasPendingUpdate, value, nextValue } = this.state;\n        const { inputRef, ...restProps } = this.props;\n        return (\n            <input\n                {...restProps}\n                ref={inputRef}\n                // render the pending value even if it is not confirmed by a parent's async controlled update\n                // so that the cursor does not jump to the end of input as reported in\n                // https://github.com/palantir/blueprint/issues/4298\n                value={isComposing || hasPendingUpdate ? nextValue : value}\n                onCompositionStart={this.handleCompositionStart}\n                onCompositionEnd={this.handleCompositionEnd}\n                onChange={this.handleChange}\n            />\n        );\n    }\n\n    private handleCompositionStart = (e: React.CompositionEvent<HTMLInputElement>) => {\n        this.cancelPendingCompositionEnd?.();\n        this.setState({ isComposing: true });\n        this.props.onCompositionStart?.(e);\n    };\n\n    private handleCompositionEnd = (e: React.CompositionEvent<HTMLInputElement>) => {\n        // In some non-latin languages, a keystroke can end a composition event and immediately afterwards start another.\n        // This can lead to unexpected characters showing up in the text input. In order to circumvent this problem, we\n        // use a timeout which creates a delay which merges the two composition events, creating a more natural and predictable UX.\n        // `this.state.nextValue` will become \"locked\" (it cannot be overwritten by the `value` prop) until a delay (10ms) has\n        // passed without a new composition event starting.\n        this.cancelPendingCompositionEnd = this.setTimeout(\n            () => this.setState({ isComposing: false }),\n            AsyncControllableInput.COMPOSITION_END_DELAY,\n        );\n        this.props.onCompositionEnd?.(e);\n    };\n\n    private handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n        const { value } = e.target;\n\n        this.setState({ nextValue: value });\n        this.props.onChange?.(e);\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}